<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Skedaddle Mobile Map Maker</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, interactive-widget=resizes-content"/>
<meta name="theme-color" content="#0d1117">
<!-- Added jsPDF for PDF generation -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

<!-- 1. Google Identity Services (GIS) for OAuth 2.0 -->
<script src="https://accounts.google.com/gsi/client" async defer></script>
<!-- 2. Google API Client Library (GAPI) for REST calls (Drive, Picker) -->
<script src="https://apis.google.com/js/api.js"></script>
<!-- 3. Google Picker API (uses GAPI) - MUST BE LOADED HERE -->
<script src="https://www.google.com/jsapi?autoload={'modules':[{'name':'picker','version':'1.0','callback':'pickerLoaded'}]}"></script>

<style>
:root{--bg:#0d1117;--panel:#141a24;--text:#e8eef6;--accent:#64b5ff;--border:#243148;--border2:#1b2435;
      /* Festive colors for splash screen retained */
      --festive-red: #cc3333;
      --festive-gold: #ffcc66;
}
*{box-sizing:border-box; -webkit-tap-highlight-color: transparent;}
html,body{height:100%;height:100dvh;overflow:hidden;background:#000000;} 
body.blurred #app{filter:blur(18px);pointer-events:none}

/* Gate / Landing - Restored Festive Styles */
#gate{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:999;background:rgba(5,7,10,.85);backdrop-filter:blur(24px);transition:opacity .35s,visibility .35s;padding:16px}
#gate.hide{opacity:0;visibility:hidden;pointer-events:none;}
.gcard{
    background:#0e1421;
    border:1px solid var(--festive-gold); /* Subtle Gold border retained */
    border-radius:18px;
    padding:28px; /* Increased padding retained */
    width:min(460px,100%);
    text-align:center;
    box-shadow:0 10px 60px rgba(rgba(204, 51, 51, 1),.4); /* Red glow effect retained */
    position: relative; /* Needed for close button positioning */
}
/* New Close Button Style */
.close-btn {
    position: absolute;
    top: 10px;
    right: 10px;
    background: none;
    border: none;
    color: var(--text);
    font-size: 24px;
    font-weight: bold;
    cursor: pointer;
    line-height: 1;
    padding: 5px;
    opacity: 0.7;
    transition: opacity 0.2s;
    display: none; /* Hidden by default */
}
.close-btn:hover {
    opacity: 1.0;
}


.gcard h2{
    margin:8px 0 4px;
    font-size:24px; /* Larger title retained */
    color:var(--festive-gold); /* Gold title text retained */
    text-shadow: 0 0 5px rgba(255,200,100,0.5);
}
.gcard p{margin:0 0 20px;color:#c7d3ea;font-size:14px} /* Larger paragraph text retained */
.gbtn{background:#121a2c;border:1px solid #334365;color:#e8eef6;padding:14px 16px;border-radius:12px;cursor:pointer;min-width:100%;margin-bottom:8px;font-size:15px}
.grow{display:flex;flex-direction:column;gap:8px}

/* Fix for file inputs on mobile: don't use display:none */
.grow input[type=file], label.file input {
    position: absolute; width: 1px; height: 1px; padding: 0; margin: -1px;
    overflow: hidden; clip: rect(0,0,0,0); border: 0; visibility: visible;
}

/* App Layout */
#app{display:flex;flex-direction:column;height:100%;background:#05070a;}
header{flex:0 0 60px;display:flex;align-items:center;gap:8px;padding:8px;background:#0a0f18;border-bottom:1px solid var(--border2);overflow-x:auto;white-space:nowrap;-webkit-overflow-scrolling:touch;scrollbar-width:none}
header::-webkit-scrollbar{display:none}

/* Header Elements */
#logoBtn{border:none;background:transparent;cursor:pointer;padding:4px;margin-right:4px;flex:0 0 auto}
#logo{width:42px;height:42px;border-radius:10px;border:1px solid #38507a;background:#0b0f18}
h1{margin:0 12px 0 0;font-size:16px;color:#d6eef6;display:inline-block;vertical-align:middle}

/* Buttons */
.btn,label.file,.pill{
  background:var(--panel);border:1px solid var(--border);color:var(--text);border-radius:10px;
  padding:0 14px;cursor:pointer;display:inline-flex;align-items:center;justify-content:center;
  gap:8px;font-size:13px;height:42px;flex:0 0 auto;white-space:nowrap;
}
.btn:disabled{opacity:0.5;cursor:not-allowed}
.btn:hover:not(:disabled),label.file:hover{background:#192235;border-color:#3c4a66}
.pill{background:#10182b;cursor:pointer;border-color:var(--accent);color:var(--accent)}

/* Toggle Button Active State */
.btn.toggled {
    background: #1c3a5e;
    border-color: #64b5ff;
    color: #64b5ff;
}

/* Dropdown */
.dropdown-container { position: relative; display: inline-block; }
.dropdown-content {
    display: none;
    position: absolute;
    right: 0;
    top: 48px;
    background: var(--panel);
    border: 1px solid var(--border);
    border-radius: 10px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
    min-width: 150px;
    z-index: 100;
    overflow: hidden;
}
.dropdown-content button {
    width: 100%;
    padding: 10px 14px;
    background: transparent;
    border: none;
    text-align: left;
    font-size: 13px;
    color: var(--text);
    cursor: pointer;
}
.dropdown-content button:hover {
    background: #192235;
}

/* Main Area */
.wrap{flex:1;display:flex;position:relative;overflow:hidden}
main{flex:1;display:flex;flex-direction:column;position:relative;background:#000;}

.canvasWrap{
    flex:1;display:flex;align-items:center;justify-content:center;overflow:hidden;position:relative;
    background:#0b0f19;
    /* SUGGESTION 1: Add subtle shadow to lift map off background */
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.5); 
}
/* ABSOLUTE POSITIONING FOR CANVAS */
canvas{
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: transparent; 
    box-shadow:0 0 0 1px var(--border2);
    touch-action:none;
    display:block;
}

/* NEW: Style for blank map background */
body.white-bg .canvasWrap {
    background: white;
}

/* Sidebar / Drawer */
aside{
  width:320px;background:#111726;border-right:1px solid var(--border2);display:flex;flex-direction:column;
  overflow-y:auto;padding:12px;transition:transform .25s cubic-bezier(0.2,0.8,0.2,1);z-index:20;
}
.overlay{position:fixed;inset:0;background:rgba(0,0,0,0.6);z-index:19;opacity:0;pointer-events:none;transition:opacity .25s}
.overlay.show{opacity:1;pointer-events:auto}

/* Tools & Inputs */
.group{background:var(--panel);border:1px solid var(--border);border-radius:14px;padding:12px;margin-bottom:12px}
.group h3{margin:0 0 10px;font-size:13px;color:#cfe2ff;letter-spacing:.3px;text-transform:uppercase}
.input{width:100%;background:#0b1222;border:1px solid var(--border);color:var(--text);border-radius:8px;padding:10px;font-size:14px;font-family:inherit}
textarea.input{resize:vertical;min-height:80px}
.row2{display:grid;grid-template-columns:1fr 1fr;gap:8px}
.lbl-row{display:grid;grid-template-columns:1fr 1fr;gap:8px; margin-bottom:4px; font-size:11px; color:#8b9bb4; padding-left:4px;}
.acc{border:1px solid var(--border);border-radius:12px;background:#11182a;margin-bottom:8px}
.accHead{display:flex;align-items:center;justify-content:space-between;cursor:pointer;padding:12px}
.accHead b{color:#9fc3ff;font-size:14px}.accBody{display:none;padding:10px;border-top:1px solid var(--border)}.acc.open .accBody{display:block}
.grid4{display:grid;grid-template-columns:repeat(auto-fill, minmax(70px, 1fr));gap:6px}
.tool{
    background:#0e1527;border:1px solid var(--border);color:var(--text);border-radius:10px;padding:12px 6px;text-align:center;font-size:12px;cursor:pointer;min-height:48px;display:flex;align-items:center;justify-content:center;line-height:1.1;
    /* SUGGESTION 3: Subtle visual cue for active tool */
    transition: all 0.15s ease-out;
}
.tool.active{
    outline:2px solid var(--accent);
    background:#1c263a;
    box-shadow: 0 0 8px rgba(100, 181, 255, 0.3);
    transform: translateY(-1px);
}

/* Clip Legend Style */
.clip-legend {
    padding: 8px 0;
    font-size: 12px;
    color: #9fc3ff;
}
.clip-legend dt {
    font-weight: bold;
    color: var(--accent);
    width: 30px;
    float: left;
    clear: left;
}
.clip-legend dd {
    margin-left: 40px;
    margin-bottom: 4px;
    color: var(--text);
}

/* Style for Clip/FRA container to align elements on one line */
.clip-fra-container {
    display: flex;
    align-items: center; /* Vertically align items */
    gap: 4px; /* Small space between dropdown and checkbox */
    flex-wrap: wrap; /* Allow wrap for small screen sizes */
}
.clip-fra-container label {
    margin-right: 8px; /* Space between FRA and Gutter Guard */
}
/* FIX: Ensure FRA/GG labels (and checkbox text) are visible */
.fra-checkbox-label, .gg-checkbox-label {
    font-size: 12px;
    white-space: nowrap;
    display: flex; /* Ensure checkbox and text align */
    align-items: center;
    color: var(--text); /* Set text color to white/light */
}
.fra-checkbox-label input, .gg-checkbox-label input {
    margin-right: 2px; /* Small space between box and text */
}

/* FIX: Ensure visibility of scale labels and bulk color label */
.group .slider-container ~ div {
    color: var(--text); /* Make 'Small'/'Large' labels white/light gray */
}
.group > div[style*="font-size:12px"] {
    color: var(--text) !important; /* Targeting 'Line/Path Scale' etc. */
}
.group > div[style*="margin-top:8px"] {
    color: var(--text) !important; /* Targeting 'Bulk Colour:' */
}
/* END FIX */


/* Length Table Drawer (Bottom Sheet style on mobile) */
#lenWrap{
  background:#0d1526;border-top:1px solid var(--border);
  position:absolute;bottom:0;left:0;right:0;max-height:50%;display:flex;flex-direction:column;z-index:10;
  transition:transform .3s;transform:translateY(calc(100% - 44px));
}
#lenWrap.open{transform:translateY(0)}
/* FIX: Set text color for the lenHead and the span text */
#lenHead{
    display:flex;justify-content:space-between;align-items:center;padding:10px 16px;background:#0f1729;
    cursor:pointer;height:44px;flex:0 0 44px;
    color: var(--text); /* Main "Line Information" text color */
}
#lenHead small {
    color: #a0b0c0; /* Slightly dimmer secondary text */
}
#lenBody{overflow-y:auto;flex:1;background:#0d1526;padding-bottom:20px;}
table{width:100%;border-collapse:collapse;min-width:100%;} 
/* FIX: Ensure table cells text is white */
th,td{border-top:1px solid var(--border);padding:8px 10px;font-size:13px;text-align:left; color: var(--text);}
th{color:#9fc3ff;text-align:left;background:#0f1729;position:sticky;top:0;z-index:2;}
.edit{width:100%;background:#0b1222;border:1px solid var(--border);color:var(--text);border-radius:6px;padding:6px}
select.edit { width: 100%; }
.xbtn{background:#32121d;border:1px solid #5b2034;color:#ffa0ae;border-radius:6px;padding:6px 12px;cursor:pointer}

/* Popups */
.pop{position:fixed;z-index:9999;background:#0f1727;border:1px solid #456;border-radius:12px;display:none;padding:8px;gap:8px;box-shadow:0 10px 40px rgba(0,0,0,0.5)}
.pop button{background:#151b2b;border:1px solid #345;color:#fff;border-radius:8px;padding:10px 14px;cursor:pointer;font-size:14px;flex:1}

/* Modal for Back/Warn, Save Validation, Cache List */
#modalBack, #modalAlert {
    position:fixed; inset:0; background:rgba(0,0,0,0.7); z-index:10000; display:none; 
    align-items:center; justify-content:center; backdrop-filter:blur(5px);
}
#modalBack .card, #modalAlert .card {
    background:#111827; border:1px solid #374151; border-radius:16px; padding:24px; 
    width:80%; max-width:min(500px, 90%); text-align:center;
}
#modalBack h3, #modalAlert h3 { margin:0 0 10px; color:#f87171; font-size:18px; }
#modalBack p, #modalAlert p { margin:0 0 20px; color:#d1d5db; font-size:14px; }
#modalBack .row, #modalAlert .row { display:flex; gap:10px; justify-content: center;}
#modalBack .row button, #modalAlert .row button { flex:1; padding:12px; border-radius:8px; border:none; cursor:pointer; font-weight:bold; }
#modalBack .btn-stay { background:#374151; color:white; }
#modalBack .btn-leave { background:#ef4444; color:white; }
#modalAlert .btn-ok { background:#3b82f6; color:white; width:100%; }

/* Cord Label Editor */
#lblEditor {
    position:fixed; z-index:5000;
    transform:translate(-50%, -120%); /* Center above point */
}
#lblInput {
    background:#111827; color:#fff; border:1px solid #3b82f6; 
    padding:4px 8px; border-radius:6px; font-size:12px; width:80px; text-align:center;
    box-shadow: 0 4px 10px rgba(0,0,0,0.5);
}

select.edit {
    width: 100%;
    background: #0b1222;
    border: 1px solid var(--border);
    color: var(--text);
    border-radius: 6px;
    padding: 6px;
}

/* --- CUSTOM SLIDER STYLING (Sleek Update) --- */
.slider-container {
    padding: 12px 6px 16px;
    position: relative;
    user-select: none;
    -webkit-user-select: none;
    touch-action: none;
}
input[type=range].input {
    width: 100%;
    height: 6px; /* Define track height */
    margin: 0;
    -webkit-appearance: none;
    appearance: none;
    background: transparent;
    cursor: pointer;
    padding: 0; /* Remove internal padding */
}
input[type=range].input::-webkit-slider-runnable-track {
    height: 6px;
    background: #243148;
    border-radius: 3px;
    transition: background 0.2s;
}
input[type=range].input::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 16px;
    height: 16px;
    background: var(--accent);
    border: 3px solid var(--panel);
    border-radius: 50%;
    margin-top: -5px; /* Center thumb vertically */
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.4);
    transition: background 0.2s, box-shadow 0.2s;
}
input[type=range].input:active::-webkit-slider-thumb {
    background: #3f9bff;
    box-shadow: 0 0 0 8px rgba(100, 181, 255, 0.2);
}

/* Mobile Specifics */
@media (max-width:900px){
  aside{position:absolute;top:0;bottom:0;left:0;transform:translateX(-105%);box-shadow:5px 0 25px rgba(0,0,0,.5)}
  aside.open{transform:translateX(0)}
  #lenWrap{width:100%}
  h1{display:none} /* Hide title on phone to save space */
  header .btn {padding:0 12px}
}
</style>
</head>
<body class="blurred">
<div id="gate">
  <div class="gcard">
    <!-- NEW CLOSE BUTTON -->
    <button class="close-btn" id="closeGateBtn" onclick="unlock()" title="Continue Editing">&times;</button>
    <img src="https://i.imgur.com/zdJfkpg.png" alt="logo" style="width:84px;height:84px;border-radius:16px;margin-bottom:16px; border: 2px solid var(--festive-gold);"><br/>
    <h2>Skedaddle Christmas Map Maker</h2>
    <p style="margin-top:12px">Upload a photo or load a saved map to begin.</p>
    <div class="grow">
      <!-- Standard Load/Upload -->
      <button id="gPickImg" class="gbtn">üì∑ Upload Image</button>
      <button id="gPickBlank" class="gbtn">‚¨ú Start Blank Map</button>
      <button id="gPickMap" class="gbtn">üìÇ Load Map (.skmap)</button>
      
      <!-- ADDED SAVE TO DRIVE BUTTON -->
      <button id="gSaveDrive" class="gbtn" disabled>‚òÅÔ∏è Save to Drive</button>
      <button id="gLoadDrive" class="gbtn" disabled>‚òÅÔ∏è Load from Drive</button>

      <input id="gImg" type="file" accept="image/*"/>
      <input id="gMap" type="file" accept=".skmap,.json,application/json"/>
    </div>
  </div>
</div>

<!-- Modals -->
<div id="modalBack">
    <div class="card">
        <h3>Wait!</h3>
        <p>If you swipe back now, you will lose all progress. Are you sure?</p>
        <div class="row"><button id="btnStay" class="btn-stay">No, Stay</button><button id="btnLeave" class="btn-leave">Yes, Leave</button></div>
    </div>
</div>
<div id="modalAlert">
    <div class="card">
        <h3>Alert</h3>
        <p id="alertMsg">Message</p>
        <div class="row"><button onclick="document.getElementById('modalAlert').style.display='none'" class="btn-ok">OK</button></div>
</div>
</div>

<!-- Save Validation Modal (Removed - Not needed for local saves) -->

<!-- Cord Label Editor -->
<div id="lblEditor"><input id="lblInput" placeholder="Ft/Note"></div>

<!-- Move/Delete Popup (Always fixed to the window) -->
<div id="movePop" class="pop" style="display: none; flex-direction: row; gap: 8px;">
  <button id="moveToolBtn" title="Move Object">‚úã Move</button>
  <button id="moveLabelToolBtn" title="Move Label">‚ÜîÔ∏è Move Label</button>
  <button id="deleteToolBtn" title="Delete Object">üóëÔ∏è Delete</button>
</div>

<div id="app">
<header>
  <button id="logoBtn" title="Menu"><img id="logo" src="https://i.imgur.com/zdJfkpg.png" alt=""></button>
  <h1>Skedaddle</h1>
  <span id="modeTag" class="pill" onclick="toggleMenu()">Draw</span>
  
  <!-- REQUIRED ORDER: Draw, Select, Undo, Finish Line, Redo, Label, Snap, Reset View, Night View, Save All -->
  <button id="btnDraw" class="btn">‚úèÔ∏è</button>
  <button id="btnSelect" class="btn">üñ±Ô∏è</button>
  
  <!-- Undo (Icon Only) -->
  <button id="btnUndo" class="btn" title="Undo">‚Ü©Ô∏è</button>

  <!-- Swag Toggle (Tool-specific, moved left of Finish Line for Garland) -->
  <button id="btnSwag" class="btn" title="Toggle Swag/Curves (Garland Only)" style="display:none">„Ä∞Ô∏è Swag</button>
  
  <!-- Finish Line -->
  <button id="btnComplete" class="btn" disabled>‚úÖ Finish Line</button>

  <!-- NEW Pillar Garland Toggle (Tool-specific) -->
  <button id="btnPillar" class="btn" title="Toggle Pillar Garland (Dotted every 2nd line)" style="display:none">üèõÔ∏è Pillar</button>

  <!-- Redo (Icon Only) -->
  <button id="btnRedo" class="btn" disabled title="Redo">‚Ü™Ô∏è</button>

  <!-- NEW Label Button (Puts label wherever clicked) -->
  <button id="btnLabel" class="btn">üè∑Ô∏è</button>
  
  <!-- Snap Toggle -->
  <button id="btnSnap" class="btn toggled" title="Toggle Snap to End/Junction">üß≤ Snap</button>

  <!-- Reset View -->
  <!-- ADDED ZOOM BUTTONS HERE -->
  <button id="btnZoomIn" class="btn" title="Zoom In">‚ûï</button>
  <button id="btnZoomOut" class="btn" title="Zoom Out">‚ûñ</button>
  <button id="btnFit" class="btn">üîÑ Reset View</button>
  
  <!-- Night View -->
  <button id="btnNightMode" class="btn" title="Toggle Night View">üåô Night View</button>

  <!-- Consolidated Save/Export Buttons -->
  <div class="dropdown-container">
      <button id="btnSaveAll" class="btn">üíæ Save All</button>
      <div id="saveDropdown" class="dropdown-content">
          <button id="btnSaveMapOnly">üíæ Save Map Only (.skmap)</button>
          <button id="btnSaveImageOnly">üì§ Save Map as PDF (.pdf)</button>
          <!-- ADDED SAVE TO DRIVE DROPDOWN BUTTON -->
          <button id="btnSaveDriveOnly">‚òÅÔ∏è Save to Drive</button>
      </div>
  </div>
</header>

<div class="wrap">
  <div id="overlay" class="overlay"></div>
  <aside id="side">
    <div class="group">
      <h3>Tools</h3>
      <div id="accWrap"></div>
    </div>
    
    <div class="group">
      <h3>Job Details</h3>
      <input id="customer" class="input" placeholder="Customer Name"/>
      <input id="address" class="input" placeholder="Address" style="margin-top:8px"/>
      <textarea id="jobNotes" class="input" placeholder="Job site notes..." style="margin-top:8px"></textarea>
      
      <!-- MOVED BULK COLOUR INPUT TO JOB DETAILS SECTION -->
      <div style="font-size:12px;color:#8b9bb4;margin-top:8px;">Bulk Colour:</div>
      <input id="inputAllCol" class="input" placeholder="Set ALL colors (C9s, Windows)..." style="margin-top:4px">

    </div>
    
    <div class="group">
        <h3>Timers</h3>
        <div id="timerInputs">
            <div class="lbl-row"><span>On</span><span>Off</span></div>
            <div class="row2"><input id="on1" type="time" class="input"/><input id="off1" type="time" class="input"/></div>
            <div class="lbl-row" style="margin-top:8px"><span>On</span><span>Off</span></div>
            <div class="row2"><input id="on2" type="time" class="input"/><input id="off2" type="time" class="input"/></div>
            <button id="btnStd" class="btn" style="width:100%;margin-top:8px">Set Standard Times</button>
        </div>
        
        <!-- Customer Controlled Toggle -->
        <button id="btnCustomerControlled" class="btn" style="width:100%;margin-top:8px">Customer Controlled</button>
    </div>
    
    <!-- MOVED SCALE & SIZE SECTION HERE -->
    <div class="group">
      <h3>Scale & Size</h3>
      
      <!-- Line Scale Slider -->
      <div style="font-size:12px; margin-bottom:8px;">Line/Path Scale</div>
      <div class="slider-container" id="lineScaleContainer">
          <input id="lineScaleInput" type="range" class="input" min="0.5" max="3" step="0.1" value="1.5"/>
          <div style="font-size:11px; color:#8b9bb4; display:flex; justify-content:space-between; margin-top: -10px;">
              <span>Thin</span><span id="lineScaleValue">1.5x</span><span>Thick</span>
          </div>
      </div>
      
      <!-- NEW Power Direction Arrow Frequency Slider -->
      <div style="font-size:12px; margin-top:12px; margin-bottom:8px;">Power Direction Arrow Frequency</div>
      <div class="slider-container" id="arrowFreqContainer">
          <input id="arrowFreqInput" type="range" class="input" min="0.5" max="2.0" step="0.1" value="1.0"/>
          <div style="font-size:11px; color:#8b9bb4; display:flex; justify-content:space-between; margin-top: -10px;">
              <span>Small</span><span id="arrowFreqValue">1.0x</span><span>More Arrows</span>
          </div>
      </div>

      <!-- Icon Scale Slider (Wreaths, Trees, Bows) -->
      <div style="font-size:12px; margin-top:12px; margin-bottom:8px;">Decorations Scale (Wreaths, Trees, Bows)</div>
      <div class="slider-container" id="iconScaleContainer">
          <!-- UPDATED MAX TO 5.0 -->
          <input id="iconScaleInput" type="range" class="input" min="0.5" max="5" step="0.1" value="1.5"/>
          <div style="font-size:11px; color:#8b9bb4; display:flex; justify-content:space-between; margin-top: -10px;">
              <span>Small</span><span id="iconScaleValue">1.5x</span><span>Huge</span>
          </div>
      </div>
      
      <!-- Junction Scale Slider (Power, 3-Way) -->
      <div style="font-size:12px; margin-top:12px; margin-bottom:8px;">Junctions Scale (Power, 3-Way)</div>
      <div class="slider-container" id="junctionScaleContainer">
          <input id="junctionScaleInput" type="range" class="input" min="0.5" max="3" step="0.1" value="1.0"/>
          <div style="font-size:11px; color:#8b9bb4; display:flex; justify-content:space-between; margin-top: -10px;">
              <span>Small</span><span id="junctionScaleValue">1.0x</span><span>Large</span>
          </div>
      </div>

      <!-- Label Scale Slider (NEW) -->
      <div style="font-size:12px; margin-top:12px; margin-bottom:8px;">Label Scale</div>
      <div class="slider-container" id="labelScaleContainer">
          <!-- UPDATED: Set default value to maximum (3.0) -->
          <input id="labelScaleInput" type="range" class="input" min="0.5" max="3" step="0.1" value="3.0"/>
          <div style="font-size:11px; color:#8b9bb4; display:flex; justify-content:space-between; margin-top: -10px;">
              <span>Small</span><span id="labelScaleValue">3.0x</span><span>Large</span>
          </div>
      </div>
    </div>
    
    <!-- Clip Legend added back below Timer section -->
    <div class="group">
        <h3>Clip Types</h3>
        <dl class="clip-legend">
            <dt>ST:</dt><dd>Shingle Tab (Eaves/Ridges)</dd>
            <dt>T:</dt><dd>Tuff Clip (Fascia)</dd>
            <dt>Mag:</dt><dd>Magnetic Clip</dd>
            <dt>FRA:</dt><dd>Flat Roof Adapter (Used with ST)</dd>
            <dt>GG:</dt><dd>Gutter Guard (Used with T/ST on Fascia)</dd>
        </dl>
    </div>
    
  </aside>

  <main>
    <div class="canvasWrap"><canvas id="cv"></canvas></div>
    <div id="lenWrap">
      <div id="lenHead"><div>üìè Line Information <small>(Tap to view)</small></div><span>‚ñ≤</span></div>
      <div id="lenBody">
        <div style="padding:8px 12px;background:#0f1729;border-bottom:1px solid var(--border);display:flex;align-items:center;gap:10px;flex-wrap:wrap">
             <label style="display:flex;align-items:center;gap:5px;font-size:12px;color:#cfe2ff;">
                <input id="chkAutoCalc" type="checkbox" checked/> Auto-calc
             </label>
             <!-- BULK COLOR INPUT REMOVED FROM HERE -->
             <button id="btnRelabelIDs" class="btn" style="width:100%;margin:8px 0 0">Relabel IDs (Left-to-Right)</button>
        </div>
        
        <!-- Relabel Button REMOVED FROM HERE -->

        <div style="overflow-x:auto">
          <table id="matTable">
            <!-- UPDATED COLUMN ORDER: Ft/Bulbs moved left of Colour -->
            <thead><tr><th>Type</th><th style="width:60px">ID</th><th>Ft</th><th>Bulbs</th><th>Clip</th><th>Colour</th><th>Notes</th><th></th></tr></thead>
            <tbody id="lenRows"></tbody>
          </table>
        </div>
      </div>
    </div>
  </main>
</div>
</div>

<div id="wreathPop" class="pop">
  <button data-bow="none">No Bow</button><button data-bow="bottom">Bot Bow</button><button data-bow="top">Top Bow</button>
</div>
<div id="tolPop" class="pop">
  <button data-size="3">3'</button><button data-size="6">6'</button><button data-size="9">9'</button><button data-size="12">12'</button><button data-size="15">15'</button>
</div>

<script>
(()=>{
/* ---------------------------------------------------------------------- */
/* --------------------- GOOGLE DRIVE API INTEGRATION ------------------- */
/* ---------------------------------------------------------------------- */

// GOOGLE DRIVE CREDENTIALS (Implemented based on user input)
const CLIENT_ID = '746571343552-88ogvei1lvtq9ojq3te7fn06d1rlgut4.apps.googleusercontent.com'; // OAuth 2.0 Client ID
const API_KEY = 'AIzaSyCBB6UWp5-FCB7VMpRKsjQh7sR42qd4SN0'; // API Key
const APP_ID = '746571343552'; // Numeric Project ID (used by Picker)

// Scopes required: drive.file for read/write access to files created/opened by app, drive.metadata for folder search
const GDRIVE_SCOPES = 'https://www.googleapis.com/auth/drive.file https://www.googleapis.com/auth/drive.appdata https://www.googleapis.com/auth/drive.metadata'; 
const MAP_MIME_TYPE = 'application/json';
const MAP_FILE_EXTENSION = '.skmap';
const MAP_FOLDER_NAME = 'Skedaddle Map Files'; 

let accessToken = null;
let tokenClient = null;
let gapiReady = false;
let gisReady = false;
let driveFolderId = null; // Global variable to store the ID of the dedicated folder

// Elements for Drive buttons
const gLoadDriveBtn = document.getElementById('gLoadDrive');
const gSaveDriveBtn = document.getElementById('gSaveDrive');
const btnSaveDriveOnly = document.getElementById('btnSaveDriveOnly');
// ADDED ZOOM BUTTONS
const btnZoomIn = document.getElementById('btnZoomIn');
const btnZoomOut = document.getElementById('btnZoomOut');

// Initialize Google APIs
// 1. Load GAPI (Client Library) for Drive API
gapi.load('client:picker', async () => {
    try {
        await gapi.client.setApiKey(API_KEY);
        // Note: We still load 'drive', 'v3' for the file content download (loadFromDrive)
        await gapi.client.load('drive', 'v3'); 
        gapiReady = true;
        
        // 2. Wait/Check for GIS (Google Identity Services)
        const checkGis = setInterval(() => {
            if (window.google && window.google.accounts) {
                clearInterval(checkGis);
                initGis();
            }
        }, 100);
        
    } catch (err) {
        console.error("Error loading GAPI:", err);
        showAlert("Error loading Google APIs: Invalid API Key?");
    }
});

// Initialize Google Identity Services (GIS)
function initGis() {
    try {
        tokenClient = google.accounts.oauth2.initTokenClient({
            client_id: CLIENT_ID,
            scope: GDRIVE_SCOPES,
            callback: (response) => {
                // This callback is executed after the user grants/refreshes the token
                if (response.error !== undefined) {
                    showAlert('Authorization Failed: ' + response.error);
                } else {
                    accessToken = response.access_token;
                    updateDriveUI(true);
                }
            },
        });
        gisReady = true;
        checkApiReadiness();
    } catch (err) {
        console.error("Error initializing GIS:", err);
    }
}

/**
 * Checks if both GAPI and Picker are ready and enables the Auth button.
 */
function checkApiReadiness() {
    if (gapiReady && gisReady) {
        gLoadDriveBtn.disabled = false;
        gSaveDriveBtn.disabled = false;
        
        // Primary action is sign-in/initiate load (for both buttons)
        const authClickHandler = () => tokenClient.requestAccessToken({ prompt: '' });
        gLoadDriveBtn.onclick = authClickHandler;
        gSaveDriveBtn.onclick = authClickHandler;

        gLoadDriveBtn.textContent = '‚òÅÔ∏è Load from Drive';
        gSaveDriveBtn.textContent = '‚òÅÔ∏è Save to Drive';
        btnSaveDriveOnly.onclick = handleSaveDriveClick;
    }
}

/**
 * Initiates the Google Sign-In/Authorization flow or Picker.
 */
function handleAuthClick(event) {
    if (accessToken) {
        // Token exists, proceed directly to Picker
        createPicker('load');
        return; 
    }
    
    // Request a new token or refresh an expired one (triggers the picker after callback)
    tokenClient.requestAccessToken({ prompt: '' });
}

/**
 * Initiates the Save to Drive flow.
 */
function handleSaveDriveClick() {
    if (!accessToken) {
        // If not signed in, prompt for sign-in first
        tokenClient.requestAccessToken({ prompt: '' });
    } else {
        // If signed in, proceed directly to save function
        saveToDrive();
    }
    document.getElementById('saveDropdown').style.display = 'none';
}


/**
 * Updates the UI state after successful authentication.
 */
function updateDriveUI(isAuthenticated) {
    if (isAuthenticated) {
        gLoadDriveBtn.textContent = '‚òÅÔ∏è Load from Drive';
        gSaveDriveBtn.textContent = '‚òÅÔ∏è Save to Drive';
        
        gLoadDriveBtn.onclick = () => createPicker('load');
        gSaveDriveBtn.onclick = saveToDrive;
        
        // Check if the user initiated the flow by clicking the Load button
        // Note: For simplicity, we just rely on the button clicks now.
    } else {
        gLoadDriveBtn.textContent = '‚òÅÔ∏è Load from Drive';
        gSaveDriveBtn.textContent = '‚òÅÔ∏è Save to Drive';
    }
}

/**
 * Opens the Google Picker dialog for file selection.
 */
async function createPicker(pickerType) {
    if (!accessToken || !gapiReady || !gisReady) {
        showAlert('Please sign in to Google Drive first.');
        return;
    }
    
    let view;
    // View for selecting an existing file (.skmap)
    view = new google.picker.View(google.picker.ViewId.DOCS);
    view.setMimeTypes(MAP_MIME_TYPE + ',text/plain,application/octet-stream'); 
    view.setQuery(MAP_FILE_EXTENSION); // Search for our file type
    
    const picker = new google.picker.PickerBuilder()
        .setAppId(APP_ID)
        .setOAuthToken(accessToken)
        .setDeveloperKey(API_KEY)
        .addView(view)
        .setCallback(pickerCallback)
        .build();
        
    picker.setVisible(true);
}

/**
 * Callback function executed after the user interacts with the Google Picker.
 */
function pickerCallback(data) {
    if (data.action === google.picker.Action.PICKED) {
        const file = data.docs[0];
        const fileId = file[google.picker.Document.ID];
        
        loadFromDrive(fileId);
    }
}

/**
 * Downloads the content of a file from Google Drive and loads it into the map maker.
 */
async function loadFromDrive(fileId) {
    showAlert('Loading map from Google Drive...');
    try {
        const response = await gapi.client.drive.files.get({
            fileId: fileId,
            alt: 'media' // Important: fetches the file content, not metadata
        });
        
        const mapDataString = response.body;
        // Convert the string content to a File object for reuse with handleMap
        const file = new File([mapDataString], 'downloaded_map.skmap', { type: MAP_MIME_TYPE });
        
        // Use the existing file loading function
        handleMap(file); 
        document.getElementById('modalAlert').style.display = 'none';
        
    } catch (error) {
        console.error('Error downloading file from Drive:', error);
        showAlert('Error loading map content from Drive. Check console for details.');
    }
}

/**
 * Finds the dedicated map folder, or creates it if it doesn't exist.
 * This version enforces the folder MIME type in the search query.
 */
async function findOrCreateMapFolder() {
    if (!accessToken) return null;
    
    const FOLDER_MIME = 'application/vnd.google-apps.folder';
    
    try {
        // Search for the folder, specifically filtering by its FOLDER MIME type
        const response = await gapi.client.drive.files.list({
            q: `mimeType='${FOLDER_MIME}' and name='${MAP_FOLDER_NAME}' and 'root' in parents and trashed=false`,
            fields: 'files(id, name)',
            spaces: 'drive',
            oauthToken: accessToken
        });

        const files = response.result.files;
        if (files && files.length > 0) {
            // FOUND: Use the first one found (should be the folder)
            driveFolderId = files[0].id;
        } else {
            // NOT FOUND: Folder does not exist, create it
            const createResponse = await gapi.client.drive.files.create({
                resource: {
                    name: MAP_FOLDER_NAME,
                    mimeType: FOLDER_MIME, // CRITICAL: Use the folder MIME type here
                    parents: ['root']
                },
                fields: 'id',
                oauthToken: accessToken
            });
            driveFolderId = createResponse.result.id;
        }
        
        // Return the confirmed ID
        console.log("Drive folder ID:", driveFolderId);
        return driveFolderId;
    } catch (error) {
        console.error('Error finding or creating Drive folder:', error);
        showAlert('Error accessing Google Drive folder permissions.');
        return null; 
    }
}

// Function to safely save the current map payload to Google Drive.
async function saveToDrive() {
    if (!accessToken) {
        showAlert('Please sign in to Google Drive first.');
        return;
    }
    
    // CRITICAL FIX: Await the confirmed folder ID and use a local variable.
    const folderId = await findOrCreateMapFolder();
    if (!folderId) {
        showAlert('Error saving map to Google Drive. Failed to find or create the dedicated folder.');
        return;
    }
    
    const payload = buildPayload();
    const filename = `${getFilenameBase()}${MAP_FILE_EXTENSION}`;
    const fileContent = JSON.stringify(payload);
    const contentType = MAP_MIME_TYPE;
    
    showAlert('Saving map to Google Drive...');

    try {
        // 1. Check if the file already exists in the dedicated folder
        const searchResponse = await gapi.client.drive.files.list({
            q: `name='${filename}' and '${folderId}' in parents and trashed=false`,
            fields: 'files(id)',
            spaces: 'drive',
            oauthToken: accessToken
        });

        const existingFile = searchResponse.result.files?.[0];

        if (existingFile) {
            // 2A. Update existing file (PATCH request)
            const updateResponse = await gapi.client.request({
                path: `/upload/drive/v3/files/${existingFile.id}`,
                method: 'PATCH',
                params: {
                    uploadType: 'media',
                },
                headers: {
                    'Content-Type': contentType,
                },
                body: fileContent,
                oauthToken: accessToken
            });
            showAlert(`Map updated successfully in Drive! (ID: ${existingFile.id})`);
        } else {
            // 2B. Create new file (POST request)
            const fileMetadata = {
                'name': filename,
                'mimeType': contentType,
                // CRITICAL: Use the confirmed local folderId here
                'parents': [folderId] 
            };

            const multipartRequestBody =
                '--BOUNDARY\r\n' +
                'Content-Type: application/json; charset=UTF-8\r\n\r\n' +
                JSON.stringify(fileMetadata) +
                '\r\n--BOUNDARY\r\n' +
                `Content-Type: ${contentType}\r\n\r\n` +
                fileContent +
                '\r\n--BOUNDARY--';

            const createResponse = await gapi.client.request({
                path: '/upload/drive/v3/files',
                method: 'POST',
                params: {
                    uploadType: 'multipart',
                },
                headers: {
                    'Content-Type': 'multipart/related; boundary="BOUNDARY"',
                    'Content-Length': multipartRequestBody.length,
                },
                body: multipartRequestBody,
                oauthToken: accessToken
            });
            showAlert(`Map saved successfully to Drive! (ID: ${createResponse.result.id})`);
        }
    } catch (error) {
        console.error('Error saving file to Drive:', error);
        showAlert('Error saving map to Google Drive. Please check permissions or try signing in again.');
    }
}

/* ---------------------------------------------------------------------- */
/* ------------------------ ORIGINAL MAP MAKER CODE --------------------- */
/* ---------------------------------------------------------------------- */


/* ---------- DATA DEFINITIONS ---------- */
const cats=[{name:"C9's",key:'c9',list:['fascia','peaks','ridges','groundstakes']},{name:'Minis',key:'min',list:['shrub','windows']},{name:'Greenery',key:'grn',list:['wreath32','wreath42','garland','bow']},{name:'Trees',key:'tre',list:['tree:Trunk + Branch (Minis)','tree:Trunk + Canopy (Minis)','tree:C9 Tree','tree:ToL']},{name:'Power',key:'pwr',list:['powersource','cords','threeway']}];
const pretty={ridges:'Ridges',fascia:'Fascia',peaks:'Peaks',groundstakes:'Stakes',shrub:'Shrub',windows:'Windows',garland:'Garland',wreath:'Wreath',bow:'Bow',cords:'Cord',powersource:'Source',threeway:'3-Way',tree:'Tree', label: 'Label'};
const pfx={ridges:'R',fascia:'F',peaks:'P',groundstakes:'GS',shrub:'S',windows:'W',garland:'GA',wreath:'WR',bow:'B',cords:'C',powersource:'PS',tree:'T', label: 'LBL'};
const data={ridges:[],fascia:[],peaks:[],groundstakes:[],shrub:[],windows:[],garland:[],wreath:[],bow:[],cords:[],powersource:[],threeway:[],tree:[], label:[]}; // Add label layer

// Extended color lookup for white variants
function getColorCode(colorName) {
    if (!colorName) return '#ddd';

    const lowerName = colorName.toLowerCase();

    // 1. Check for the hard-coded Multi keyword (CASE-INSENSITIVE)
    if (lowerName.includes('multi') || lowerName === 'm' || lowerName.includes('multiple')) {
        // FIX 1: Enforce the required multi-color scheme
        return 'Red/Blue/Green/Orange/Yellow';
    }
    
    // 2. FIX: If it contains separators (spaces/slashes/commas), return the raw string.
    if (colorName.includes(' ') || colorName.includes('/') || colorName.includes(',')) {
        return colorName;
    }

    // 3. Process as a single, clean color name or hex
    const cleanName = lowerName.replace(/[^a-z0-9#]/g, '');

    switch (cleanName) {
        case 'warmwhite':
        case 'softwhite':
        case 'white':
        case 'ww':
        case 'sw':
        case '#fffdf0':
            return '#fffdf0';
        case 'red':
            return '#ff3b3b';
        case 'blue':
            return '#64b5ff';
        case 'green':
            return '#46c47a';
        case 'yellow':
            return '#ffd86a';
        case 'orange':
            return '#ff8c00';
        case 'purple':
            return '#8a2be2';
        case 'pink':
            return '#ff69b4';
        case 'black':
            return '#000000';
        default:
            // Use custom hex if provided, otherwise default fallback color
            if(colorName.startsWith('#') && colorName.length >= 4) return colorName;
            return '#ddd'; 
    }
}
// UPDATED: Wreath now uses the same green as Garland/Shrub for drawing consistency (FIX 1)
const colorOf=L=>({ridges:'#fffdf0',fascia:'#fffdf0',peaks:'#fffdf0',groundstakes:'#fffdf0',shrub:'#46c47a',windows:'#7fd9ff',garland:'#46c47a',wreath:'#46c47a',bow:'#ff3b3b',cords:'#000000',powersource:'#ff3b3b',threeway:'#ffd86a',tree:'#2aa36e'}[L]||'#ddd');


// --- Global Settings Object ---
let settings = {
    // UPDATED DEFAULTS FOR BETTER VISIBILITY:
    iconScale: 1.5, // Wreaths, Trees, Bows
    junctionScale: 1.0, // Power, 3-Way (New scale)
    lineScale: 1.5, // Start slightly larger
    labelScale: 3.0, // Default max for best visibility
    lineThickness: 3, 
    arrowFreqFactor: 1.0, // NEW: Power direction arrow frequency
};

/* --- New Night Mode State --- */
let isNightMode = false;


/* ---------- UI & UTILS ---------- */
const aside=document.getElementById('side'), overlay=document.getElementById('overlay');
function toggleMenu(){
    const isOpen = aside.classList.contains('open');
    if(isOpen) { aside.classList.remove('open'); overlay.classList.remove('show'); }
    else { aside.classList.add('open'); overlay.classList.add('show'); }
}
document.getElementById('logoBtn').onclick=toggleMenu;
overlay.onclick=toggleMenu;
document.getElementById('modeTag').onclick=toggleMenu;

// New functions for the splash screen toggle
const closeGateBtn = document.getElementById('closeGateBtn');
function openGate(fromCanvas = false) {
    document.body.classList.add('blurred');
    document.getElementById('gate').classList.remove('hide');
    // Only show close button if opened from the Canvas
    closeGateBtn.style.display = fromCanvas ? 'block' : 'none';
}
function unlock(){
    document.body.classList.remove('blurred');
    document.getElementById('gate').classList.add('hide');
    // Push state for back button trap
    history.pushState(null, null, location.href);
}


const lenWrap = document.getElementById('lenWrap');
document.getElementById('lenHead').onclick=()=>{
    lenWrap.classList.toggle('open');
    const sp = lenWrap.querySelector('span');
    sp.textContent = lenWrap.classList.contains('open') ? '‚ñº' : '‚ñ≤';
};

function showAlert(msg) {
    document.getElementById('alertMsg').textContent = msg;
    document.getElementById('modalAlert').style.display = 'flex';
}

// ITEM SCALE CONTROLS
const lineScaleInput = document.getElementById('lineScaleInput');
const lineScaleValue = document.getElementById('lineScaleValue');
const iconScaleInput = document.getElementById('iconScaleInput');
const iconScaleValue = document.getElementById('iconScaleValue');
const junctionScaleInput = document.getElementById('junctionScaleInput'); // NEW
const junctionScaleValue = document.getElementById('junctionScaleValue'); // NEW
const labelScaleInput = document.getElementById('labelScaleInput');
const labelScaleValue = document.getElementById('labelScaleValue');
const arrowFreqInput = document.getElementById('arrowFreqInput'); // NEW
const arrowFreqValue = document.getElementById('arrowFreqValue'); // NEW

function updateLineScaleUI() {
    settings.lineScale = parseFloat(lineScaleInput.value);
    lineScaleValue.textContent = `${settings.lineScale.toFixed(1)}x`;
}
function updateIconScaleUI() {
    settings.iconScale = parseFloat(iconScaleInput.value);
    iconScaleValue.textContent = `${settings.iconScale.toFixed(1)}x`;
}
function updateJunctionScaleUI() { // NEW
    settings.junctionScale = parseFloat(junctionScaleInput.value);
    junctionScaleValue.textContent = `${settings.junctionScale.toFixed(1)}x`;
}
function updateLabelScaleUI() {
    settings.labelScale = parseFloat(labelScaleInput.value);
    labelScaleValue.textContent = `${settings.labelScale.toFixed(1)}x`;
}
function updateArrowFreqUI() { // NEW
    settings.arrowFreqFactor = parseFloat(arrowFreqInput.value);
    arrowFreqValue.textContent = `${settings.arrowFreqFactor.toFixed(1)}x`;
}

lineScaleInput.oninput = (e) => {
    settings.lineScale = parseFloat(e.target.value);
    updateLineScaleUI(); 
    markPowerDirty();
    requestRender(); 
};
iconScaleInput.oninput = (e) => {
    settings.iconScale = parseFloat(e.target.value);
    updateIconScaleUI();
    requestRender(); 
};
junctionScaleInput.oninput = (e) => { // NEW
    settings.junctionScale = parseFloat(e.target.value);
    updateJunctionScaleUI();
    markPowerDirty();
    requestRender(); 
};
labelScaleInput.oninput = (e) => {
    settings.labelScale = parseFloat(e.target.value);
    updateLabelScaleUI();
    requestRender(); 
};
arrowFreqInput.oninput = (e) => { // NEW
    settings.arrowFreqFactor = parseFloat(e.target.value);
    updateArrowFreqUI();
    markPowerDirty();
    requestRender(); 
};

// NIGHT MODE TOGGLE LOGIC
const btnNightMode = document.getElementById('btnNightMode');
btnNightMode.onclick = () => {
    isNightMode = !isNightMode;
    btnNightMode.classList.toggle('toggled', isNightMode);
    requestRender();
};


// TOGGLES (Virtual State)
const chkSnap = { checked: true };
const btnSnap = document.getElementById('btnSnap');
btnSnap.onclick = () => {
    chkSnap.checked = !chkSnap.checked;
    btnSnap.classList.toggle('toggled', chkSnap.checked);
};

const chkSwag = { checked: false };
const btnSwag = document.getElementById('btnSwag');
btnSwag.onclick = () => {
    chkSwag.checked = !chkSwag.checked;
    btnSwag.classList.toggle('toggled', chkSwag.checked);
};

const chkPillar = { checked: false }; // NEW: Pillar Garland Toggle State
const btnPillar = document.getElementById('btnPillar'); // NEW: Pillar Garland Toggle Button
btnPillar.onclick = () => {
    chkPillar.checked = !chkPillar.checked;
    btnPillar.classList.toggle('toggled', chkPillar.checked);
};


// HELPER: Is Layer Minis?
function isMinis(L, item) {
    // 1. If it's a Tree, check if it's NOT a C9 Tree
    if(L === 'tree') return item && item.kind !== 'C9 Tree'; 
    // 2. Standard Minis layers
    const c = cats.find(x => x.key === 'min');
    return c && c.list.includes(L);
}
function isC9(L) {
    const c = cats.find(x => x.key === 'c9');
    return c && c.list.includes(L);
}

// RELABEL LOGIC
function relabelIds() {
    let itemsToRelabel = [];
    Object.keys(data).forEach(L => {
        if (L === 'cords' || L === 'threeway' || L === 'powersource' || L === 'bow') return; // Do not relabel simple line types or junction points

        data[L].forEach(item => {
            if (item.label || L === 'label') { // Include all line items with labels AND simple labels
                let centerX = 0;
                if (item.points && item.points.length > 0) {
                    item.points.forEach(p => centerX += p.x);
                    centerX /= item.points.length;
                } else if (item.pt) {
                    centerX = item.pt.x;
                }

                itemsToRelabel.push({ item, L, centerX });
            }
        });
    });

    // Sort items by calculated center X position (Left to Right)
    itemsToRelabel.sort((a, b) => a.centerX - b.centerX);

    // Apply new sequential labels grouped by Layer
    const nextIndices = {}; 

    itemsToRelabel.forEach(record => {
        const L = record.L;
        const prefix = pfx[L] || 'L';
        
        if (!nextIndices[L]) nextIndices[L] = 1;

        const newIndex = nextIndices[L]++;
        record.item.label = prefix + newIndex;
        // Simple labels use 'text' property, copy the generated label into it for consistency
        if(L === 'label') record.item.text = prefix + newIndex; 
    });

    refreshTable();
    markPowerDirty();
    requestRender();
}

// Helper to determine if Gutter Guard checkbox should be shown
function shouldShowGutterGuard(layer, clipType) {
    // Only show for 'fascia' (not 'peaks') + Tuff or Shingle clips
    const isFascia = layer === 'fascia';
    const isTuffOrShingle = clipType === 'T' || clipType === 'ST';
    return isFascia && isTuffOrShingle;
}


// REFRESH TABLE (UPDATED COLUMN ORDER: Ft/Bulbs moved left of Colour)
function refreshTable(){
    const tbody = document.getElementById('lenRows');
    tbody.innerHTML='';
    let rows=[];
    Object.keys(data).forEach(k=>data[k].forEach(it=>{ if(it.label && k !== 'label') rows.push({item: it, L:k}); }));
    rows.sort((a,b)=>a.item.label.localeCompare(b.item.label, undefined, {numeric:true}));
    const chkAuto = document.getElementById('chkAutoCalc');

    rows.forEach(r=>{
        const tr=document.createElement('tr');
        
        // Clip Logic
        let clipHtml = '';
        let showFRA = false;
        let showGutterGuard = false; 
        
        // Container for Clip and Adapters 
        let clipFraContainerStart = '<div class="clip-fra-container">';
        let clipFraContainerEnd = '</div>';

        // Check if Clip type selection should be shown (Only C9 layers, excluding groundstakes)
        if(isC9(r.L)) {
            if(r.L === 'groundstakes') {
                // HIDE clip/FRA/GG for groundstakes
                clipHtml = '<span style="color:#555">-</span>';
                clipFraContainerStart = '';
                clipFraContainerEnd = '';
            } else {
                if(!r.item.clip) {
                    if(r.L === 'ridges') r.item.clip = 'ST';
                    else if(r.L === 'peaks') r.item.clip = 'ST';
                    else if(r.L === 'fascia') r.item.clip = 'T';
                    else r.item.clip = 'T';
                }
                let opts = [];
                // Allow only specific clips per line type
                if(r.L === 'ridges') opts = [{v:'ST', l:'Shingle'}]; 
                else if (r.L === 'peaks') opts = [{v:'ST', l:'Shingle'}, {v:'Mag', l:'Mag'}];
                else if (r.L === 'fascia') opts = [{v:'T', l:'Tuff'}, {v:'ST', l:'Shingle'}, {v:'Mag', l:'Mag'}];
                
                let optStr = opts.map(o => `<option value="${o.v}" ${r.item.clip===o.v?'selected':''}>${o.l}</option>`).join('');
                
                clipHtml = `<select class="edit clip-select" style="width:80px">${optStr}</select>`;

                // Check if FRA option should be shown (only for Shingle Tab on C9 lines)
                if (r.item.clip === 'ST') {
                    showFRA = true;
                    if (r.item.fra === undefined) r.item.fra = false;
                }

                // Check if Gutter Guard option should be shown (only for Fascia lines on Tuff/Shingle clips)
                if (shouldShowGutterGuard(r.L, r.item.clip)) {
                     showGutterGuard = true;
                     // Initialize gguard property if missing
                     if (r.item.gguard === undefined) r.item.gguard = false; 
                }
            }

        } else { 
            clipHtml = '<span style="color:#555">-</span>'; 
            clipFraContainerStart = '';
            clipFraContainerEnd = '';
        }
        
        const fraHtml = showFRA ? 
            `<label class="fra-checkbox-label">
                <input type="checkbox" class="fra-checkbox" ${r.item.fra ? 'checked' : ''}/> FRA
             </label>` : 
            '';
            
        // NEW Gutter Guard HTML
        const gguardHtml = showGutterGuard ?
            `<label class="gg-checkbox-label">
                <input type="checkbox" class="gg-checkbox" ${r.item.gguard ? 'checked' : ''}/> Gutter Guard
            </label>` :
            '';
            
        const clipCellContent = clipFraContainerStart + clipHtml + fraHtml + gguardHtml + clipFraContainerEnd; // Add gguardHtml

        // CONDITIONAL COLOR INPUT RENDERING 
        let colorInputHtml = '';
        const rawColorValue = r.item.col || '';
        // CRITICAL FIX 1: Ensure multi-color strings are passed through getColorCode correctly for display/storage consistency
        const processedColorCode = getColorCode(rawColorValue);

        if (r.L === 'garland' || r.L === 'wreath') { 
             // Garland/Wreath: Fixed Green, display text block
             const color = getColorCode('green');
             colorInputHtml = `<span style="color:#e8eef6; font-weight:bold; background:${color}; padding: 2px 5px; border-radius: 4px;">Green</span>`; 
        } else if (r.L === 'cords') {
             // Cords: Fixed Black, display text block
             const color = getColorCode('black');
             colorInputHtml = `<span style="color:#e8eef6; font-weight:bold; background:${color}; padding: 2px 5px; border-radius: 4px;">Black</span>`; 
        } else if (r.L === 'shrub') {
             // Shrub: Keep input field, default to green if empty
             const displayValue = rawColorValue || '';
             colorInputHtml = `<input class="edit" placeholder="Col" value="${displayValue}">`;
        } else {
             // Default/C9s/Others: Keep input field
             // FIX 1: If it's a multi-color string, display the string itself (or "Multi")
             const displayValue = processedColorCode.toLowerCase().includes('red/blue') ? 'Multi' : rawColorValue;
             colorInputHtml = `<input class="edit" placeholder="Col" value="${displayValue}">`;
        }


        // NEW COLUMN ORDER: ID, Ft, Bulbs, Clip, Colour, Notes
        tr.innerHTML=`
            <td>${pretty[r.L]}</td>
            <td><input class="edit" style="width:50px" value="${r.item.label}"></td>
            <td><input class="edit" placeholder="ft" style="width:40px" value="${r.item.ft||''}"></td>
            <td><input class="edit" placeholder="#" style="width:40px" value="${r.item.bulbs||''}"></td>
            <td>${clipCellContent}</td>
            <td>${colorInputHtml}</td>
            <td><input class="edit" placeholder="Notes" style="min-width:80px" value="${r.item.notes||''}"></td>
            <td><button class="xbtn">√ó</button></td>`;
        
        
        const select = tr.querySelector('.clip-select');
        const fraCheck = tr.querySelector('.fra-checkbox');
        const gguardCheck = tr.querySelector('.gg-checkbox'); // NEW Gutter Guard Checkbox
        
        // Find inputs by placeholder/style due to changed order and conditional rendering
        const inputId = tr.querySelector('input[style*="width:50px"]');
        const inputCol = tr.querySelector('input[placeholder="Col"]');
        const inputFt = tr.querySelector('input[placeholder="ft"]');
        const inputBulbs = tr.querySelector('input[placeholder="#"]');
        const inputNotes = tr.querySelector('input[placeholder="Notes"]');
        
        // ID 
        if (inputId) inputId.onchange = e => { r.item.label = e.target.value; markPowerDirty(); requestRender(); };

        // COLOR
        if (inputCol) {
            inputCol.oninput=e=>{
                 const val = e.target.value;
                 const lowerVal = val.toLowerCase();
                 // FIX 1: Normalize separators immediately for consistent multi-color parsing
                 const cleanedV = val.replace(/\s/g, '/').replace(/,/g, '/');
                 
                 // CRITICAL FIX: Ensure full list of colors is saved if Multi/M/Multiple is entered, or the cleaned string otherwise
                 if (lowerVal.includes('multi') || lowerVal === 'm' || lowerVal.includes('multiple')) {
                     // Use fixed scheme defined in getColorCode for consistency
                     r.item.col = getColorCode('multi'); 
                     e.target.value = 'Multi'; // Display friendly text in input field
                 } else {
                     // Save the cleaned, multi-color-friendly string
                     r.item.col = cleanedV; 
                     // Update display immediately for better UX
                     if (cleanedV.includes('/')) e.target.value = cleanedV;
                     else e.target.value = val;
                 }
            };
            inputCol.onchange=()=>requestRender(); 
        }

        // FOOTAGE 
        if (inputFt) {
            inputFt.oninput=e=>{ r.item.ft = e.target.value; };
            inputFt.onchange=e=>{
                if(chkAuto.checked && e.target.value) {
                    if(r.L === 'garland' || r.L === 'wreath') return; 
                    const val = parseFloat(e.target.value);
                    if(!isNaN(val)) {
                        let b = Math.round(val / 0.8);
                        if(isMinis(r.L, r.item)) {
                            b = val * 2; 
                            b = Math.ceil(b / 50) * 50; 
                            const balls = b / 50;
                            if(inputNotes) inputNotes.value = `${balls} Ball${balls > 1 ? 's' : ''}`;
                            r.item.notes = inputNotes ? inputNotes.value : r.item.notes;
                            r.item.ft = b / 2; inputFt.value = b / 2;
                        }
                        if(inputBulbs) inputBulbs.value = b; 
                        r.item.bulbs = b;
                    }
                }
            };
        }
        
        // BULBS
        if (inputBulbs) {
            inputBulbs.oninput=e=>{ r.item.bulbs = e.target.value; };
            inputBulbs.onchange=e=>{
                if(chkAuto.checked && e.target.value) {
                    if(r.L === 'garland' || r.L === 'wreath') return; 
                    const val = parseFloat(e.target.value);
                    if(!isNaN(val)) {
                        let f = Math.round(val / 0.8); 
                        if(isMinis(r.L, r.item)) {
                            const balls = Math.ceil(val / 50);
                            const exactBulbs = balls * 50;
                            f = exactBulbs / 2; 
                            if(inputNotes) inputNotes.value = `${balls} Ball${balls > 1 ? 's' : ''}`;
                            r.item.notes = inputNotes ? inputNotes.value : r.item.notes;
                            r.item.bulbs = exactBulbs; inputBulbs.value = exactBulbs;
                        }
                        if(inputFt) inputFt.value = f; 
                        r.item.ft = f;
                    }
                }
            };
        }

        // Notes
        if (inputNotes) inputNotes.oninput=e=>r.item.notes=e.target.value;
        
        if(select) select.onchange = e => { 
            r.item.clip = e.target.value; 
            // Reset FRA and Gutter Guard when clip changes, and re-render table to show/hide checkboxes
            r.item.fra = false;
            r.item.gguard = false; // Reset Gutter Guard state on clip change
            refreshTable(); 
            requestRender(); 
        };
        
        if(fraCheck) fraCheck.onchange = e => {
            r.item.fra = e.target.checked;
            requestRender(); // Update canvas label immediately
        };

        if(gguardCheck) gguardCheck.onchange = e => { // NEW Gutter Guard Handler
            r.item.gguard = e.target.checked;
            requestRender(); // Update canvas label immediately
        };
        
        tr.querySelector('.xbtn').onclick=()=>{ 
            const idx=data[r.L].indexOf(r.item); 
            if(idx>-1){ data[r.L].splice(idx,1); refreshTable(); markPowerDirty(); requestRender(); } 
        };
        tbody.appendChild(tr);
    });
}

/* ---------- CORE & VIEWPORT ---------- */
let cv = document.getElementById('cv');
let ctx = cv.getContext('2d', {alpha: true}); 

const canvasWrap = cv.parentElement;
let DPR=1; 
let scale=1, panX=0, panY=0; 
let imgReady=false; let imgDataUrl=null;
const bg=new Image(); 
const logo=new Image(); logo.crossOrigin='anonymous'; logo.src='https://i.imgur.com/zdJfkpg.png'; logo.onload=()=>requestRender();

let lastWidth = 0, lastHeight = 0;
let actionCounter = 0; 
let isTapCandidate = false; 
let tapDownX = 0, tapDownY = 0;
const TAP_THRESHOLD = 25; 
let activeLabelTarget = null; 
let dragStartPt = null; // New: For dragging the whole object
let isMovingLabel = false; // NEW: State for moving a label, not the object

function initializeAndSizeContext() {
    const r = canvasWrap.getBoundingClientRect();
    const width = r.width; const height = r.height;
    if (width === 0 || height === 0) { requestRender(); return; }
    if (width !== lastWidth || height !== lastHeight) {
        DPR = Math.min(devicePixelRatio || 1, 2);
        cv.width = Math.floor(width * DPR); cv.height = Math.floor(height * DPR);
        lastWidth = width; lastHeight = height;
        if (!ctx) ctx = cv.getContext('2d', {alpha: true});
        if (ctx) ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
        cv.style.width = width + 'px'; cv.style.height = height + 'px';
        requestRender();
    }
    requestRender();
}
function resetView(){
  if(!imgReady) return;
  const r = canvasWrap.getBoundingClientRect();
  const imgW = bg.naturalWidth || bg.width || 1000;
  const imgH = bg.naturalHeight || bg.height || 1000;
  const targetWidth = r.width * 0.9; 
  scale = targetWidth / imgW;
  if(!isFinite(scale) || scale <= 0) scale = 0.1;
  panX = (r.width - imgW * scale) / 2;
  panY = (r.height - imgH * scale) / 2;
  requestRender();
}
document.getElementById('btnFit').onclick=resetView;

// ADDED zoom handlers
btnZoomIn.onclick = () => {
    const mx = lastWidth / 2;
    const my = lastHeight / 2;
    const w = toWorld(mx, my);
    const f = 1.1;
    const nz = Math.max(0.1, Math.min(10, scale * f));
    panX = mx - w.x * nz;
    panY = my - w.y * nz;
    scale = nz;
    requestRender();
};

btnZoomOut.onclick = () => {
    const mx = lastWidth / 2;
    const my = lastHeight / 2;
    const w = toWorld(mx, my);
    const f = 0.9;
    const nz = Math.max(0.1, Math.min(10, scale * f));
    panX = mx - w.x * nz;
    panY = my - w.y * nz;
    scale = nz;
    requestRender();
};

const accWrap=document.getElementById('accWrap'); const toolBtn={};
function buildTools(){
  accWrap.innerHTML='';
  cats.forEach(cat=>{
    const acc=document.createElement('div');acc.className='acc';
    const head=document.createElement('div');head.className='accHead';
    head.innerHTML=`<b>${cat.name}</b><span>‚ñ∂</span>`;
    head.onclick=()=>{
        document.querySelectorAll('.acc.open').forEach(el=>{if(el!==acc)el.classList.remove('open')});
        acc.classList.toggle('open');
    };
    const body=document.createElement('div');body.className='accBody';
    const grid=document.createElement('div');grid.className='grid4';
    cat.list.forEach(k=>{
      const btn=document.createElement('button');btn.className='tool';
      if(k.startsWith('tree:')){
          const t=k.slice(5); btn.textContent=t.split('(')[0].trim(); 
          btn.onclick=()=>selectTool('tree',t); toolBtn[k]=btn;
      } else if(k.startsWith('wreath')){
          btn.textContent=k==='wreath32'?'Wr 32"':'Wr 42"';
          btn.onclick=()=>selectTool('wreath', k==='wreath32'?'32"':'42"'); toolBtn[k]=btn;
      } else {
          btn.textContent=pretty[k]||k;
          btn.onclick=()=>selectTool(k); toolBtn[k]=btn;
      }
      grid.appendChild(btn);
    });
    body.appendChild(grid);acc.append(head,body);accWrap.appendChild(acc);
  });
}
buildTools();

let mode='draw',currLayer='ridges',currTreeKind='Trunk + Branch (Minis)',currWreathSize='32"', currLabelTarget='point'; // Added currLabelTarget for clarity
function selectTool(L, variant=null){
    currLayer=L;
    if(L==='tree') currTreeKind=variant;
    else if(L==='wreath') currWreathSize=variant;
    for(const k in toolBtn) toolBtn[k].classList.remove('active');
    if(L==='tree') toolBtn['tree:'+currTreeKind]?.classList.add('active');
    else if(L==='wreath') toolBtn[currWreathSize==='32"'?'wreath32':'wreath42']?.classList.add('active');
    else toolBtn[L]?.classList.add('active');
    if(matchMedia('(max-width:900px)').matches) toggleMenu();
    
    // Hide move popup when changing tools
    document.getElementById('movePop').style.display = 'none';

    mode='draw'; updateModeTag(); startNewSketch();
    
    // Toggle visibility and state for Garland-specific buttons
    if(currLayer === 'garland') {
        document.getElementById('btnSwag').style.display = 'inline-flex';
        document.getElementById('btnPillar').style.display = 'inline-flex'; // NEW: Show Pillar button
    } else {
        document.getElementById('btnSwag').style.display = 'none';
        document.getElementById('btnPillar').style.display = 'none'; // NEW: Hide Pillar button
        // Reset state when leaving Garland
        chkPillar.checked = false;
        btnPillar.classList.remove('toggled');
    }
    redoStack = []; document.getElementById('btnRedo').disabled = true;
}
document.getElementById('btnDraw').onclick=()=>{mode='draw';updateModeTag()};
document.getElementById('btnSelect').onclick=()=>{mode='select';updateModeTag()};
// New Label Mode button handler
document.getElementById('btnLabel').onclick=()=>{
    mode='label';
    // Default to point label on entering label mode
    currLabelTarget='point'; 
    updateModeTag();
};

function updateModeTag(){
    const t = document.getElementById('modeTag');
    if (mode === 'draw') {
         t.textContent = pretty[currLayer] || 'Draw';
         t.style.borderColor = '#64b5ff';
         t.style.color = '#64b5ff';
    } else if (mode === 'select') {
         t.textContent = 'Select';
         t.style.borderColor = '#ffbd2e';
         t.style.color = '#ffbd2e';
    } else if (mode === 'label') {
         t.textContent = 'Label';
         t.style.borderColor = '#46c47a';
         t.style.color = '#46c47a';
    } else if (mode === 'move') {
         t.textContent = 'Move';
         t.style.borderColor = '#ff3b3b';
         t.style.color = '#ff3b3b';
    } else if (mode === 'move-label') { // NEW: Label Move Mode
         t.textContent = 'Move Label';
         t.style.borderColor = '#4a90e2';
         t.style.color = '#4a90e2';
    }
    
    // --- Emergency Scale Visibility Check (Added Fix) ---
    // If scales are nonsensically low (e.g., loaded from a corrupted file), force them to be visible.
    // This addresses the user's issue by guaranteeing visibility when switching modes.
    const MIN_SCALE = 0.5; // Same as slider minimum
    if (settings.iconScale < MIN_SCALE) settings.iconScale = 1.5;
    if (settings.junctionScale < MIN_SCALE) settings.junctionScale = 1.0; // NEW
    if (settings.lineScale < MIN_SCALE) settings.lineScale = 1.5;
    if (settings.labelScale < MIN_SCALE) settings.labelScale = 3.0; // Max size for prominence
    updateLineScaleUI(); 
    updateIconScaleUI();
    updateJunctionScaleUI(); // NEW
    updateLabelScaleUI();
    // --- End Emergency Fix ---

    selectedItem = null; draggingPoint = null; isMovingLabel = false; requestRender();
}

/* ---------- POWER LOGIC ---------- */
let powerGraph = null, powerDirty = true;
function markPowerDirty(){ powerDirty = true; }
function analyzePower(){
  // COMING SOON: Max Circuit Capacity Tracking/Warning
  if(!powerDirty && powerGraph) return powerGraph;
  const nodes = []; const edges = []; const TOL_SQR = 0.5 * 0.5;
  function getId(p){
    for(let i=0; i<nodes.length; i++){
      const dx = nodes[i].x - p.x; const dy = nodes[i].y - p.y;
      if(dx*dx + dy*dy < TOL_SQR) return i;
    }
    return nodes.push({x:p.x, y:p.y, dist:Infinity, adj:[]}) - 1;
  }
  
  // Track connections for Garland/Stakes for the single-arrow-per-object logic
  const singlePathLayers = ['garland', 'groundstakes']; 
  const singlePathEdges = new Map(); // Map line object to its total path length and segments
  
  ['ridges','fascia','peaks','groundstakes','garland','cords','shrub','windows'].forEach(L => {
    data[L].forEach(it => {
       if(it.points.length < 2) return;
       let currentLength = 0;
       let pathSegments = [];

       for(let i=0; i<it.points.length-1; i++){
          const u = getId(it.points[i]); const v = getId(it.points[i+1]);
          const edge = {u, v, type:L, cps:(it.cps?.[i] || null), index: i, line: it};
          edges.push(edge);
          nodes[u].adj.push(v); nodes[v].adj.push(u);
          
          if (singlePathLayers.includes(L)) {
              const p1 = it.points[i];
              const p2 = it.points[i+1];
              const cp = it.cps ? it.cps[i] : null;
              const len = segmentLength(p1, p2, cp); // Use world coordinates
              currentLength += len;
              pathSegments.push({ edge, length: len, startDist: currentLength - len });
          }
       }
       
       if (singlePathLayers.includes(L) && pathSegments.length > 0) {
           singlePathEdges.set(it, { totalLength: currentLength, segments: pathSegments });
       }
    });
  });
  
  const queue = [];
  data.powersource.forEach(ps => { const id = getId(ps.pt); if(nodes[id]){ nodes[id].dist = 0; queue.push(id); } });
  let head = 0;
  while(head < queue.length){
    const u = queue[head++]; const d = nodes[u].dist + 1;
    nodes[u].adj.forEach(v => { if(nodes[v].dist === Infinity){ nodes[v].dist = d; queue.push(v); } });
  }
  const deadTips = [];
  nodes.forEach((n, i)=>{ 
    if(n.dist !== Infinity && n.dist > 0 && n.adj.length === 1){ 
      const worldPos = {x:n.x, y:n.y};
      let isDecoration = false;
      
      // Check if this dead end point is occupied by a decoration icon
      ['wreath', 'tree', 'bow'].forEach(L => {
        data[L].forEach(item => {
          if (item.pt && Math.hypot(item.pt.x - worldPos.x, item.pt.y - worldPos.y) < TOL_SQR) {
            isDecoration = true;
          }
        });
      });
      
      // Also check if the line attached to this node is garland or shrub (greenery)
      let isGarlandOrShrub = false;
      edges.forEach(e => {
        if (['garland', 'shrub'].includes(e.type) && (e.u === i || e.v === i)) {
             isGarlandOrShrub = true;
        }
      });
      
      // R2: If it's a dead end, and not a decoration, and NOT garland/shrub, draw the cap
      if (!isDecoration && !isGarlandOrShrub) {
        deadTips.push(i); 
      }
    } 
  });
  
  // NEW: Process single-path layers to find where the single arrow should go
  const singleArrowEdges = [];
  singlePathEdges.forEach((pathInfo, line) => {
      const totalLength = pathInfo.totalLength;
      if (totalLength < 0.1) return;
      const targetDist = totalLength * 0.5; // Place arrow at midpoint
      
      let bestSegment = null;
      for (const seg of pathInfo.segments) {
          if (targetDist >= seg.startDist && targetDist <= (seg.startDist + seg.length)) {
              bestSegment = seg;
              break;
          }
      }

      if (bestSegment) {
          const edge = bestSegment.edge;
          const distInSegment = targetDist - bestSegment.startDist;
          
          // Determine flow direction (power is always at start, so flow is start to end)
          const uNode = nodes[edge.u]; 
          const vNode = nodes[edge.v];
          let isReversed = false;
          if (uNode.dist > vNode.dist) {
              // The line is connected backwards to the power source, reverse direction
              isReversed = true; 
          }
          
          singleArrowEdges.push({ edge: edge, distInSegment: distInSegment, isReversed: isReversed });
      }
  });

  powerGraph = {nodes, edges, deadTips, singleArrowEdges}; // Add new info
  powerDirty = false;
  return powerGraph;
}
function projOnSeg(p,a,b){
    const ABx=b.x-a.x, ABy=b.y-a.y; const d=ABx*ABx+ABy*ABy||1; const t=((p.x-a.x)*ABx+(p.y-a.y)*ABy)/d;
    return{t,q:{x:a.x+ABx*t,y:a.y+ABy*t}};
}
function nextIndex(prefix){const re=new RegExp('^'+prefix+'(\\d+)$','i');const used=new Set();for(const L in data){for(const it of data[L]){const m=(it.label||'').match(re);if(m)used.add(+m[1])}}let i=1;while(used.has(i))i++;return i}

/* ---------- CORE UTILITIES (Icon/Snap/Placement) ---------- */

// Helper to find nearest line point/segment for snapping
function getSnapLineOnly(wx, wy, thresholdW){
    let best = null; let minD = thresholdW;
    const p = {x:wx, y:wy};
    ['ridges','fascia','peaks','groundstakes','garland','shrub','windows'].forEach(L=>{
        data[L].forEach(line=>{
            for(let i=0; i<line.points.length-1; i++){
                const a=line.points[i]; const b=line.points[i+1];
                const proj=projOnSeg(p,a,b);
                const d=Math.hypot(p.x-proj.q.x, p.y-proj.q.y);
                if(d<minD){
                    minD=d;
                    best={x:proj.q.x, y:proj.q.y, type:'mid', host:line, seg:i};
                }
            }
        });
    });
    return best;
}

// Main snap function for both ends/junctions and mid-segments
function getSnap(sx, sy, thresholdS){
    const w=toWorld(sx, sy);
    const thresholdW=thresholdS/scale;
    let best=null; let minD=thresholdW;
    const p = w;

    // 1. Snap to Line End/Start (Higher priority)
    ['ridges','fascia','peaks','groundstakes','garland','cords','shrub','windows'].forEach(L=>{
        data[L].forEach(line=>{
            if(line.points.length>0){
                [line.points[0], line.points[line.points.length-1]].forEach(pt=>{
                    const d=Math.hypot(p.x-pt.x, p.y-pt.y);
                    if(d<minD){ minD=d; best={x:pt.x, y:pt.y, type:'end', host:line}; }
                });
            }
        });
    });

    // 2. Snap to Icon/Junction (Same priority as ends)
    ['powersource','threeway','wreath','bow','tree'].forEach(L=>{
        data[L].forEach(it=>{
            if(it.pt){
                const d=Math.hypot(p.x-it.pt.x, p.y-it.pt.y);
                if(d<minD){ minD=d; best={x:it.pt.x, y:it.pt.y, type:'junction', host:it}; }
            }
        });
    });

    // 3. Snap to Line Segment Midpoint (Lower priority)
    if(!best){
        minD = thresholdW;
        ['ridges','fascia','peaks','groundstakes','garland','shrub','windows'].forEach(L=>{
            data[L].forEach(line=>{
                for(let i=0; i<line.points.length-1; i++){
                    const a=line.points[i]; const b=line.points[i+1];
                    const proj=projOnSeg(p,a,b);
                    if(proj.t>=0 && proj.t<=1 && Math.hypot(p.x-proj.q.x, p.y-proj.q.y)<minD){
                        minD=Math.hypot(p.x-proj.q.x, p.y-proj.q.y);
                        best={x:proj.q.x, y:proj.q.y, type:'proj', host:line, seg:i};
                    }
                }
            });
        });
    }

    return best;
}

// Checks how many lines are connected to a junction (for 3-Way limit)
function countConnections(junction) {
    let count = 0;
    const junctionWorld = junction.pt;
    const TOL_SQR = 0.5 * 0.5;
    
    // Check line connections
    ['ridges', 'fascia', 'peaks', 'groundstakes', 'garland', 'cords', 'shrub', 'windows'].forEach(L => {
        data[L].forEach(line => {
            if (line.points.length > 0) {
                // Check start point
                if (Math.hypot(line.points[0].x - junctionWorld.x, line.points[0].y - junctionWorld.y) < TOL_SQR) count++;
                // Check end point (if not the same as start)
                const end = line.points[line.points.length - 1];
                if (line.points.length > 1 && Math.hypot(end.x - junctionWorld.x, end.y - junctionWorld.y) < TOL_SQR) count++;
            }
        });
    });

    return count;
}

// Finds if a 3-Way junction exists at a given world point
function find3WayAt(pt) {
    const TOL_SQR = 0.5 * 0.5;
    for(const tw of data.threeway){
        if(Math.hypot(tw.pt.x - pt.x, tw.pt.y - pt.y) < TOL_SQR) return tw;
    }
    return null;
}

// Handles the placement of Icons/single-point items (Wreath, Tree, Power, 3-Way, Bow)
function placeItem(L, w, sx, sy){
    let item;
    const {label, index} = getNewItemData(L);
    
    if(L==='tree') {
         placeTree(L, w, sx, sy, label, index); 
         return; 
    } else if(L==='wreath') {
         placeWreath(L, w, sx, sy, label, index);
         return;
    }
    
    // For simple icons (Power, 3-Way, Bow)
    item = {pt:w, label:label, index:index, kind: L};
    
    data[L].push(item);
    markPowerDirty(); requestRender(); refreshTable();
}

// Handles placing a Tree, including the ToL size popup
function placeTree(L, w, sx, sy, label, index) {
    if (currTreeKind === 'ToL') {
        openPop(document.getElementById('tolPop'), sx, sy, (size) => {
            const item = {pt:w, label:label, index:index, kind: currTreeKind, size: parseInt(size)};
            data[L].push(item);
            markPowerDirty(); requestRender(); refreshTable();
        });
    } else {
        const item = {pt:w, label:label, index:index, kind: currTreeKind};
        data[L].push(item);
        markPowerDirty(); requestRender(); refreshTable();
    }
}

// Handles placing a Wreath, including the bow position popup
function placeWreath(L, w, sx, sy, label, index) {
    openPop(document.getElementById('wreathPop'), sx, sy, (bow) => {
        const item = {pt:w, label:label + (currWreathSize === '42"' ? ' (42)' : ''), index:index, size: currWreathSize, bow: bow};
        data[L].push(item);
        markPowerDirty(); requestRender(); refreshTable();
    });
}

// Function to finalize the current drawn line (FIXED)
function completeSketch() {
    if (!sketch || sketch.points.length < 2) return;
    
    // Add the completed line to the permanent data structure
    data[sketch.layer].push(sketch); 
    
    // Reset state and start a new sketch for the same layer
    const layer = sketch.layer;
    sketch = null;
    document.getElementById('btnComplete').disabled = true;
    startNewSketch(); // Start a fresh sketch immediately
    
    // Update dependencies
    markPowerDirty(); 
    refreshTable();
    requestRender(); 
}

/* ---------- INPUT ---------- */
let pointers=new Map(),gesture=false,gMid=null,gScale=1,gPanX=0,gPanY=0,gDist=0;
function mp(a,b){return{x:(a.x+b.x)/2,y:(a.y+b.y)/2}}
function ds(a,b){return Math.hypot(a.x-b.x,a.y-b.y)}
const toWorld=(sx,sy)=>({x:(sx-panX)/scale,y:(sy-panY)/scale});
const toScr=p=>({x:p.x*scale+panX,y:p.y*scale+panY});

let selectedItem = null, draggingPoint = null;
let currentSnapLine = null; 
let draggedLabelTarget = null; // NEW: Label currently being dragged

let dragStartX=0, dragStartY=0, dragPanStartX=0, dragPanStartY=0;

cv.addEventListener('pointerdown',e=>{
    cv.setPointerCapture(e.pointerId);
    const r=canvasWrap.getBoundingClientRect();
    const ex = e.clientX-r.left, ey = e.clientY-r.top;
    pointers.set(e.pointerId,{x:ex,y:ey,id:e.pointerId});
    
    document.getElementById('lblEditor').style.display = 'none';
    document.getElementById('movePop').style.display = 'none'; // Hide popups on new interaction

    if(pointers.size === 1) {
        isTapCandidate = true;
        tapDownX = ex; tapDownY = ey;
        dragStartX = ex; dragStartY = ey;
        dragPanStartX = panX; dragPanStartY = panY;
        
        if (mode === 'move' && selectedItem) {
             // Initiate full object drag
             dragStartPt = { x: selectedItem.obj.pt ? selectedItem.obj.pt.x : (selectedItem.obj.points ? getItemCenter(selectedItem.obj).x : 0),
                             y: selectedItem.obj.pt ? selectedItem.obj.pt.y : (selectedItem.obj.points ? getItemCenter(selectedItem.obj).y : 0) };
             return;
        } else if (mode === 'move-label' && selectedItem) { // NEW: Initiate label drag
             const target = checkLabelClick(ex, ey, selectedItem.obj, selectedItem.type);
             if (target) {
                 draggedLabelTarget = target;
                 return;
             }
        }
    }
    
    if(pointers.size >= 2){
        isTapCandidate = false; gesture=true;
        const v=[...pointers.values()];
        gDist=ds(v[0],v[1]); gMid=mp(v[0],v[1]);
        gScale=scale; gPanX=panX; gPanY=panY;
        return;
    }
    
    if(mode === 'select' || mode === 'move') {
        const w = toWorld(ex, ey);
        // Try to heal only if clicking near a junction, don't interfere with dragging/selecting
        let clickedObj = null;
        data.threeway.forEach(t => { if(Math.hypot(toScr(t.pt).x - ex, toScr(t.pt).y - ey) < 30) clickedObj = t; });
        if(!clickedObj) {
            data.powersource.forEach(t => { if(Math.hypot(toScr(t.pt).x - ex, toScr(t.pt).y - ey) < 30) clickedObj = t; });
        }
        if(clickedObj) attemptHeal(clickedObj.pt);
        
        // Check if clicking anything to decide if pan or select drag starts
        let hit = false;
        const search = (list)=>{
             list.forEach(obj=>{
                 if(obj.points){
                     // Check Vertices (for dragging)
                     for(let i=0; i<obj.points.length; i++) if(Math.hypot(ex-toScr(obj.points[i]).x, ey-toScr(obj.points[i]).y)<30) hit=true;
                     // Check Segments (for selecting/deleting)
                     if(!hit) {
                         for(let i=0; i<obj.points.length-1; i++){
                             const p=projOnSeg(w, obj.points[i], obj.points[i+1]);
                             if(p.t>=0 && p.t<=1 && Math.hypot(ex-toScr(p.q).x, ey-toScr(p.q).y)<30) hit=true;
                         }
                     }
                 } else if(obj.pt){
                     // Check Icons/Single Points
                     if(Math.hypot(ex-toScr(obj.pt).x, ey-toScr(obj.pt).y)<30) hit=true;
                 }
             });
        };
        Object.keys(data).forEach(k=>search(data[k]));
        
        if(!hit) {
            // Drag on empty space -> Pan (handled in pointermove later)
        } else {
             // Drag on item/point -> Select drag
             // This function handles setting 'draggingPoint' and 'selectedItem'
             handleSelectDown(ex, ey); 
        }
    }
    
    if(mode === 'label') {
        // Only allow tap to bring up label editor, prevent panning/dragging in this mode
        // Tap is handled in pointerup
    }
});

function attemptHeal(pt) {
    const lineLayers = ['ridges','fascia','peaks','groundstakes','garland','cords','shrub','windows'];
    let candidates = [];
    lineLayers.forEach(L => {
        data[L].forEach(line => {
            if(line.points) {
                const pStart = line.points[0];
                const pEnd = line.points[line.points.length-1];
                if(Math.hypot(pStart.x-pt.x, pStart.y-pt.y) < 0.1) candidates.push({line, L, end:'start'});
                else if(Math.hypot(pEnd.x-pt.x, pEnd.y-pt.y) < 0.1) candidates.push({line, L, end:'end'});
            }
        });
    });
    if(candidates.length === 2 && candidates[0].L === candidates[1].L) {
        const A = candidates[0].line;
        const B = candidates[1].line;
        if (!A.isSplit || !B.isSplit) return; 
        if(candidates[0].end === 'end' && candidates[1].end === 'start') mergeLines(candidates[0].L, A, B);
        else if (candidates[1].end === 'end' && candidates[0].end === 'start') mergeLines(candidates[0].L, B, A);
    }
}

function mergeLines(L, keepLine, mergeLine) {
    const newPoints = keepLine.points.concat(mergeLine.points.slice(1));
    const newCps = (keepLine.cps || []).concat(mergeLine.cps || []);
    keepLine.points = newPoints;
    keepLine.cps = newCps;
    const idx = data[L].indexOf(mergeLine);
    if(idx > -1) data[L].splice(idx, 1);
    refreshTable(); markPowerDirty();
}

cv.addEventListener('pointermove',e=>{
    const r=canvasWrap.getBoundingClientRect();
    const x=e.clientX-r.left, y=e.clientY-r.top;
    if(pointers.has(e.pointerId)) pointers.set(e.pointerId,{x,y,id:e.pointerId});
    cv._mx=x; cv._my=y;

    if(gesture && pointers.size>=2){
        const v=[...pointers.values()];
        const currDist=ds(v[0],v[1]); const currMid=mp(v[0],v[1]);
        if(gDist>0){
            const nz = Math.max(0.1, Math.min(10, gScale * (currDist/gDist)));
            const worldMid = {x:(gMid.x-gPanX)/gScale, y:(gMid.y-gPanY)/gScale};
            scale = nz;
            panX = currMid.x - worldMid.x*scale;
            panY = currMid.y - worldMid.y*scale;
            requestRender();
        }
        return;
    }
    
    // Pan logic (Draw Mode OR Select/Label Mode when dragging empty space)
    if(pointers.size === 1 && (!draggingPoint) && mode !== 'label' && mode !== 'move' && mode !== 'move-label') { // Label/Move mode explicitly blocks panning on tap/drag
         const dx = x - dragStartX; const dy = y - dragStartY;
         if(Math.hypot(dx, dy) > TAP_THRESHOLD){
            isTapCandidate = false; 
            panX = dragPanStartX + dx;
            panY = dragPanStartY + dy;
            requestRender();
         }
    }
    
    if(mode === 'select' && draggingPoint){
        const w = toWorld(x, y);
        currentSnapLine = null; 
        
        if (draggingPoint.index === -1 && (draggingPoint.type === 'powersource' || draggingPoint.type === 'threeway' || draggingPoint.type === 'wreath' || draggingPoint.type === 'bow' || draggingPoint.type === 'tree')) {
             // Move Icon/Junction point
             const snap = getSnapLineOnly(w.x, w.y, 25 / scale); 
             if (snap) {
                 draggingPoint.obj.pt = {x: snap.x, y: snap.y};
                 if(snap.type === 'mid') currentSnapLine = snap;
             } else {
                 draggingPoint.obj.pt = w;
             }
        } else {
            // Move Line Point: Snap to lines/ends
            let snap = getSnap(x, y, 25); // Use screen pixels for snap feel
            const ptVal = snap ? {x:snap.x, y:snap.y} : w;
            
            if (draggingPoint.index === -1 && draggingPoint.obj.pt) {
                draggingPoint.obj.pt = ptVal;
            } else if (draggingPoint.obj.points) {
                draggingPoint.obj.points[draggingPoint.index] = ptVal;
            }
        }
        markPowerDirty(); requestRender();
        return;
    }
    
    // NEW: Handle full object drag in 'move' mode
    if (mode === 'move' && selectedItem && dragStartPt) {
        const w = toWorld(x, y);
        const wStart = toWorld(dragStartX, dragStartY);
        const dx = w.x - wStart.x;
        const dy = w.y - wStart.y;
        
        const obj = selectedItem.obj;

        if (obj.pt) {
            // For Icons (pt), just update the point
            obj.pt.x = dragStartPt.x + dx;
            obj.pt.y = dragStartPt.y + dy;
        } else if (obj.points) {
            // For Lines (points), move all points by the delta
            obj.points.forEach(p => {
                p.x += dx;
                p.y += dy;
            });
            // Update drag start for continuous movement relative to the original click
            dragStartX = x;
            dragStartY = y;
            dragStartPt.x = obj.points[0].x; 
            dragStartPt.y = obj.points[0].y; 
            
            // If the object has control points (like garland swag), move those too
            if (obj.cps) {
                obj.cps.forEach(cp => {
                    if (cp) {
                        cp.x += dx;
                        cp.y += dy;
                    }
                });
            }
        }
        markPowerDirty();
        requestRender();
        return;
    }
    
    // NEW: Handle label drag in 'move-label' mode
    if (mode === 'move-label' && draggedLabelTarget) {
        const w = toWorld(x, y);
        const obj = draggedLabelTarget.item;
        const index = draggedLabelTarget.index;
        const type = draggedLabelTarget.type;

        if (type === 'point') {
             if(!obj.ptLabelPos) obj.ptLabelPos = {};
             obj.ptLabelPos[index] = {x: w.x, y: w.y};
        } else if (type === 'seg') {
             if(!obj.segLabelPos) obj.segLabelPos = {};
             obj.segLabelPos[index] = {x: w.x, y: w.y};
        } else if (type === 'simple') {
             obj.pt.x = w.x;
             obj.pt.y = w.y;
        }
        requestRender();
        return;
    }
    
    requestRender();
});

cv.addEventListener('pointerup',e=>{
    const wasGesture = gesture;
    
    // Vertex/Icon drag release fix (1st priority)
    if (pointers.size === 1 && !wasGesture) { // Check size=1 to ensure the *last* pointerup is handled correctly
        if (draggingPoint) {
            // Only release draggingPoint if this was the last pointer (size 1 after delete)
            draggingPoint = null;
            markPowerDirty();
            requestRender();
        }
    }
    
    // Full object drag release fix (2nd priority)
    if (mode === 'move' && dragStartPt) {
        dragStartPt = null;
    }
    
    // Label drag release fix (3rd priority)
    if (mode === 'move-label' && draggedLabelTarget) {
        draggedLabelTarget = null;
    }

    pointers.delete(e.pointerId);
    
    // If a multi-touch sequence just ended (Fix 9)
    if (wasGesture) {
         const r=canvasWrap.getBoundingClientRect();
         // Reset single-touch drag start points to prevent jump
         dragStartX = cv._mx;
         dragStartY = cv._my;
         dragPanStartX = panX;
         dragPanStartY = panY;
         isTapCandidate = false; // Cannot be a tap
    }

    if(pointers.size<2) gesture=false;
    
    // Handle tap events after multi-touch processing is complete
    if(!wasGesture && pointers.size === 0 && e.button===0) {
        const r=canvasWrap.getBoundingClientRect();
        const ex = e.clientX-r.left, ey = e.clientY-r.top;
        const dist = Math.hypot(ex - dragStartX, ey - dragStartY);
        
        if(dist < TAP_THRESHOLD) {
             if(mode === 'draw') {
                 handleTap(ex, ey);
             } else if (mode === 'label') {
                 // Activation of label editor moved here
                 checkCordLabelClick(ex, ey);
             } else if (mode === 'select' || mode === 'move' || mode === 'move-label') {
                 // Re-check selection in case a click/tap selected an item but didn't drag
                 handleSelectDown(ex, ey);
             }
        }
    }
});

// NEW: Keyboard listener for Delete/Backspace
document.addEventListener('keydown', (e) => {
    if (selectedItem && (e.key === 'Delete' || e.key === 'Backspace')) {
        e.preventDefault(); // Prevent browser back action on backspace
        deleteItem(selectedItem);
        selectedItem = null;
        // Hide move popup after deletion
        document.getElementById('movePop').style.display = 'none';
        requestRender();
        updateModeTag(); // Clears any latent 'move' mode state or updates 'select' visuals
    }
});

// NEW: Move Tool button handler
document.getElementById('moveToolBtn').onclick = () => {
    if (selectedItem) {
        mode = 'move';
        document.getElementById('movePop').style.display = 'none';
        updateModeTag();
        // The dragging will start on the next pointerdown, handled in cv.addEventListener('pointerdown')
    }
};

// NEW: Move Label Tool button handler
document.getElementById('moveLabelToolBtn').onclick = () => {
    if (selectedItem && selectedItem.obj.points) { // Only available for line objects
        mode = 'move-label';
        document.getElementById('movePop').style.display = 'none';
        updateModeTag();
    }
};

// NEW: Delete Tool button handler
document.getElementById('deleteToolBtn').onclick = () => {
    if (selectedItem) {
        deleteItem(selectedItem);
        selectedItem = null;
        document.getElementById('movePop').style.display = 'none';
        updateModeTag();
    }
};


function checkCordLabelClick(sx, sy) {
    const w = toWorld(sx, sy);
    
    // Check for Simple Labels first (highest priority for a clean tap)
    for (const item of data.label) {
        const s = toScr(item.pt);
        // Use a fixed size tap area around the point for simple labels
        if(Math.hypot(s.x - sx, s.y - sy) < 40) {
            showLabelEditor({ item: item, type: 'simple', index: -1, x: sx, y: sy });
            return;
        }
    }
    
    // Then check for Segment/Point Labels
    let best = checkLabelClick(sx, sy);
    if (best) {
        showLabelEditor(best);
        return;
    }
    
    // If nothing hit, create a new simple label
    const {label, index} = getNewItemData('label');
    if (!data.label) data.label = []; 
    data.label.push({pt: w, label: label, index: index, text: ''});
    // Immediately try to show label editor on the newly created item
    showLabelEditor({ item: data.label[data.label.length - 1], type: 'simple', index: -1, x: sx, y: sy });
}

function checkLabelClick(sx, sy, specificItem=null, specificType=null) {
    const w = toWorld(sx, sy);
    let best = null;
    
    const search = (item, L) => {
        if (item.points) {
            // Point Labels
            if(item.ptLabels) {
                Object.keys(item.ptLabels).forEach(idx => {
                    const i = parseInt(idx);
                    const labelPos = item.ptLabelPos && item.ptLabelPos[i] ? item.ptLabelPos[i] : item.points[i];
                    const sc = toScr(labelPos);
                    if(Math.hypot(sc.x - sx, sc.y - sy) < 30) {
                        if (!best || Math.hypot(sc.x - sx, sc.y - sy) < best.d) {
                            best = { item: item, type: 'point', index: i, x: sc.x, y: sc.y, L, d: Math.hypot(sc.x - sx, sc.y - sy) };
                        }
                    }
                });
            }
            // Segment Labels
            if(item.segLabels) {
                Object.keys(item.segLabels).forEach(idx => {
                    const i = parseInt(idx);
                    // Use stored position or calculate midpoint world position
                    let labelPos;
                    if (item.segLabelPos && item.segLabelPos[i]) {
                         labelPos = item.segLabelPos[i];
                    } else {
                         const mid = getPolylineMidpoint([item.points[i], item.points[i+1]]);
                         labelPos = mid;
                    }

                    const sc = toScr(labelPos);
                    if(Math.hypot(sc.x - sx, sc.y - sy) < 30) {
                        if (!best || Math.hypot(sc.x - sx, sc.y - sy) < best.d) {
                           best = { item: item, type: 'seg', index: i, x: sc.x, y: sc.y, L, d: Math.hypot(sc.x - sx, sc.y - sy) };
                        }
                    }
                });
            }
        }
    }
    
    if (specificItem) {
        search(specificItem, specificType);
    } else {
        Object.keys(data).forEach(L => {
            if (L === 'label') return; // Skip simple labels here, they are checked first
            data[L].forEach(item => search(item, L));
        });
    }

    return best;
}


function showLabelEditor(target) {
    activeLabelTarget = target;
    const el = document.getElementById('lblEditor');
    const inp = document.getElementById('lblInput');
    let val = '';
    
    // Determine the world position to calculate screen position for editor placement.
    let worldPos;
    if (target.type === 'simple') {
        worldPos = target.item.pt;
    } else if (target.type === 'point') {
        // Use stored label position or fall back to point location
        worldPos = target.item.ptLabelPos && target.item.ptLabelPos[target.index] ? target.item.ptLabelPos[target.index] : target.item.points[target.index];
    } else if (target.type === 'seg') {
        // Use stored label position or fall back to segment midpoint
        worldPos = target.item.segLabelPos && target.item.segLabelPos[target.index] ? target.item.segLabelPos[target.index] : getPolylineMidpoint([target.item.points[target.index], target.item.points[target.index+1]]);
    }
    const s = toScr(worldPos);


    if (target.type === 'point') {
        if(!target.item.ptLabels) target.item.ptLabels = {};
        val = target.item.ptLabels[target.index] || '';
        inp.placeholder = 'Point Note/Ft';
    } else if (target.type === 'seg') {
        if(!target.item.segLabels) target.item.segLabels = {};
        val = target.item.segLabels[target.index] || '';
        inp.placeholder = 'Segment Note/Ft';
    } else if (target.type === 'simple') {
        val = target.item.text || '';
        inp.placeholder = 'Label Text';
    }
    
    inp.value = val;
    // CRITICAL: Use the calculated screen coordinates for positioning
    el.style.left = s.x + 'px';
    el.style.top = s.y + 'px';
    el.style.display = 'block';
    inp.focus();
}

document.getElementById('lblInput').onchange = (e) => {
    if(!activeLabelTarget) return;
    const val = e.target.value;
    const item = activeLabelTarget.item;
    
    if(activeLabelTarget.type === 'point') {
        item.ptLabels[activeLabelTarget.index] = val;
        // If label is set/changed, reset stored position to default point location
        if(val) {
            if(!item.ptLabelPos) item.ptLabelPos = {};
            item.ptLabelPos[activeLabelTarget.index] = null;
        }
    } else if (activeLabelTarget.type === 'seg') {
        item.segLabels[activeLabelTarget.index] = val;
        // If label is set/changed, reset stored position to default midpoint
        if(val) {
            if(!item.segLabelPos) item.segLabelPos = {};
            item.segLabelPos[activeLabelTarget.index] = null;
        }
    } else if (activeLabelTarget.type === 'simple') {
        item.text = val;
        // If text is cleared, delete the simple label
        if (val === '') {
             const idx = data.label.indexOf(item);
             if(idx > -1) data.label.splice(idx, 1);
        }
    }
    
    document.getElementById('lblEditor').style.display = 'none';
    requestRender();
};

document.getElementById('lblInput').onblur = () => {
    setTimeout(() => { 
        // Ensure that if it's a new simple label and the user blurred without typing, we delete it.
        if (activeLabelTarget && activeLabelTarget.type === 'simple' && activeLabelTarget.item.text === '') {
             const idx = data.label.indexOf(activeLabelTarget.item);
             if(idx > -1) data.label.splice(idx, 1);
             requestRender();
        }
        document.getElementById('lblEditor').style.display = 'none'; 
    }, 200);
};

function splitLine(L, originalLine, segIndex, splitX, splitY) {
    originalLine.isSplit = true;
    const pointsA = originalLine.points.slice(0, segIndex+1);
    pointsA.push({x: splitX, y: splitY});
    const cpsA = originalLine.cps ? originalLine.cps.slice(0, segIndex+1) : [];
    if(cpsA.length > segIndex) cpsA[segIndex] = null; 

    const pointsB = [{x: splitX, y: splitY}].concat(originalLine.points.slice(segIndex+1));
    const cpsB = originalLine.cps ? originalLine.cps.slice(segIndex+1) : [];
    
    originalLine.points = pointsA;
    originalLine.cps = cpsA;
    originalLine.ft = ''; originalLine.bulbs = ''; originalLine.notes = '';
    
    const {label, index} = getNewItemData(L);
    const newLine = {
        points: pointsB,
        cps: cpsB,
        label: label,
        index: index,
        col: originalLine.col,
        ft: '', bulbs: '', notes: '',
        isSplit: true,
        clip: originalLine.clip, // Copy clip type
        fra: originalLine.fra || false, // Copy FRA state
        gguard: originalLine.gguard || false, // Copy Gutter Guard state
        isPillarMode: originalLine.isPillarMode || false // NEW: Copy Pillar state
    };
    data[L].push(newLine);
    refreshTable(); markPowerDirty();
}

cv.addEventListener('wheel',e=>{
    e.preventDefault();
    const r=canvasWrap.getBoundingClientRect();
    const mx=e.clientX-r.left, my=e.clientY-r.top;
    const w=toWorld(mx,my);
    const f = e.deltaY<0 ? 1.1 : 0.9;
    const nz = Math.max(0.1, Math.min(10, scale*f));
    panX = mx - w.x*nz;
    panY = my - w.y*nz;
    scale=nz;
    requestRender();
},{passive:false});

let redoStack = [];

function getNewItemData(L){
    actionCounter++;
    const p = pfx[L] || 'L';
    
    let label = '';
    // FIX: Wreath IDs use WR prefix regardless of size, followed by size suffix.
    if (L === 'wreath') {
        const pWreath = pfx.wreath || 'WR'; // Use generic WR prefix
        const indexWreath = nextIndex(pWreath);
        label = pWreath + indexWreath;
    } else if (L === 'label') { // Simple labels use LBL prefix
        label = pfx.label + nextIndex(pfx.label);
    } else {
        label = (L==='cords'||L==='threeway'||L==='powersource'||L==='bow') ? '' : p + nextIndex(p);
    }
    
    return {label, index: actionCounter};
}

document.getElementById('btnUndo').onclick=()=>{
    if (sketch && sketch.points.length > 0) {
        sketch.points.pop(); sketch.cps.pop();
        document.getElementById('btnComplete').disabled = sketch.points.length<2;
        markPowerDirty(); requestRender();
        return;
    }
    let maxIndex = -1; let targetObj = null; let targetLayer = null; let targetIdxInArray = -1;
    for (const L in data) {
        if (!data[L]) continue;
        data[L].forEach((item, idx) => {
            if (item.index > maxIndex) {
                maxIndex = item.index; targetObj = item; targetLayer = L; targetIdxInArray = idx;
            }
        });
    }
    if (targetObj && targetLayer) {
        redoStack.push({layer: targetLayer, item: targetObj});
        document.getElementById('btnRedo').disabled = false;
        data[targetLayer].splice(targetIdxInArray, 1);
        markPowerDirty(); requestRender(); refreshTable();
    }
};

document.getElementById('btnRedo').onclick = () => {
    if(redoStack.length === 0) return;
    const record = redoStack.pop();
    if(redoStack.length === 0) document.getElementById('btnRedo').disabled = true;
    data[record.layer].push(record.item);
    markPowerDirty(); requestRender(); refreshTable();
};

let sketch=null; 
function startNewSketch(){
    const data = getNewItemData(currLayer);
    // NEW: Include Pillar Mode state in the sketch
    sketch={points:[],cps:[],layer:currLayer,label:data.label, index: data.index, firstHost:null, isPillarMode: chkPillar.checked}; 
    document.getElementById('btnComplete').disabled=true;
}

// Function to finalize the current drawn line (FIXED)
function completeSketch() {
    if (!sketch || sketch.points.length < 2) return;
    
    // Add the completed line to the permanent data structure
    data[sketch.layer].push(sketch); 
    
    // Reset state and start a new sketch for the same layer
    const layer = sketch.layer;
    sketch = null;
    document.getElementById('btnComplete').disabled = true;
    startNewSketch(); // Start a fresh sketch immediately
    
    // Update dependencies
    markPowerDirty(); 
    refreshTable();
    requestRender(); 
}

document.getElementById('btnComplete').onclick = completeSketch; // <-- ADDED HANDLER

function handleTap(sx,sy){
    if(!imgReady || mode!=='draw' || draggingPoint) return;
    const w=toWorld(sx,sy);
    redoStack = []; document.getElementById('btnRedo').disabled = true;

    if(['powersource','threeway','tree','wreath','bow'].includes(currLayer)){
        // This was the missing function causing the failure
        placeItem(currLayer, w, sx, sy); 
        return;
    }
    if(!sketch) startNewSketch();
    
    // Check if the sketch is empty and start a new one if necessary
    if(sketch.points.length === 0 && !['ridges','fascia','peaks','groundstakes','garland','shrub','windows'].includes(currLayer)) {
        // This block is redundant if startNewSketch() is called correctly, but helps clarity
    }

    let pt = w; let snappedHost = null; let snappedSegIndex = -1;
    if(chkSnap.checked){
        const sn = getSnap(sx,sy,25); 
        if(sn) {
            pt = {x:sn.x, y:sn.y};
            if(sketch.points.length===0) sketch.firstHost = sn.host;
            if(sn.type === 'proj') { snappedHost = sn.host; snappedSegIndex = sn.seg; }
            if(sn.host && data.threeway.includes(sn.host)){
                if(countConnections(sn.host) >= 4){
                    showAlert("3-Way limit reached (Max 4 connections: 1 In, 3 Out).");
                    if(sketch.points.length === 0) return;
                }
            }
        }
    }
    
    if(sketch.points.length > 0 && pt) {
        const dest3Way = find3WayAt(pt);
        if(dest3Way) {
             if(countConnections(dest3Way) >= 4){
                 showAlert("Destination 3-Way limit reached.");
                 return;
             }
        }
    }
    
    sketch.points.push(pt);
    
    if(['garland','groundstakes','cords'].includes(currLayer)) {
        if(sketch.points.length > 1) {
            const p1 = sketch.points[sketch.points.length - 2];
            const p2 = sketch.points[sketch.points.length - 1];
            if(chkSwag.checked && currLayer === 'garland') {
                const mx = (p1.x + p2.x) / 2;
                const my = (p1.y + p2.y) / 2;
                const dist = Math.hypot(p2.x - p1.x, p2.y - p1.y);
                sketch.cps.push({x: mx, y: my + (dist * 0.2)}); 
            } else {
                sketch.cps.push(null);
            }
        }
    }

    if(snappedHost && snappedSegIndex > -1){
         const a = snappedHost.points[snappedSegIndex]; const b = snappedHost.points[snappedSegIndex+1];
         if(Math.hypot(pt.x-a.x, pt.y-a.y)>0.1 && Math.hypot(pt.x-b.x, pt.y-b.y)>0.1) {
             snappedHost.points.splice(snappedSegIndex+1, 0, {x:pt.x, y:pt.y});
             if(snappedHost.cps) snappedHost.cps.splice(snappedSegIndex+1, 0, null);
             markPowerDirty();
         }
    }
    // FIX: Ensure this line correctly checks the length and updates the button state
    document.getElementById('btnComplete').disabled = sketch.points.length < 2;
    markPowerDirty(); requestRender();
}

function handleSelectDown(sx, sy){
    // Hide move popup immediately
    document.getElementById('movePop').style.display = 'none';
    isMovingLabel = false; // Disable label moving on general selection check

    // 1. Try to set dragging point first (vertex or icon)
    let hitPoint = null;
    let bestPointDist = 45; // Max distance in pixels to consider a hit (Used for lines/vertices only)

    const searchPoints = (list, type, overrideHitbox=30) => {
        list.forEach((obj, i) => {
            const currentHitbox = (type === 'threeway' || type === 'powersource') ? 45 : overrideHitbox; // Custom hitbox for junctions
            if (obj.points) {
                // Check Vertices
                obj.points.forEach((p, index) => {
                    // Lines/Vertices selection uses a constant hitbox size (30px)
                    const d = Math.hypot(sx - toScr(p).x, sy - toScr(p).y);
                    if (d < currentHitbox) {
                        if (!hitPoint || d < hitPoint.d) {
                             hitPoint = { obj, index, type, d: d };
                        }
                    }
                });
            } else if (obj.pt) {
                // Check Icons/Single Points (Wreath, Tree, Power, 3Way, Bow, Simple Label)
                // Hitting Icons relies on the actual visual size scaled by its setting
                const scaleFactor = (type === 'threeway' || type === 'powersource') ? settings.junctionScale : settings.iconScale;
                const scaledHitbox = (type === 'label') ? 40 : 30 * scaleFactor; // Simple labels use fixed 40px hitbox
                
                const d = Math.hypot(sx - toScr(obj.pt).x, sy - toScr(obj.pt).y);
                if (d < scaledHitbox) {
                    if (!hitPoint || d < hitPoint.d) {
                         hitPoint = { obj, index: -1, type, d: d }; // index: -1 indicates icon/single point
                    }
                }
            }
        });
    };
    // Use a large default hitbox for initial sweep to ensure we catch large decorations
    Object.keys(data).forEach(k => searchPoints(data[k], k, bestPointDist)); 

    if (hitPoint && hitPoint.type !== 'label') { // Prevent dragging simple labels as vertices
        draggingPoint = hitPoint; // Initiate vertex/point dragging directly
        selectedItem = { type: hitPoint.type, obj: hitPoint.obj };
        document.getElementById('movePop').style.display = 'none';
        requestRender();
        return;
    }

    // 2. Try to select an entire line segment or object (for selecting the *object*)
    let bestObject = null;
    let bestObjectDist = 30; 
    const w = toWorld(sx, sy);

    const searchObjects = (list, type) => {
        list.forEach(obj => {
            if (obj.points) {
                for (let i = 0; i < obj.points.length - 1; i++) {
                    const p = projOnSeg(w, obj.points[i], obj.points[i + 1]);
                    const s = toScr(p.q);
                    const d = Math.hypot(sx - s.x, sy - s.y);
                    if (p.t >= 0 && p.t <= 1 && d < bestObjectDist) {
                        bestObjectDist = d;
                        bestObject = { type, obj };
                    }
                }
            } else if (obj.pt) {
                 // Icons/Simple Labels: Check if clicking near enough to select the whole icon object (Fallback/Confirmation click)
                 const d = Math.hypot(sx - toScr(obj.pt).x, sy - toScr(obj.pt).y);
                 if (d < bestObjectDist) {
                     bestObjectDist = d;
                     bestObject = { type, obj };
                 }
            }
        });
    };
    Object.keys(data).forEach(k => searchObjects(data[k], k));

    if (bestObject) {
        selectedItem = bestObject;
        
        // Show the move/delete popup buttons
        const c = getItemCenter(selectedItem.obj);
        const sc = toScr(c);
        const popEl = document.getElementById('movePop');
        popEl.style.left = `${sc.x}px`;
        popEl.style.top = `${sc.y + 20}px`; // Offset below the icon
        popEl.style.transform = 'translate(-50%, 0)';
        popEl.style.display = 'flex';
        
        // Show/Hide Move Label button based on object type
        const btnMoveLabel = document.getElementById('moveLabelToolBtn');
        if (selectedItem.obj.points) {
             btnMoveLabel.style.display = 'flex';
        } else {
             btnMoveLabel.style.display = 'none';
        }
    } else {
        selectedItem = null;
    }
    requestRender();
}

function getItemCenter(obj){
    if(obj.pt) return obj.pt;
    if(obj.points){
        let sx=0, sy=0; obj.points.forEach(p=>{sx+=p.x; sy+=p.y});
        return {x:sx/obj.points.length, y:sy/obj.points.length}; 
    }
    return {x:0,y:0};
}
function deleteItem(sel){
    const arr = data[sel.type]; const idx = arr.indexOf(sel.obj);
    if(idx > -1) arr.splice(idx, 1);
    markPowerDirty(); refreshTable();
    redoStack = []; document.getElementById('btnRedo').disabled = true;
}

function openPop(el, x, y, cb){
    el.style.display='flex'; const r = canvasWrap.getBoundingClientRect();
    el.style.left = '50%'; el.style.top = '50%'; el.style.transform = 'translate(-50%, -50%)';
    const h = e=>{ const v = e.target.dataset.bow || e.target.dataset.size; if(v){ cb(v); el.style.display='none'; el.removeEventListener('click',h); } }
    el.addEventListener('click',h);
}

function getPolylineMidpoint(points){
    if(points.length < 2) return points[0];
    let totalDist = 0; const segs = [];
    for(let i=0; i<points.length-1; i++){
        const d = Math.hypot(points[i+1].x - points[i].x, points[i+1].y - points[i].y);
        totalDist += d; segs.push(d);
    }
    let target = totalDist / 2;
    for(let i=0; i<segs.length; i++){
        if(target <= segs[i]){
            const t = target / segs[i];
            return { x: points[i].x + (points[i+1].x - points[i].x) * t, y: points[i].y + (points[i+1].y - points[i].y) * t };
        }
        target -= segs[i];
    }
    return points[points.length-1];
}

function drawTreeIcon(ctx, p, kind, size, scale, itemScale) { // Added itemScale (Icon/Decorations)
    const baseScale = 3.0; 
    scale *= (itemScale * 0.25 * baseScale); // Apply item scale factor
    
    if(kind.includes('Branch')) { 
        const h = 25 * scale;
        ctx.strokeStyle = 'black'; ctx.lineWidth = 5 * scale; ctx.lineCap = 'round'; ctx.lineJoin = 'round';
        ctx.beginPath(); 
        ctx.moveTo(p.x, p.y); ctx.lineTo(p.x, p.y - h); 
        ctx.moveTo(p.x - 12*scale, p.y - h*0.4); ctx.quadraticCurveTo(p.x, p.y - h*0.1, p.x + 12*scale, p.y - h*0.4);
        ctx.moveTo(p.x - 10*scale, p.y - h*0.7); ctx.quadraticCurveTo(p.x, p.y - h*0.4, p.x + 10*scale, p.y - h*0.7);
        ctx.stroke();
        ctx.strokeStyle = '#d4b483'; ctx.lineWidth = 3 * scale;
        ctx.beginPath(); ctx.moveTo(p.x, p.y); ctx.lineTo(p.x, p.y - h); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(p.x - 12*scale, p.y - h*0.4); ctx.quadraticCurveTo(p.x, p.y - h*0.1, p.x + 12*scale, p.y - h*0.4); ctx.stroke();
        ctx.beginPath(); ctx.moveTo(p.x - 10*scale, p.y - h*0.7); ctx.quadraticCurveTo(p.x, p.y - h*0.4, p.x + 10*scale, p.y - h*0.7); ctx.stroke();
    } else if(kind.includes('Canopy')) {
        const h = 30 * scale;
        ctx.strokeStyle = 'black'; ctx.lineWidth = 5 * scale;
        ctx.beginPath(); ctx.moveTo(p.x, p.y); ctx.lineTo(p.x, p.y - h/2); ctx.stroke();
        ctx.beginPath(); ctx.arc(p.x, p.y - h*0.6, 12*scale, 0, Math.PI*2); ctx.stroke();
        ctx.strokeStyle = '#fff'; ctx.lineWidth = 3 * scale;
        ctx.beginPath(); ctx.moveTo(p.x, p.y); ctx.lineTo(p.x, p.y - h/2); ctx.stroke();
        ctx.strokeStyle = '#6ee7b7';
        ctx.beginPath(); ctx.arc(p.x, p.y - h*0.6, 12*scale, 0, Math.PI*2); ctx.stroke();
    } else if(kind === 'C9 Tree') {
        const startY = p.y - 8*scale; const triH = 12 * scale; const triW = 14 * scale;
        ctx.strokeStyle = 'black'; ctx.lineWidth = 5 * scale; ctx.lineJoin = 'round';
        ctx.beginPath(); ctx.moveTo(p.x, p.y); ctx.lineTo(p.x, p.y - 8*scale); ctx.stroke();
        for(let i=0; i<3; i++){
            const yBase = startY - (i * triH * 0.6); 
            ctx.beginPath(); ctx.moveTo(p.x - triW * (1 - i*0.1), yBase); ctx.lineTo(p.x + triW * (1 - i*0.1), yBase); ctx.lineTo(p.x, yBase - triH); ctx.closePath(); ctx.stroke();
        }
        ctx.strokeStyle = '#fff'; ctx.lineWidth = 3 * scale;
        ctx.beginPath(); ctx.moveTo(p.x, p.y); ctx.lineTo(p.x, p.y - 8*scale); ctx.stroke();
        ctx.strokeStyle = '#6ee7b7';
        for(let i=0; i<3; i++){
            const yBase = startY - (i * triH * 0.6); 
            ctx.beginPath(); ctx.moveTo(p.x - triW * (1 - i*0.1), yBase); ctx.lineTo(p.x + triW * (1 - i*0.1), yBase); ctx.lineTo(p.x, yBase - triH); ctx.closePath(); ctx.stroke();
        }
    } else if (kind === 'ToL') {
        const h = (size || 9) * 3 * scale; const w = 8 * scale;
        ctx.beginPath(); ctx.moveTo(p.x, p.y - h); ctx.lineTo(p.x - w, p.y); ctx.lineTo(p.x + w, p.y); ctx.closePath();
        ctx.strokeStyle = 'black'; ctx.lineWidth = 6; ctx.stroke();
        ctx.fillStyle = '#2aa36e'; ctx.fill(); ctx.lineWidth = 2; ctx.stroke();
    } else {
        ctx.fillStyle = '#2aa36e'; ctx.beginPath(); ctx.arc(p.x, p.y, 10*scale, 0, Math.PI*2); ctx.fill(); ctx.stroke();
    }
}

function requestRender(){ 
    window.requestAnimationFrame(draw); 
}

function drawArrow(p, dir, color){
    // Scale size by settings.lineScale AND scale (zoom)
    const L = 10 * settings.lineScale * scale; 
    const ang = Math.atan2(dir.y, dir.x); 
    const baseWidth = 4 * settings.lineScale * scale;
    const colorWidth = 2 * settings.lineScale * scale;
    
    // Draw standard power arrow (fixed colors)
    ctx.beginPath(); 
    ctx.moveTo(p.x, p.y); ctx.lineTo(p.x - L*Math.cos(ang-Math.PI/6), p.y - L*Math.sin(ang-Math.PI/6));
    ctx.moveTo(p.x, p.y); ctx.lineTo(p.x - L*Math.cos(ang+Math.PI/6), p.y - L*Math.sin(ang+Math.PI/6));
    ctx.strokeStyle = 'black'; ctx.lineWidth = baseWidth; ctx.stroke();
    ctx.beginPath(); 
    ctx.moveTo(p.x, p.y); ctx.lineTo(p.x - L*Math.cos(ang-Math.PI/6), p.y - L*Math.sin(ang-Math.PI/6));
    ctx.moveTo(p.x, p.y); ctx.lineTo(p.x - L*Math.cos(ang+Math.PI/6), p.y - L*Math.sin(ang+Math.PI/6));
    ctx.strokeStyle = '#ff3b3b'; // Default red for power flow
    ctx.lineWidth = colorWidth; ctx.stroke();
}

function drawDeadEnd(p, neighbor, color){
    // R1: Dead end size scaled by settings.lineScale AND scale (zoom)
    const capLen = 7.5 * settings.lineScale * scale; // Was 5
    const sP = toScr(p); 
    const sN = toScr(neighbor);
    const dx = sP.x - sN.x, dy = sN.y - sP.y; 
    const ang = Math.atan2(dy, dx); 
    const baseWidth = 4 * settings.lineScale * scale; // Was 3
    const colorWidth = 2 * settings.lineScale * scale; // Was 1
    
    const px = Math.cos(ang + Math.PI/2) * capLen; 
    const py = Math.sin(ang + Math.PI/2) * capLen;
    
    ctx.beginPath(); ctx.moveTo(sP.x - px, sP.y - py); ctx.lineTo(sP.x + px, sP.y + py);
    ctx.strokeStyle = '#000'; ctx.lineWidth = baseWidth; ctx.stroke();
    ctx.strokeStyle = color; ctx.lineWidth = colorWidth; ctx.stroke();
}
function drawBow(x, y, scale, itemScale){
    // UPDATED: Scale factor changed from 0.05 to 0.4 to make the bow larger (approx 50% of tree size)
    const baseBowSize = 20; 
    const s = baseBowSize * itemScale * scale * 0.4; 
    
    ctx.fillStyle = '#ff3b3b'; 
    ctx.strokeStyle='black'; 
    ctx.lineWidth=1 * itemScale * scale;
    
    // Draw center
    ctx.beginPath(); ctx.arc(x, y, s*0.25, 0, Math.PI*2); ctx.fill(); ctx.stroke();
    
    ctx.beginPath(); ctx.ellipse(x-s*0.5, y-s*0.15, s*0.5, s*0.35, -0.3, 0, Math.PI*2); ctx.fill(); ctx.stroke();
    ctx.beginPath(); ctx.ellipse(x+s*0.5, y-s*0.15, s*0.5, s*0.35, 0.3, 0, Math.PI*2); ctx.fill(); ctx.stroke();
    
    // Draw tails
    ctx.beginPath(); ctx.moveTo(x,y); ctx.quadraticCurveTo(x-s*0.5, y+s*0.8, x-s*0.6, y+s*1.2); ctx.lineTo(x-s*0.3, y+s*1.2); ctx.quadraticCurveTo(x-s*0.2, y+s*0.8, x,y); ctx.fill();
    ctx.beginPath(); ctx.moveTo(x,y); ctx.quadraticCurveTo(x+s*0.5, y+s*0.8, x+s*0.6, y+s*1.2); ctx.lineTo(x+s*0.3, y+s*1.2); ctx.quadraticCurveTo(x+s*0.2, y+s*0.8, x,y); ctx.fill();
    
    ctx.stroke(); // Stroke the tails
}

// Function to calculate the length of a single segment (straight line or quadratic curve)
function segmentLength(p1, p2, cp = null) {
    if (!cp) {
        return Math.hypot(p2.x - p1.x, p2.y - p1.y);
    }
    // Approximation of quadratic Bezier curve length (simpler estimation)
    const d1 = Math.hypot(cp.x - p1.x, cp.y - p1.y);
    const d2 = Math.hypot(p2.x - cp.x, p2.y - p2.y);
    return d1 + d2; // Chord length approximation
}

// Function to find a point on a segment (straight line or quadratic curve) at a given distance t (0 to length)
function getPointOnSegmentAtDist(p1, p2, dist, targetDist, cp = null) {
    if (!cp) {
        const t = targetDist / dist;
        return { 
            x: p1.x + (p2.x - p1.x) * t, 
            y: p1.y + (p2.y - p1.y) * t,
            t: t,
            dx: (p2.x - p1.x) / dist, // Direction vector
            dy: (p2.y - p1.y) / dist
        };
    }
    // For quadratic curve, we iterate in small steps (less accurate but works for drawing)
    const steps = 20;
    let accumulatedDist = 0;
    let prevP = p1;

    for (let i = 1; i <= steps; i++) {
        const t = i / steps;
        const mt = 1 - t;
        const qx = mt * mt * p1.x + 2 * mt * t * cp.x + t * t * p2.x;
        const qy = mt * mt * p1.y + 2 * mt * t * cp.y + t * t * p2.y;
        const currentP = { x: qx, y: qy };
        
        const stepDist = Math.hypot(currentP.x - prevP.x, currentP.y - prevP.y);
        
        if (accumulatedDist + stepDist >= targetDist) {
            const remaining = targetDist - accumulatedDist;
            const subT = remaining / stepDist;
            
            const px = prevP.x + (currentP.x - prevP.x) * subT;
            const py = prevP.y + (currentP.y - prevP.y) * subT;
            
            // Approximate direction from the segment that contains the point
            const dx = (currentP.x - prevP.x) / stepDist;
            const dy = (currentP.y - prevP.y) / stepDist;

            return { x: px, y: py, t: t, dx, dy };
        }
        accumulatedDist += stepDist;
        prevP = currentP;
    }
    return { x: p2.x, y: p2.y, t: 1, dx: 0, dy: 0 }; // Should not happen if distances are right
}

function drawContinuousLine(it, col, layerName) {
    if (it.points.length < 2) return;
    const points = it.points.map(p => toScr(p));
    const cps = it.cps ? it.cps.map(p => p ? toScr(p) : null) : [];

    // Base line width
    const baseWidth = settings.lineThickness * settings.lineScale * scale;
    const strokeWidth = baseWidth + (4 * settings.lineScale * scale); 
    
    // Determine colors
    const rawColorString = it.col || '';
    
    // FIX 1: Normalize the raw input string to lowercase and split by separators for multi-color parsing
    const normalizedColorString = rawColorString.toLowerCase().replace(/\s/g, '/').replace(/,/g, '/');
    
    // Use the normalized string for splitting and resolving colors
    let colors = [];
    normalizedColorString.split('/').forEach(c => {
        if (!c) return;
        
        // CRITICAL FIX: Use the actual getColorCode on the individual color name (case-insensitive)
        const resolvedColor = getColorCode(c); 
        
        // If the resolved color string contains slashes (e.g. "Red/Blue/..." from 'Multi'), split it
        if (resolvedColor.includes('/')) {
             resolvedColor.split('/').forEach(subC => {
                 const subHex = getColorCode(subC);
                 if (subHex !== '#ddd') colors.push(subHex);
             });
        } else if (resolvedColor !== '#ddd') {
             colors.push(resolvedColor);
        }
    });
    
    // 1. Color Enforcement
    if (layerName === 'garland' || layerName === 'wreath') { 
        colors = [getColorCode('green')];
    } else if (layerName === 'cords') { 
        colors = ['#000000']; 
    } else if (layerName === 'shrub') { 
        if (colors.length === 0) {
            colors = [getColorCode('green')];
        }
    }
    
    // Fallback to default if no valid colors were parsed
    const finalColors = colors.length > 0 ? colors : [(isC9(layerName) ? colorOf('ridges') : col)]; 

    // --- Night Mode Glow Effect Setup ---
    let glowStrength = 0;
    let isLightElement = isC9(layerName) || ['windows', 'wreath', 'tree', 'bow', 'shrub'].includes(layerName);
    
    const AMBIENT_MULTIPLIER = 15; 
    const CORE_GLOW_BLUR = 2 * scale + (baseWidth * 1.5); 

    // We control the initial shadow state here, which affects the Ambient Pass
    if (isNightMode && isLightElement) {
        glowStrength = CORE_GLOW_BLUR; 
        ctx.shadowBlur = glowStrength;
    } else {
        ctx.shadowBlur = 0;
    }
    
    // --- Helper to draw the main path segments (Corrected path drawing) ---
    const drawPathSegments = () => {
        for (let i = 0; i < points.length - 1; i++) {
            const p2 = points[i+1];
            const cp = cps[i] || null;
            if (cp) ctx.quadraticCurveTo(cp.x, cp.y, p2.x, p2.y);
            else ctx.lineTo(p2.x, p2.y);
        }
    };
    
    // --- Helper to apply dashes per segment ---
    const drawDashedPath = (styleFn) => {
        for (let i = 0; i < points.length - 1; i++) {
            const p1 = points[i];
            const p2 = points[i+1];
            const cp = cps[i] || null;
            
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            
            const isDotted = it.isPillarMode && layerName === 'garland' && (i % 2 !== 0); 
            if (isDotted) { 
                 ctx.setLineDash([5 * settings.lineScale * scale, 5 * settings.lineScale * scale]); 
             } else { 
                 ctx.setLineDash([]); 
             }
             
            if (cp) ctx.quadraticCurveTo(cp.x, cp.y, p2.x, p2.y);
            else ctx.lineTo(p2.x, p2.y);
            
            styleFn(isDotted); // Apply color/stroke
            
            ctx.stroke();
            ctx.setLineDash([]); // Reset after stroke
        }
    };

    // --- 1. AMBIENT PASS (Full Path) ---
    // CRITICAL FIX: Skip ambient pass entirely if it's a multi-color line, as the color would be wrong.
    if (isNightMode && isLightElement && finalColors.length <= 1) { 
        const ambientBlur = CORE_GLOW_BLUR * AMBIENT_MULTIPLIER * 3; 
        const ambientAlpha = 0.05; 
        
        ctx.globalAlpha = ambientAlpha;
        ctx.shadowBlur = ambientBlur;
        ctx.shadowColor = finalColors[0];
        ctx.strokeStyle = finalColors[0]; 
        ctx.lineWidth = baseWidth * AMBIENT_MULTIPLIER * 1.5; 
        
        ctx.beginPath();
        if (points.length > 0) ctx.moveTo(points[0].x, points[0].y);
        drawPathSegments();
        ctx.lineCap = 'round'; ctx.lineJoin = 'round';
        ctx.stroke();

        ctx.globalAlpha = 1.0;
    }
    
    // Reset shadow after ambient pass (or if skipped)
    ctx.shadowBlur = 0;


    // --- 2. BLACK OUTLINE (Ensures visibility) ---
    
    // FIX: Skip general black outline for Cords, as it's handled in step 4
    if (layerName !== 'cords') { 
        ctx.shadowBlur = 0;
        ctx.strokeStyle = 'black'; 
        ctx.lineWidth = strokeWidth;
        ctx.lineCap = 'round'; ctx.lineJoin = 'round';
        
        // Use dashed path drawing for black outline for garland pillar mode
        drawDashedPath(() => { /* No special logic here, just apply stroke/dash */ });
    }
    
    // --- 3. COLOR DRAWING (Single Color vs. Multi-Color) ---
    
    if (finalColors.length <= 1) {
        // --- Single Color Path (Inner Line) ---
        const color = finalColors[0];
        
        if (isNightMode && isLightElement) {
            ctx.shadowBlur = glowStrength;
            ctx.shadowColor = color;
        } else {
            ctx.shadowBlur = 0;
        }

        ctx.strokeStyle = color; 
        ctx.lineWidth = baseWidth; 
        
        // Use dashed path drawing for inner color for garland pillar mode
        drawDashedPath(() => { /* No special logic here, just apply stroke/dash */ });

        // 4. Cord Specific Drawing (White and Black inner lines)
        if (layerName === 'cords') {
            ctx.shadowBlur = 0;
            
            // White middle stroke
            ctx.strokeStyle = 'white';
            ctx.lineWidth = baseWidth * 1.5; 
            ctx.beginPath();
            if (points.length > 0) ctx.moveTo(points[0].x, points[0].y);
            drawPathSegments();
            ctx.stroke();
            
            // Black inner stroke (final line)
            ctx.strokeStyle = '#000000'; 
            ctx.lineWidth = baseWidth; 
            ctx.beginPath();
            if (points.length > 0) ctx.moveTo(points[0].x, points[0].y);
            drawPathSegments();
            ctx.stroke();
        }
        
    } else {
        // --- Multi-Color Path (Segment by Segment Blocks) ---
        
        const segmentLengths = [];
        for (let i = 0; i < it.points.length - 1; i++) {
            segmentLengths.push(segmentLength(it.points[i], it.points[i+1], it.cps?.[i]));
        }
        
        const colorBlockLength = Math.max(10, 10 * settings.lineScale * scale); 
        let colorIndex = 0;

        for (let i = 0; i < points.length - 1; i++) {
            const p1 = points[i];
            const p2 = points[i+1];
            const cp = cps[i];
            const segDist = segmentLength(it.points[i], it.points[i+1], it.cps?.[i]) * scale;
            
            // Check for Pillar Garland Dashing on Multi-Color lines (applies to the whole segment)
            const isDottedSegment = it.isPillarMode && layerName === 'garland' && (i % 2 !== 0);
            
            let currentDistInSegment = 0;
            let lastDrawnPoint = p1;

            while (currentDistInSegment < segDist) {
                const color = finalColors[colorIndex % finalColors.length];
                const remainingDistInSegment = segDist - currentDistInSegment;
                const blockDist = Math.min(colorBlockLength, remainingDistInSegment);
                
                // We need to use world coordinates for the segment length calculation to find the point
                const ptObj = getPointOnSegmentAtDist(it.points[i], it.points[i+1], segmentLength(it.points[i], it.points[i+1], it.cps?.[i]), (currentDistInSegment + blockDist) / scale, it.cps?.[i]);
                const endPoint = toScr({x: ptObj.x, y: ptObj.y});
                
                if (blockDist > 0.1) {
                    if (isNightMode && isLightElement) {
                        // CRITICAL FIX: Set shadow color and blur for this specific segment
                        ctx.shadowBlur = glowStrength;
                        ctx.shadowColor = color;
                    } else {
                        ctx.shadowBlur = 0;
                    }
                    
                    ctx.beginPath();
                    ctx.moveTo(lastDrawnPoint.x, lastDrawnPoint.y);
                    ctx.lineTo(endPoint.x, endPoint.y);
                    
                    // Apply dash if the overall segment is dotted
                    if (isDottedSegment) { 
                         ctx.setLineDash([5 * settings.lineScale * scale, 5 * settings.lineScale * scale]); 
                    } else { 
                         ctx.setLineDash([]); 
                    }
                    
                    ctx.strokeStyle = color; 
                    ctx.lineWidth = baseWidth; 
                    ctx.stroke();
                    ctx.setLineDash([]); // Reset after stroke
                    
                    // CRITICAL FIX: Reset shadow immediately after stroke so it doesn't affect the next block
                    ctx.shadowBlur = 0; 
                }

                currentDistInSegment += blockDist;
                lastDrawnPoint = endPoint;
                colorIndex++; 
            }
        }
    }
    
    // Always reset shadow after drawing loop is complete
    ctx.shadowBlur = 0;
    ctx.setLineDash([]); // Ensure line dash is reset globally
}

function drawCord(it, col, layerName) { // ADDED layerName
    if (it.points.length < 2) return;
    drawContinuousLine(it, col, layerName);
}

// Function to draw a rounded rectangle (RETAINED)
function roundRect(ctx, x, y, w, h, r) {
    if (w < 2 * r) r = w / 2;
    if (h < 2 * r) r = h / 2;
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
}

function drawLabels(ctx, isExport=false) {
    // --- Draw Main Line Labels (Always on top) ---
    const nominalFontSize = 14;
    // Base font scaling on combined map scale, icon scale, and new label scale
    const fontScaleFactor = Math.min(1, scale * settings.labelScale); 
    const currentFontSize = nominalFontSize * fontScaleFactor; 
    
    if (currentFontSize > 5) { // Only draw if font is reasonably sized
        ctx.font=`bold ${currentFontSize}px system-ui`; 
        ctx.fillStyle='white'; ctx.textAlign='center'; ctx.textBaseline='middle';

        Object.keys(data).forEach(k=>data[k].forEach(it=>{
            if(!it.label || k === 'label') return;
            let p;
            let offY;
            
            // 1. Determine base world position for label
            if(it.points) {
                 p = getPolylineMidpoint(it.points); 
                 offY = -14 * fontScaleFactor; // Default vertical offset for line labels
            } else if (it.kind === 'ToL') {
                 const treeScale = (k === 'tree') ? settings.iconScale : 1.0;
                 const h = (it.size || 9) * 3 * scale * treeScale; 
                 p = {x: it.pt.x, y: it.pt.y - (h/2)/scale}; 
                 offY = 0;
            } else {
                 p = it.pt;
                 offY = 0;
            }
            const s = toScr(p);

            // 2. Determine text and suffix
            let suffix = '';
            if(isC9(k) && it.clip) suffix = ` ${it.clip}`;
            if(k === 'wreath') suffix = ` ${it.size}`; 
            if(it.fra) suffix += ' (FRA)'; // ADD FRA SUFFIX
            if(it.gguard) suffix += ' (GG)'; // ADD Gutter Guard SUFFIX
            
            const labelText = it.label + suffix;
            const metrics = ctx.measureText(labelText);
            const textWidth = metrics.width;
            
            // 3. Calculate box geometry based on font scale
            const padX = 6 * fontScaleFactor;
            const padY = 4 * fontScaleFactor;
            const currentHeight = currentFontSize;
            const boxWidth = textWidth + (2 * padX);
            const boxHeight = currentHeight + (2 * padY);
            const radius = 6 * fontScaleFactor;
            
            const boxX = s.x - boxWidth/2;
            const boxY = s.y + offY - boxHeight/2;

            // Draw Black background rectangle with 75% opacity and rounded corners
            ctx.fillStyle = 'rgba(0, 0, 0, 0.75)'; 
            roundRect(ctx, boxX, boxY, boxWidth, boxHeight, radius);
            ctx.fill();

            // Draw text (White text, no stroke)
            ctx.fillStyle='white'; 
            ctx.fillText(labelText, s.x, s.y + offY);
        }));
    }

    // --- Draw Cord Labels (Segment/Point) ---
    const nominalCordFontSize = 12;
    const cordFontScaleFactor = Math.min(1, scale * settings.labelScale);
    const currentCordFontSize = nominalCordFontSize * cordFontScaleFactor;
    
    if (currentCordFontSize > 5) { // Only draw if font is reasonably sized
        ctx.font=`bold ${currentCordFontSize}px system-ui`; 
        ctx.fillStyle='white'; ctx.textAlign='center'; ctx.textBaseline='middle';
        
        // Helper to draw a generic label box
        const drawLabelBox = (s, txt, scaleFactor) => {
             const metrics = ctx.measureText(txt);
             const textWidth = metrics.width;
             
             const padX = 4 * scaleFactor; 
             const padY = 3 * scaleFactor;
             const currentHeight = nominalCordFontSize * scaleFactor;
             const boxWidth = textWidth + (2 * padX);
             const boxHeight = currentHeight + (2 * padY);
             const radius = 4 * scaleFactor;
             
             const boxX = s.x - boxWidth/2;
             const boxY = s.y - boxHeight/2;

             ctx.fillStyle = 'rgba(0, 0, 0, 0.75)'; 
             roundRect(ctx, boxX, boxY, boxWidth, boxHeight, radius);
             ctx.fill();

             ctx.fillStyle='white'; ctx.fillText(txt, s.x, s.y);
        };

        // Lines/Cords: Segment and Point Labels
        const lineLayers = ['ridges','fascia','peaks','groundstakes','garland','cords','shrub','windows'];
        lineLayers.forEach(lineLayer => {
            data[lineLayer].forEach(line => {
                // Segment Labels
                if(line.segLabels) {
                    Object.keys(line.segLabels).forEach(idx => {
                        const i = parseInt(idx);
                        if(i < line.points.length - 1) {
                            // Use stored position or calculate midpoint world position
                            const wPos = line.segLabelPos && line.segLabelPos[i] ? line.segLabelPos[i] : getPolylineMidpoint([line.points[i], line.points[i+1]]);
                            const s = toScr(wPos);
                            const txt = line.segLabels[idx];
                            if(txt) drawLabelBox(s, txt, cordFontScaleFactor);
                        }
                    });
                }
                // Point Labels
                if(line.ptLabels) {
                    Object.keys(line.ptLabels).forEach(idx => {
                        const i = parseInt(idx);
                        if(i < line.points.length) {
                            // Use stored position or calculate default offset screen position (for drawing)
                            const point = line.points[i];
                            let s; // Screen position
                            
                            if (line.ptLabelPos && line.ptLabelPos[i]) {
                                s = toScr(line.ptLabelPos[i]);
                            } else {
                                // Default offset position (based on point, slightly up-left on screen)
                                const offset = 15 * cordFontScaleFactor;
                                const defaultScreenPos = toScr(point);
                                s = {x: defaultScreenPos.x + offset, y: defaultScreenPos.y - offset};
                            }

                            const txt = line.ptLabels[idx];
                            if(txt) drawLabelBox(s, txt, cordFontScaleFactor);
                        }
                    });
                }
            });
        });
        
        // Simple Labels
        data.label.forEach(it => {
            if (!it.text) return; 
            const s = toScr(it.pt);
            drawLabelBox(s, it.text, cordFontScaleFactor);
        });
    }
}


function draw(){
    if (!ctx) return;
    const r = canvasWrap.getBoundingClientRect();
    const width = r.width; const height = r.height;
    if (width !== lastWidth || height !== lastHeight) { initializeAndSizeContext(); return; }
    
    const cw = cv.width / DPR; const ch = cv.height / DPR;
    ctx.fillStyle='#000000'; ctx.fillRect(0,0,cw,ch);
    
    let isBlankMap = imgReady && !imgDataUrl;
    
    if(isBlankMap){
        // Blank map: Fill with white and skip the aerial background box fill
        ctx.fillStyle='#ffffff'; ctx.fillRect(0,0,cw,ch);
    } else {
        // Aerial map: Fill with dark gray/blue before drawing image
        ctx.fillStyle='#0b0f19'; ctx.fillRect(0,0,cw,ch);
    }
    
    // --- NIGHT MODE AERIAL IMAGE FILTERING ---
    let imageFilter = 'none';
    if(imgReady && imgDataUrl && isNightMode) {
        // Darken and slightly desaturate the image to simulate night/dusk
        imageFilter = 'brightness(0.25) grayscale(0.2)'; 
    }
    
    if(imgReady && imgDataUrl){ 
        ctx.filter = imageFilter;
        ctx.drawImage(bg, panX, panY, bg.width*scale, bg.height*scale); 
        ctx.filter = 'none'; // Reset filter before drawing lines/icons
    } else if (!imgReady) { // Only show instruction text if no map (blank or image) is loaded yet
        ctx.fillStyle='#151b2b'; ctx.textAlign='center'; ctx.textBaseline='middle';
        ctx.font='16px system-ui'; ctx.fillStyle='#456';
        ctx.fillText('Load an image to start or click to draw on a blank map', cw/2, ch/2);
    }
    
    // Power flow arrows (no glow)
    ctx.shadowBlur = 0;
    const pg = analyzePower();
    
    // --- DRAW LINES (Cords, Lines, Garland, Shrub, Windows) ---
    // Cords layer: drawCord calls drawContinuousLine where color is enforced black
    data.cords.forEach(it => { drawCord(it, getColorCode(it.col) || colorOf('cords'), 'cords'); }); 
    
    // Other layers: drawContinuousLine handles fixed colors for shrub and garland
    ['shrub','windows','ridges','fascia','peaks','groundstakes','garland'].forEach(L=>{
        data[L].forEach(it=>{
            drawContinuousLine(it, getColorCode(it.col) || colorOf(L), L); 
        });
    });
    
    // --- POWER ARROWS AND DEAD ENDS ---
    if(pg){
        // 1. Draw arrows on standard layers
        pg.edges.forEach(e => {
            if(['garland', 'groundstakes'].includes(e.type)) return; // Skip single-path layers here
            
            const uNode = pg.nodes[e.u]; const vNode = pg.nodes[e.v];
            if(uNode.dist !== Infinity && vNode.dist !== Infinity){
                const uPos = toScr({x:uNode.x, y:uNode.y}); 
                const vPos = toScr({x:vNode.x, y:vNode.y});
                let from, to, isReversed;
                if(uNode.dist < vNode.dist) { from = uPos; to = vPos; isReversed = false; } 
                else if(vNode.dist < uNode.dist) { from = vPos; to = uPos; isReversed = true; }
                else return; 

                const cp = e.cps ? toScr(e.cps) : null;
                const dist = Math.hypot(vPos.x - uPos.x, vPos.y - uPos.y);
                // Arrow density based on frequency factor
                let count = Math.floor(dist/150 * settings.arrowFreqFactor); 
                
                // CRITICAL FIX: Ensure at least one arrow for non-cord lines (if freq > 0.5)
                if (e.type !== 'cords' && count === 0 && settings.arrowFreqFactor > 0.5) count = 1; 

                if(cp) {
                    for(let k=1; k<=count; k++){
                        let t = k / (count+1);
                        const invT = 1 - t;
                        const px = invT*invT*uPos.x + 2*invT*t*cp.x + t*t*vPos.x;
                        const py = invT*invT*uPos.y + 2*invT*t*cp.y + t*t*vPos.y;
                        const tx = 2*invT*(cp.x - uPos.x) + 2*t*(vPos.x - cp.x);
                        const ty = 2*invT*(cp.y - uPos.y) + 2*t*(vPos.y - cp.y);
                        let dir = {x: tx, y: ty};
                        if(isReversed) { dir.x = -dir.x; dir.y = -dir.y; }
                        drawArrow({x: px, y: py}, dir, '#ff3b3b');
                    }
                } else {
                    const dx = to.x - from.x, dy = to.y - from.y; 
                    for(let k=1; k<=count; k++){
                        const t = k / (count+1);
                        drawArrow({x:from.x + dx*t, y:from.y + dy*t}, {x:dx, y:dy}, '#ff3b3b');
                    }
                }
            }
        });
        
        // 2. Draw arrows for single-path layers (Garland, Stakes)
        pg.singleArrowEdges.forEach(a => {
            const edge = a.edge;
            const uPos = toScr(edge.line.points[edge.index]); 
            const vPos = toScr(edge.line.points[edge.index+1]);
            const segDist = segmentLength(uPos, vPos, edge.cps ? toScr(edge.cps) : null);
            
            // Get point on segment at calculated distance (in screen space for simplicity here, though path analysis was world)
            const ptObj = getPointOnSegmentAtDist(uPos, vPos, segDist, a.distInSegment * scale, edge.cps ? toScr(edge.cps) : null);
            
            let dir = {x: ptObj.dx, y: ptObj.dy};
            if (a.isReversed) { dir.x = -dir.x; dir.y = -dir.y; }
            
            // Single arrow per object (center of object)
            drawArrow({x: ptObj.x, y: ptObj.y}, dir, '#ff3b3b');
        });
        
        // 3. Draw Dead Ends
        pg.deadTips.forEach(nodeIdx => {
            const n = pg.nodes[nodeIdx]; const neighborIdx = n.adj[0]; 
            if(neighborIdx !== undefined){ drawDeadEnd(n, pg.nodes[neighborIdx], '#fffdf0'); }
        });
    }

    // Apply icon scale factor to items
    const itemScale = settings.iconScale; 
    const junctionScale = settings.junctionScale; // NEW junction scale
    const labelScale = settings.labelScale;

    // --- ICON DRAWING (with glow logic) ---
    const CORE_GLOW_BLUR = 2; // Fixed base glow strength for icons

    data.wreath.forEach(w=>{
        const s=toScr(w.pt); 
        const r=(w.size==='42"'?12.5:8.75) * scale * itemScale; // Apply itemScale (Decoration scale)
        
        const wreathColor = colorOf('wreath'); // Green fill
        
        if (isNightMode) {
            
            // R3: Ambient pass for icons
            const ambientBlur = CORE_GLOW_BLUR * 3 * 15 * scale;
            const ambientAlpha = 0.05;
            
            ctx.globalAlpha = ambientAlpha;
            ctx.shadowBlur = ambientBlur;
            ctx.shadowColor = wreathColor;
            ctx.beginPath(); ctx.arc(s.x,s.y,r*1.5,0,Math.PI*2); // Wider radius for glow
            ctx.fillStyle = wreathColor; 
            ctx.fill();
            
            ctx.globalAlpha = 1.0;
            ctx.shadowBlur = CORE_GLOW_BLUR * 15 * scale; // Core glow is amplified
            ctx.shadowColor = wreathColor;
        } else {
             ctx.shadowBlur = 0;
        }

        ctx.beginPath(); ctx.arc(s.x,s.y,r,0,Math.PI*2);
        ctx.fillStyle = colorOf('wreath'); 
        ctx.fill();
        
        ctx.shadowBlur = 0; // Black stroke should not glow
        ctx.strokeStyle='black'; ctx.lineWidth=6 * itemScale * scale; ctx.stroke(); 
        ctx.strokeStyle=colorOf('wreath'); ctx.lineWidth=3 * itemScale * scale; ctx.stroke(); // Green inner stroke
        
        if(w.bow === 'top' || w.bow === 'bottom'){
            const by = w.bow==='top' ? s.y - r : s.y + r;
            // Bow glow is handled internally by its color/glow applied in drawContinuousLine
            drawBow(s.x, by, scale, itemScale); 
        }
        ctx.shadowBlur = 0; // Reset after drawing wreath item
    });
    ctx.shadowBlur = 0; // Final reset after wreaths drawing loop

    data.bow.forEach(b=>{ 
        const s=toScr(b.pt); 
        if (isNightMode) {
            ctx.shadowBlur = CORE_GLOW_BLUR * 15 * scale;
            ctx.shadowColor = '#ff3b3b'; // Red glow for bows
        } else {
            ctx.shadowBlur = 0;
        }
        drawBow(s.x, s.y, scale, itemScale); 
        ctx.shadowBlur = 0; // Reset after drawing bow item
    }); 
    ctx.shadowBlur = 0;

    data.tree.forEach(tr => {
        const p = toScr(tr.pt);
        // Determine glow color based on tree type or color field
        let treeGlowColor = colorOf('shrub'); // Default green glow for general trees
        if (tr.kind === 'C9 Tree') {
            // C9 trees glow based on user's selected color (defaults to warm white if empty)
            const treeColor = getColorCode(tr.col || '') || colorOf('ridges'); 
            treeGlowColor = treeColor;
        } else {
            treeGlowColor = colorOf('shrub'); // Minis/Canopy glow green
        }

        if (isNightMode) {
            
            // R3: Ambient pass for icons
            const ambientBlur = CORE_GLOW_BLUR * 3 * 15 * scale;
            const ambientAlpha = 0.05;
            
            ctx.globalAlpha = ambientAlpha;
            ctx.shadowBlur = ambientBlur;
            ctx.shadowColor = treeGlowColor;
            ctx.beginPath(); ctx.arc(p.x, p.y, 25 * itemScale * scale, 0, Math.PI*2); 
            ctx.fillStyle = treeGlowColor;
            ctx.fill();
            
            ctx.globalAlpha = 1.0;
            ctx.shadowBlur = CORE_GLOW_BLUR * 15 * scale; // Core glow is amplified
            ctx.shadowColor = treeGlowColor;
        } else {
            ctx.shadowBlur = 0;
        }
        drawTreeIcon(ctx, p, tr.kind, tr.size, scale, itemScale); 
        ctx.shadowBlur = 0; // Reset after drawing tree item
    });
    ctx.shadowBlur = 0;
    
    data.powersource.forEach(ps=>{
        const s=toScr(ps.pt);
        // Power sources scale by junctionScale AND scale
        const size = 8 * junctionScale * scale; 
        const strokeWidth = 3 * junctionScale * scale; 
        
        ctx.shadowBlur = isNightMode ? 10 * junctionScale * scale : 0;
        ctx.shadowColor = '#ff3b3b';
        
        ctx.fillStyle='#ff3b3b'; 
        ctx.fillRect(s.x-size/2, s.y-size/2, size, size);
        
        ctx.shadowBlur = 0; // Black/White strokes do not glow
        ctx.strokeStyle='black'; 
        ctx.lineWidth=strokeWidth; 
        ctx.strokeRect(s.x-size/2, s.y-size/2, size, size);
        ctx.strokeStyle='white'; 
        ctx.lineWidth=strokeWidth/2; 
        ctx.strokeRect(s.x-size/2, s.y-size/2, size, size);
        ctx.shadowBlur = 0; // Reset after drawing powersource item
    });
    ctx.shadowBlur = 0;


    if(data.threeway){
        data.threeway.forEach(tw=>{
            const s = toScr(tw.pt);
            // 3-ways scale by junctionScale AND scale
            const sz = 6 * scale * junctionScale; 
            const strokeWidth = 3 * junctionScale * scale;

            if (isNightMode) {
                 ctx.shadowBlur = CORE_GLOW_BLUR * 15 * scale;
                 ctx.shadowColor = '#ffd86a';
            } else {
                 ctx.shadowBlur = 0;
            }
            
            ctx.beginPath();
            ctx.moveTo(s.x, s.y - sz); 
            ctx.lineTo(s.x + sz, s.y + sz); 
            ctx.lineTo(s.x - sz, s.y + sz); 
            ctx.closePath();
            ctx.fillStyle = '#ffd86a'; ctx.fill();
            ctx.shadowBlur = 0; // Strokes do not glow
            ctx.strokeStyle = 'black'; 
            ctx.lineWidth = strokeWidth; 
            ctx.stroke(); 
            ctx.strokeStyle = 'white'; 
            ctx.lineWidth = strokeWidth/2; ctx.stroke(); 
            ctx.shadowBlur = 0; // Reset after drawing threeway item
        });
    }
    ctx.shadowBlur = 0;

    // --- Draw Final Sketch (Always on top of everything except selection markers) ---
    if(sketch && sketch.points.length>0){
        const cursor = cv._mx!=null ? toWorld(cv._mx, cv._my) : null;
        const pts = [...sketch.points]; if(cursor) pts.push(cursor);
        const skObj = {points: pts, cps: sketch.cps || [], L: sketch.layer, col: sketch.col, isPillarMode: sketch.isPillarMode}; // Pass layer and color info
        
        // Pass the actual color value/default color
        const sketchColor = getColorCode(sketch.col) || colorOf(sketch.layer);

        drawContinuousLine(skObj, sketchColor, sketch.layer); 

        if(chkSnap.checked && cv._mx!=null){
             const sn = getSnap(cv._mx, cv._my, 25);
             if(sn){
                 const s = toScr({x:sn.x, y:sn.y});
                 ctx.beginPath(); ctx.arc(s.x, s.y, 5, 0, Math.PI*2);
                 ctx.fillStyle = '#ffff00'; ctx.fill(); ctx.strokeStyle = '#000'; ctx.lineWidth=1; ctx.stroke();
             }
        }
    }

    // --- DRAW LABELS (Always last for z-index) ---
    drawLabels(ctx);


    if(selectedItem){
        const obj = selectedItem.obj;
        // FIX: Selection markers/delete buttons should be based on a constant size for control, not the decorative icon scale.
        const selectionBaseScale = 1.0; 

        if(obj.points){
             // Draw draggable vertices (fixed size)
             obj.points.forEach(p=>{
                 const s = toScr(p); 
                 ctx.beginPath(); ctx.arc(s.x, s.y, 6 * selectionBaseScale, 0, Math.PI*2);
                 ctx.fillStyle = 'white'; ctx.fill(); 
                 ctx.strokeStyle = '#4a90e2'; ctx.lineWidth=2 * selectionBaseScale; ctx.stroke();
             });
        } else if (obj.pt){
            const s = toScr(obj.pt); 
            // Draw selection circle around icon (fixed size)
            ctx.beginPath(); ctx.arc(s.x, s.y, 15 * selectionBaseScale, 0, Math.PI*2); 
            ctx.strokeStyle = '#4a90e2'; ctx.lineWidth=2 * selectionBaseScale; ctx.stroke();
        }
        
        // If we are in 'move' mode, draw a large drag indicator
        if (mode === 'move') {
            const c = getItemCenter(obj);
            const sc = toScr(c);
            ctx.fillStyle = 'rgba(255, 60, 60, 0.5)';
            ctx.beginPath(); ctx.arc(sc.x, sc.y, 25, 0, Math.PI*2); ctx.fill();
        }
        
        // If we are in 'move-label' mode, highlight potential label drag targets
        if (mode === 'move-label') {
             const labelTargets = checkLabelClick(cv._mx, cv._my, obj, selectedItem.type);
             if (labelTargets) {
                 ctx.strokeStyle = '#00ff00';
                 ctx.lineWidth = 3;
                 ctx.beginPath(); ctx.arc(labelTargets.x, labelTargets.y, 25, 0, Math.PI*2); ctx.stroke();
             }
        }
    }
}


// Functionality to manage splash screen opening/closing
/*
function unlock(){
    document.body.classList.remove('blurred');
    document.getElementById('gate').classList.add('hide');
    // Push state for back button trap
    history.pushState(null, null, location.href);
}
*/

// Back Button Trap
window.addEventListener('popstate', () => {
    document.getElementById('modalBack').style.display = 'flex';
});

document.getElementById('btnStay').onclick = () => {
    document.getElementById('modalBack').style.display = 'none';
    history.pushState(null, null, location.href); // Re-push state to trap again
};

document.getElementById('btnLeave').onclick = () => {
    document.getElementById('modalBack').style.display = 'none';
    history.back(); // Allow exit
};

// IMPROVED FILE HANDLER: Checks for null input AND resets input value
const handleImg = (f)=>{
    if(!f) return;
    const r=new FileReader();
    r.onload=()=>{
        imgDataUrl=r.result;
        bg.src=imgDataUrl;
        bg.onload=()=>{
            imgReady=true; 
            document.body.classList.remove('white-bg'); // REMOVE white-bg when an image loads
            resetView(); 
            unlock();
        };
        bg.onerror=()=>{ showAlert("Failed to load image"); };
    };
    r.readAsDataURL(f);
};

// New function to safely initiate a blank map state (FIX for blank map drawing)
function startBlankMap() {
    // Set default dimensions for coordinate system if none exist (1000x1000 world units)
    bg.width = 1000;
    bg.height = 1000;
    imgDataUrl = null; // Ensure no old image data is kept
    imgReady = true; 
    document.body.classList.add('white-bg'); // ADD white-bg for blank paper effect
    resetView();
    unlock();
}

// --- NEW FUNCTION TO APPLY UI STATE ---
function applyUIState(o) {
    // 1. Load Sliders (The handleMap function sets the input values, this ensures display is right)
    lineScaleInput.value = settings.lineScale;
    iconScaleInput.value = settings.iconScale;
    junctionScaleInput.value = settings.junctionScale;
    labelScaleInput.value = settings.labelScale;
    arrowFreqInput.value = settings.arrowFreqFactor; // NEW
    
    updateLineScaleUI(); 
    updateIconScaleUI();
    updateJunctionScaleUI();
    updateLabelScaleUI();
    updateArrowFreqUI(); // NEW
    
    // 2. Load Toggle States
    const uiState = o.uiState || {};
    
    // Night Mode
    isNightMode = uiState.isNightMode !== undefined ? uiState.isNightMode : false;
    btnNightMode.classList.toggle('toggled', isNightMode);
    
    // Snap Toggle
    chkSnap.checked = uiState.isSnapOn !== undefined ? uiState.isSnapOn : true;
    btnSnap.classList.toggle('toggled', chkSnap.checked);
    
    // Swag Toggle
    chkSwag.checked = uiState.isSwagOn !== undefined ? uiState.isSwagOn : false;
    btnSwag.classList.toggle('toggled', chkSwag.checked);
    
    // Pillar Toggle
    chkPillar.checked = uiState.isPillarOn !== undefined ? uiState.isPillarOn : false;
    btnPillar.classList.toggle('toggled', chkPillar.checked);

    // Auto-Calc Checkbox
    const chkAuto = document.getElementById('chkAutoCalc');
    chkAuto.checked = uiState.isAutoCalcOn !== undefined ? uiState.isAutoCalcOn : true;
    
    // Ensure white-bg class is handled if no image data but data exists
    if (!imgDataUrl && Object.keys(data).some(k => data[k].length > 0)) {
        document.body.classList.add('white-bg');
    } else if (imgDataUrl) {
         document.body.classList.remove('white-bg');
    }

    // Re-render canvas to reflect night mode/snap/scale changes
    requestRender();
}


const handleMap = (f)=>{
    if(!f) return;
    const r=new FileReader(); r.onload=()=>{ 
        try{ 
            const o=JSON.parse(r.result); 
            imgDataUrl=o.image||null; 
            
            if(o.data) {
                 let maxIndex = 0;
                 // Backwards compatibility for the new 'label' layer
                 if (!o.data.label) o.data.label = []; 
                 
                 for (const L in data) {
                     data[L] = o.data[L] || [];
                     data[L].forEach(item => {
                         if(item.index > maxIndex) maxIndex = item.index;
                         if(isC9(L) && item.clip && item.fra === undefined) item.fra = false; 
                         if(isC9(L) && item.clip && item.gguard === undefined) item.gguard = false; // Initialize Gutter Guard
                         if(L === 'garland' && item.isPillarMode === undefined) item.isPillarMode = false; // Initialize Pillar Mode
                     });
                 }
                 actionCounter = maxIndex;
            }

            // Load Settings, handling all scale properties
            const MIN_SCALE = 0.5; // Same as slider minimum
            if (o.settings) {
                // Ensure loaded values are clamped at a visible minimum (MIN_SCALE)
                settings.iconScale = Math.max(MIN_SCALE, o.settings.iconScale !== undefined ? o.settings.iconScale : 1.5);
                settings.junctionScale = Math.max(MIN_SCALE, o.settings.junctionScale !== undefined ? o.settings.junctionScale : 1.0); // NEW
                settings.lineScale = Math.max(MIN_SCALE, o.settings.lineScale !== undefined ? o.settings.lineScale : 1.5);
                // Preserve loaded labelScale, or use the new 3.0 default if missing
                settings.labelScale = Math.max(MIN_SCALE, o.settings.labelScale !== undefined ? o.settings.labelScale : 3.0);
                settings.arrowFreqFactor = Math.max(0.5, o.settings.arrowFreqFactor !== undefined ? o.settings.arrowFreqFactor : 1.0); // NEW
                
                // Backwards compatibility for single itemScale being loaded
                if (o.settings.itemScale !== undefined && o.settings.iconScale === undefined) {
                    settings.iconScale = Math.max(MIN_SCALE, o.settings.itemScale);
                    settings.lineScale = Math.max(MIN_SCALE, o.settings.itemScale);
                    settings.labelScale = 3.0; // Use new default if labelScale was absent
                }
            } else {
                 // Set to a generous default if no settings object exists
                 settings.iconScale = 1.5;
                 settings.junctionScale = 1.0; // NEW
                 settings.lineScale = 1.5;
                 settings.labelScale = 3.0; 
                 settings.arrowFreqFactor = 1.0; // NEW
            }
            
            // --- CRITICAL FIX: Transfer loaded settings to UI inputs ---
            lineScaleInput.value = settings.lineScale;
            iconScaleInput.value = settings.iconScale;
            junctionScaleInput.value = settings.junctionScale;
            labelScaleInput.value = settings.labelScale;
            arrowFreqInput.value = settings.arrowFreqFactor;
            
            // Update display spans immediately
            updateLineScaleUI(); 
            updateIconScaleUI();
            updateJunctionScaleUI(); 
            updateLabelScaleUI();
            updateArrowFreqUI();


            if(imgDataUrl){ 
                bg.src=imgDataUrl; 
                bg.onload=()=>{
                    imgReady=true; 
                    document.body.classList.remove('white-bg'); // REMOVE white-bg when image loads
                    resetView(); 
                    applyState(o); // Apply job details
                    applyUIState(o); // Apply slider positions and toggles
                    unlock();
                }; 
                bg.onerror=()=>{
                    imgReady=true; 
                    document.body.classList.remove('white-bg'); // REMOVE white-bg on error just in case
                    resetView(); 
                    applyState(o); // Apply job details
                    applyUIState(o); // Apply slider positions and toggles
                    unlock();
                    showAlert("Map image failed to load");
                };
            } 
            else { 
                // CRITICAL FIX: Ensure image background dimensions are set even if image data is missing
                bg.width = o.bg_width || 1000;
                bg.height = o.bg_height || 1000;
                imgReady = true;
                document.body.classList.add('white-bg'); // ADD white-bg for loaded map with no background image
                resetView(); 
                applyState(o); // Apply job details
                applyUIState(o); // Apply slider positions and toggles
                unlock();
            } 
        }catch(e){showAlert('Error loading map'); console.error('Error loading map:', e);} 
    };
    r.readAsText(f);
};

function applyState(o){
    document.getElementById('customer').value=o.job?.name||'';
    document.getElementById('address').value=o.job?.address||'';
    document.getElementById('jobNotes').value=o.job?.notes||''; 
    
    const timerInputs = document.getElementById('timerInputs');
    const btnCC = document.getElementById('btnCustomerControlled');

    // Timer handling including 'CC'
    if(o.job?.timer?.isCustomerControlled) {
        timerInputs.style.display = 'none';
        btnCC.classList.add('toggled');
        document.getElementById('on1').value = 'CC';
    } else {
        timerInputs.style.display = 'block';
        btnCC.classList.remove('toggled');
        document.getElementById('on1').value = o.job?.timer?.on1 || '';
        document.getElementById('off1').value = o.job?.timer?.off1 || '';
        document.getElementById('on2').value = o.job?.timer?.on2 || '';
        document.getElementById('off2').value = o.job?.timer?.off2 || '';
    }
    
    // Only refresh table/power here. UI state is handled by applyUIState(o).
    markPowerDirty(); 
    refreshTable();
    // Request render is called in applyUIState
}

// FIX: Set Standard Times Logic
document.getElementById('btnStd').onclick=()=>{ 
    document.getElementById('on1').value='06:00'; 
    document.getElementById('off1').value='08:00'; 
    document.getElementById('on2').value='17:00'; 
    document.getElementById('off2').value='00:00'; 
    // If CC was active, deactivate it upon setting times
    document.getElementById('btnCustomerControlled').classList.remove('toggled');
    document.getElementById('timerInputs').style.display = 'block';
};

// Timer button for "Customer Controlled" toggle
document.getElementById('btnCustomerControlled').onclick = () => {
    const timerInputs = document.getElementById('timerInputs');
    const btnCC = document.getElementById('btnCustomerControlled');
    const isActive = btnCC.classList.toggle('toggled');

    if (isActive) {
        // Activate CC mode
        timerInputs.style.display = 'none';
        document.getElementById('on1').value = 'CC';
        document.getElementById('off1').value = 'CC';
        document.getElementById('on2').value = 'CC';
        document.getElementById('off2').value = 'CC';
    } else {
        // Deactivate CC mode
        document.getElementById('on1').value = '';
        document.getElementById('off1').value = '';
        document.getElementById('on2').value = '';
        document.getElementById('off2').value = '';
        timerInputs.style.display = 'block';
    }
};


// UPDATED LISTENERS: Reset target value to allow re-uploading same file
document.getElementById('gPickImg').onclick=()=>document.getElementById('gImg').click();
document.getElementById('gPickMap').onclick=()=>document.getElementById('gMap').click();
document.getElementById('gImg').onchange=e=>{ handleImg(e.target.files[0]); e.target.value=''; };
document.getElementById('gMap').onchange=e=>{ handleMap(e.target.files[0]); e.target.value=''; };


// --- SAVE/EXPORT LOGIC (ONLY LOCAL SAVE REMAINS) ---

// Toggle visibility of dropdown content - Right-click/Context menu handler
cv.addEventListener('contextmenu', (e) => {
    e.preventDefault(); 
    const dropdown = document.getElementById('saveDropdown');
    dropdown.style.display = 'block';
    
    // Position dropdown near mouse/touch point
    dropdown.style.left = e.clientX + 'px';
    dropdown.style.top = e.clientY + 'px';
    dropdown.style.right = 'auto'; // Prevent overlap on the right
});

// Close dropdown if clicking anywhere else
document.addEventListener('click', (e) => {
    const dropdown = document.getElementById('saveDropdown');
    const btnSaveAll = document.getElementById('btnSaveAll');
    if (dropdown.style.display === 'block' && !dropdown.contains(e.target) && !btnSaveAll.contains(e.target)) {
        dropdown.style.display = 'none';
    }
    // Also hide the move popup if clicking anywhere outside the canvas/popups
    const movePop = document.getElementById('movePop');
    if (movePop.style.display === 'flex' && !movePop.contains(e.target) && e.target !== cv) {
        movePop.style.display = 'none';
        // When clicking outside, reset mode to select
        if (mode === 'move' || mode === 'move-label') {
            mode = 'select';
            updateModeTag();
        }
    }
});


// MAIN SAVE BUTTON LOGIC (Save All - Left Click on Header Button)
document.getElementById('btnSaveAll').onclick = (e) => {
    // If this is a right click (context menu), let the contextmenu listener handle it (and display the dropdown)
    if (e.button === 2) return; 

    const dropdown = document.getElementById('saveDropdown');
    dropdown.style.display = 'none'; // Ensure dropdown is closed before validation

    // NOTE: Since the validation modal was removed, we just proceed with the save.
    // If you want validation back, re-add the HTML for #modalSaveValidate and the logic here.
    performDualSave();
};

// Handle Dropdown button clicks
document.getElementById('btnSaveMapOnly').onclick = () => { performSaveMapOnly(); document.getElementById('saveDropdown').style.display = 'none'; };
document.getElementById('btnSaveImageOnly').onclick = () => { performSavePdf(); document.getElementById('saveDropdown').style.display = 'none'; };
// Drive Save is handled by handleSaveDriveClick
btnSaveDriveOnly.onclick = handleSaveDriveClick;


// Global function to construct payload
function buildPayload() {
    const isCC = document.getElementById('btnCustomerControlled').classList.contains('toggled');
    const timerOn1 = document.getElementById('on1').value;
    const timerOff1 = document.getElementById('off1').value;
    const timerOn2 = document.getElementById('on2').value;
    const timerOff2 = document.getElementById('off2').value;

    return {
        version:17, // Updated version to 17 (due to Pillar Mode and Arrow Frequency)
        image:imgDataUrl, 
        data, 
        job:{ 
            name:document.getElementById('customer').value, 
            address:document.getElementById('address').value, 
            notes:document.getElementById('jobNotes').value,
            timer: {
                on1: isCC ? 'CC' : timerOn1,
                off1: isCC ? 'CC' : timerOff1,
                on2: isCC ? 'CC' : timerOn2,
                off2: isCC ? 'CC' : timerOff2,
                isCustomerControlled: isCC
            }
        },
        settings: settings, // Save settings data (including all scale values and new arrowFreqFactor)
        uiState: { // Save UI state (toggles/checkboxes)
            isNightMode: isNightMode,
            isSnapOn: chkSnap.checked,
            isSwagOn: chkSwag.checked,
            isPillarOn: chkPillar.checked, // NEW: Save Pillar state
            isAutoCalcOn: document.getElementById('chkAutoCalc').checked
        }
    };
}

function getFilenameBase() {
    const year = new Date().getFullYear();
    const nm = (document.getElementById('customer').value || 'Untitled').trim();
    return `${nm}_${year}_Map`.replace(/\s/g, '_');
}

// HELPER: Save using showSaveFilePicker if supported, else fallback to anchor tag
async function saveFileWithPicker(blob, filename, description, mimeType, extension) {
    if (window.showSaveFilePicker) {
        try {
            const handle = await window.showSaveFilePicker({
                suggestedName: filename,
                types: [{
                    description: description,
                    accept: { [mimeType]: [extension] },
                }],
            });
            const writable = await handle.createWritable();
            await writable.write(blob);
            await writable.close();
            return true;
        } catch (err) {
            // If user cancels (AbortError), do nothing. Log others.
            if (err.name !== 'AbortError') {
                console.warn('File picker failed, falling back to download link:', err);
                // Fallthrough to anchor click below
            } else {
                return false; // User cancelled
            }
        }
    }
    
    // Fallback behavior
    const url = URL.createObjectURL(blob); 
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    a.click();
    setTimeout(() => URL.revokeObjectURL(url), 1000);
    return true;
}

async function performSaveMapOnly() {
    const filenameMap = `${getFilenameBase()}.skmap`;
    const payload = buildPayload();
    const blob = new Blob([JSON.stringify(payload)], {type:'application/json'});
    
    await saveFileWithPicker(blob, filenameMap, 'Skedaddle Map File', 'application/json', '.skmap');
}

async function performSavePdf() {
    const capture = captureCanvasData();
    if(!capture) {
        showAlert("Error generating image data.");
        return;
    }

    const { url: pngData, width, height } = capture;
    
    // Create PDF with exact image dimensions
    const { jsPDF } = window.jspdf;
    const pdf = new jsPDF({
        orientation: width > height ? 'l' : 'p',
        unit: 'px',
        format: [width, height]
    });
    
    pdf.addImage(pngData, 'PNG', 0, 0, width, height);
    
    const filenamePdf = `${getFilenameBase()}.pdf`;
    const pdfData = pdf.output('blob'); // Get PDF as blob

    await saveFileWithPicker(pdfData, filenamePdf, 'PDF Document', 'application/pdf', '.pdf');
}

async function performDualSave() {
    // 1. Perform local PDF save
    await performSavePdf();
    
    // 2. Perform local map save
    await performSaveMapOnly();
    
    // DRIVE SAVE REMOVED HERE
}


// Helper function to capture the final exported PNG data (as implemented in btnExport)
function captureCanvasData() {
    if(!imgReady) return null;
    
    // 1. Calculate Bounding Box of all drawn items (in World Coordinates)
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    
    const checkPt = (p) => {
        if(p.x < minX) minX = p.x;
        if(p.y < minY) minY = p.y;
        if(p.x > maxX) maxX = p.x;
        if(p.y > maxY) maxY = p.y;
    };

    let hasItems = false;
    Object.keys(data).forEach(L => {
        data[L].forEach(item => {
             hasItems = true;
             if(item.points) item.points.forEach(checkPt);
             if(item.pt) {
                 checkPt(item.pt);
                 // Approximate size for single items to ensure full visibility
                 checkPt({x:item.pt.x+50, y:item.pt.y+50});
                 checkPt({x:item.pt.x-50, y:item.pt.y-50});
             }
        });
    });

    if(!hasItems) {
        minX = 0; minY = 0; maxX = bg.width; maxY = bg.height;
    } else {
        const pad = 50;
        minX = Math.max(0, minX - pad);
        minY = Math.max(0, minY - pad);
        maxX = Math.min(bg.width, maxX + pad);
        maxY = Math.min(bg.height, maxY + pad);
    }
    
    const cropW = maxX - minX;
    const cropH = maxY - minY;

    // --- 2. Create and Setup Export Canvas ---
    const DPI = 2; 
    const MAP_WIDTH_PX = 1000;
    const MAP_H_PX = Math.round((MAP_WIDTH_PX / cropW) * cropH);

    const HEADER_H = 100;
    const FOOTER_ROW_H = 20;
    const FOOTER_TITLE_H = 30;
    const ITEM_COUNT = document.getElementById('lenRows').children.length;
    const FOOTER_H = ITEM_COUNT > 0 ? (FOOTER_TITLE_H + ITEM_COUNT * FOOTER_ROW_H + 20) : 0;
    
    const OUT_W = MAP_WIDTH_PX;
    const OUT_H = HEADER_H + MAP_H_PX + FOOTER_H;

    const out = document.createElement('canvas');
    out.width = OUT_W * DPI;
    out.height = OUT_H * DPI;
    const o = out.getContext('2d');
    o.scale(DPI, DPI); // Scale drawing context for retina output

    const oldScale = scale;
    const oldPanX = panX;
    const oldPanY = panY;
    
    // --- IMPORTANT: Capture current settings BEFORE manipulation ---
    const originalSettings = settings; // Keep reference to original settings object
    
    // Create temporary settings object for drawing
    const tempSettings = { ...originalSettings };
    settings = tempSettings; // Temporarily use local settings for accurate export draw
    
    // Temporarily disable Night Mode for export to ensure original colors/no glow is captured
    const originalNightMode = isNightMode;
    isNightMode = false;
    
    try {
        const renderScale = MAP_WIDTH_PX / cropW; 
        const renderPanX = -minX * renderScale;
        const renderPanY = HEADER_H - (minY * renderScale); 

        // Temporarily set globals for EXPORT rendering
        scale = renderScale;
        panX = renderPanX;
        panY = renderPanY;
        
        // 3. Draw Header
        o.fillStyle = '#0a0f18';
        o.fillRect(0, 0, OUT_W, OUT_H);

        const logoSize = 80; 
        o.drawImage(logo, (OUT_W - logoSize) / 2, 10, logoSize, logoSize);
        
        o.fillStyle = '#d6eef6'; o.font = 'bold 13px system-ui'; o.textAlign = 'left'; o.textBaseline = 'top';
        o.fillText(`CUSTOMER: ${document.getElementById('customer').value || 'N/A'}`, 12, 12 + 10);
        o.fillText(`ADDRESS: ${document.getElementById('address').value || 'N/A'}`, 12, 12 + 25);
        
        const jNotes = document.getElementById('jobNotes').value.replace(/\n/g, ' '); 
        if(jNotes) {
            o.fillStyle = '#a0b0c0'; o.font = 'italic 11px system-ui';
            const dispNotes = jNotes.length > 110 ? jNotes.substring(0, 110) + '...' : jNotes;
            o.fillText(`NOTES: ${dispNotes}`, 12, 12 + 45);
        }

        o.fillStyle = '#d6eef6'; o.font = 'bold 13px system-ui'; o.textAlign = 'right';
        
        const timerVal = document.getElementById('on1').value.trim();
        let timerText;
        if (document.getElementById('btnCustomerControlled').classList.contains('toggled') || timerVal === 'CC') {
            timerText = 'Timer: Customer Controlled';
        } else {
            timerText = `TIMER 1: ${document.getElementById('on1').value || '--:--'} - ${document.getElementById('off1').value || '--:--'} / TIMER 2: ${document.getElementById('on2').value || '--:--'} - ${document.getElementById('off2').value || '--:--'}`;
        }
        o.fillText(timerText, OUT_W - 12, 12 + 10);
        o.textBaseline = 'alphabetic';

        // 4. Draw Map Body (Original image, no night mode filter)
        // If there is no image data but imgReady is true, we draw white background for export.
        if (imgReady && !imgDataUrl) {
            o.fillStyle = '#ffffff';
            o.fillRect(0, HEADER_H, OUT_W, MAP_H_PX);
        } else {
             o.drawImage(bg, 
                minX, minY, cropW, cropH, 
                0, HEADER_H, OUT_W, MAP_H_PX); 
        }

        const originalCtx = ctx;
        ctx = o; 
        
        // --- DRAWING LINES ---
        data.cords.forEach(it => { drawCord(it, getColorCode(it.col) || colorOf('cords'), 'cords'); });
        ['shrub','windows','ridges','fascia','peaks','groundstakes','garland'].forEach(L=>{ 
            data[L].forEach(it=>{ 
                drawContinuousLine(it, getColorCode(it.col) || colorOf(L), L); 
            }); 
        });
        
        // --- DRAWING POWER ARROWS (Before Icons, After Lines) ---
        const pg = analyzePower();
        if(pg){
             pg.edges.forEach(e => {
                 if(['garland', 'groundstakes'].includes(e.type)) return;
                 const uNode = pg.nodes[e.u]; const vNode = pg.nodes[e.v];
                 if(uNode.dist !== Infinity && vNode.dist !== Infinity){
                     const uPos = toScr({x:uNode.x, y:uNode.y}); const vPos = toScr({x:vNode.x, y:vNode.y});
                     let from, to, isReversed;
                     if(uNode.dist < vNode.dist) { from = uPos; to = vPos; isReversed = false; } 
                     else if(vNode.dist < uNode.dist) { from = vPos; to = uPos; isReversed = true; }
                     else return; 

                     const cp = e.cps ? toScr(e.cps) : null;
                     const dist = Math.hypot(vPos.x - uPos.x, vPos.y - uPos.y);
                     let count = Math.floor(dist/150 * settings.arrowFreqFactor); 
                     if (e.type !== 'cords' && count === 0 && settings.arrowFreqFactor > 0.5) count = 1; 

                     if(cp) {
                         for(let k=1; k<=count; k++){
                             let t = k / (count+1);
                             const invT = 1 - t;
                             const px = invT*invT*uPos.x + 2*invT*t*cp.x + t*t*vPos.x;
                             const py = invT*invT*uPos.y + 2*invT*t*cp.y + t*t*vPos.y;
                             const tx = 2*invT*(cp.x - uPos.x) + 2*t*(vPos.x - cp.x);
                             const ty = 2*invT*(cp.y - uPos.y) + 2*t*(vPos.y - cp.y);
                             let dir = {x: tx, y: ty};
                             if(isReversed) { dir.x = -dir.x; dir.y = -dir.y; }
                             drawArrow({x: px, y: py}, dir, '#ff3b3b');
                         }
                     } else {
                         const dx = to.x - from.x, dy = to.y - from.y; 
                         for(let k=1; k<=count; k++){
                             const t = k / (count+1);
                             drawArrow({x:from.x + dx*t, y:from.y + dy*t}, {x:dx, y:dy}, '#ff3b3b');
                         }
                     }
                 }
             });
             // Draw single arrows
             pg.singleArrowEdges.forEach(a => {
                const edge = a.edge;
                const uPos = toScr(edge.line.points[edge.index]); 
                const vPos = toScr(edge.line.points[edge.index+1]);
                const segDist = segmentLength(uPos, vPos, edge.cps ? toScr(edge.cps) : null);
                const ptObj = getPointOnSegmentAtDist(uPos, vPos, segDist, a.distInSegment * scale, edge.cps ? toScr(edge.cps) : null);
                let dir = {x: ptObj.dx, y: ptObj.dy};
                if (a.isReversed) { dir.x = -dir.x; dir.y = -dir.y; }
                drawArrow({x: ptObj.x, y: ptObj.y}, dir, '#ff3b3b');
             });
             pg.deadTips.forEach(nodeIdx => {
                 const n = pg.nodes[nodeIdx]; const neighborIdx = n.adj[0]; 
                 if(neighborIdx !== undefined){ drawDeadEnd(n, pg.nodes[neighborIdx], '#fffdf0'); }
             });
        }
        
        // --- DRAWING ICONS ---
        data.wreath.forEach(w=>{
            const s=toScr(w.pt); 
            const r=(w.size==='42"'?12.5:8.75)*scale * settings.iconScale; 
            
            ctx.beginPath(); ctx.arc(s.x,s.y,r,0,Math.PI*2);
            ctx.fillStyle = colorOf('wreath'); 
            ctx.fill();
            ctx.strokeStyle='black'; ctx.lineWidth=6 * settings.iconScale * scale; ctx.stroke(); 
            ctx.strokeStyle=colorOf('wreath'); ctx.lineWidth=3 * settings.iconScale * scale; ctx.stroke(); 

            if(w.bow === 'top' || w.bow === 'bottom'){
                const by = w.bow==='top' ? s.y - r : s.y + r;
                drawBow(s.x, by, scale, settings.iconScale);
            }
        });
        
        data.bow.forEach(b=>{ const s=toScr(b.pt); drawBow(s.x, s.y, scale, settings.iconScale); }); 

        data.tree.forEach(tr => {
            const p = toScr(tr.pt);
            drawTreeIcon(ctx, p, tr.kind, tr.size, scale, settings.iconScale);
        });
        
        data.powersource.forEach(ps=>{
            const s=toScr(ps.pt);
            const size = 8 * settings.junctionScale * scale;
            const strokeWidth = 3 * settings.junctionScale * scale;
            ctx.fillStyle='#ff3b3b'; ctx.fillRect(s.x-size/2, s.y-size/2, size, size);
            ctx.strokeStyle='black'; ctx.lineWidth=strokeWidth; ctx.strokeRect(s.x-size/2, s.y-size/2, size, size);
            ctx.strokeStyle='white'; ctx.lineWidth=strokeWidth/2; ctx.strokeRect(s.x-size/2, s.y-size/2, size, size);
        });

        if(data.threeway){
            data.threeway.forEach(tw=>{
                const s = toScr(tw.pt);
                const sz = 6 * scale * settings.junctionScale;
                const strokeWidth = 3 * settings.junctionScale * scale;
                ctx.beginPath(); ctx.moveTo(s.x, s.y - sz); ctx.lineTo(s.x + sz, s.y + sz); ctx.lineTo(s.x - sz, s.y + sz); ctx.closePath();
                ctx.fillStyle = '#ffd86a'; ctx.fill();
                ctx.strokeStyle = 'black'; ctx.lineWidth = strokeWidth; ctx.stroke();
                ctx.strokeStyle = 'white'; ctx.lineWidth = strokeWidth/2; ctx.stroke();
            });
        }
        
        // --- DRAWING LABELS (Always last for z-index on export) ---
        drawLabels(ctx, true);


        ctx = originalCtx;

        // 5. Draw Footer (Line Information)
        if (ITEM_COUNT > 0) {
            const footY = HEADER_H + MAP_H_PX;
            o.fillStyle = '#111726';
            o.fillRect(0, footY, OUT_W, FOOTER_H);
            
            o.fillStyle = '#9fc3ff'; o.font = 'bold 16px system-ui'; o.textAlign = 'left';
            o.fillText('Line Information', 12, footY + 20);

            o.font = '13px system-ui'; o.fillStyle = '#e7ecf3';
            
            // FIX 2: Collect rows and sort them by label (ID) using natural sorting
            const columnData = collectRows(); 
            columnData.sort((a,b)=>a.label.localeCompare(b.label, undefined, {numeric:true}));
            
            let y = footY + FOOTER_TITLE_H;
            
            // UPDATED COLUMN DEFINITION
            const cols = [
                { label: 'Type', width: 0.15 },
                { label: 'ID', width: 0.1 },
                { label: 'Ft', width: 0.08 }, // Adjusted width
                { label: 'Bulbs', width: 0.1 }, // Adjusted width
                { label: 'Clip', width: 0.1 },
                { label: 'Colour', width: 0.15 },
                { label: 'Notes', width: 0.32 } // Adjusted width
            ];

            let xOffset = 0;
            o.font = 'bold 13px system-ui'; o.fillStyle = '#cfe2ff';
            cols.forEach(col => {
                o.fillText(col.label, 12 + xOffset, y + 5);
                xOffset += OUT_W * col.width;
            });
            o.font = '13px system-ui'; o.fillStyle = '#e7ecf3';
            y += FOOTER_ROW_H;
            
            columnData.forEach(r => {
                xOffset = 0;
                o.fillText(pretty[r.L] || r.L, 12 + xOffset, y + 5); xOffset += OUT_W * cols[0].width;
                o.fillText(r.label, 12 + xOffset, y + 5); xOffset += OUT_W * cols[1].width;
                o.fillText(r.ft || '-', 12 + xOffset, y + 5); xOffset += OUT_W * cols[2].width; // Ft
                o.fillText(r.bulbs || '-', 12 + xOffset, y + 5); xOffset += OUT_W * cols[3].width; // Bulbs
                
                let clipSuffix = r.clip || '-';
                if(r.fra) clipSuffix += ' (FRA)';
                if(r.gguard) clipSuffix += ' (GG)';
                o.fillText(clipSuffix.trim(), 12 + xOffset, y + 5); xOffset += OUT_W * cols[4].width; // Clip/FRA/GG
                
                // Color
                let displayCol = r.col || '-';
                // FIX 1: Use normalized/processed color logic
                const normalizedRCol = r.col ? r.col.toLowerCase().replace(/\s/g, '/').replace(/,/g, '/').replace(/ /g, '') : '';

                if (r.L === 'garland' || r.L === 'wreath' || (r.L === 'shrub' && !r.col)) {
                    displayCol = 'Green';
                } else if (r.L === 'cords') {
                    displayCol = 'Black';
                } else {
                     if (normalizedRCol.includes('multi')) {
                         displayCol = 'Multi';
                     } else if (normalizedRCol.includes('/')) {
                          displayCol = r.col; // Display the saved multi-word string
                     } else if (r.col === '') {
                          displayCol = 'Warm White'; // Default C9 color
                     } else {
                          displayCol = r.col; // Display single color input value
                     }
                }
                o.fillText(displayCol, 12 + xOffset, y + 5); xOffset += OUT_W * cols[5].width;
                
                o.fillText(r.notes || '-', 12 + xOffset, y + 5); xOffset += OUT_W * cols[6].width;
                y += FOOTER_ROW_H;
            });
        }

    } catch (error) {
        console.error("Export Drawing Error:", error);
        return null;
    } finally {
        // --- Restore user's original settings (critical step) ---
        scale = oldScale;
        panX = oldPanX;
        panY = oldPanY;
        settings = originalSettings; // Restore original global settings object
        isNightMode = originalNightMode;

        // Ensure UI is refreshed regardless of success or failure in the try block
        updateLineScaleUI();
        updateIconScaleUI();
        updateJunctionScaleUI(); 
        updateLabelScaleUI();
        updateArrowFreqUI();
    }
    
    // Return Data URL for PDF conversion in next step
    return { url: out.toDataURL('image/png'), width: OUT_W * DPI, height: OUT_H * DPI };
}

function collectRows() {
    const rows = [];
    Object.keys(data).forEach(L => {
        data[L].forEach(it => {
            if (it.label && L !== 'label') rows.push({ // Exclude 'simple' labels from the table
                L: L,
                label: it.label,
                ft: it.ft || '',
                bulbs: it.bulbs || '',
                col: it.col || '',
                clip: it.clip || '',
                notes: it.notes || '', 
                fra: it.fra || false, // Include FRA state
                gguard: it.gguard || false // Include Gutter Guard state
            });
        });
    });
    return rows;
}

// Custom Icon Slider Logic
// Removed UI elements for icon scale and line thickness
// The logic for settings remains in the settings object for saving/loading

// --- Initial Setup ---
function initializeUI() {
    // !!! CRITICAL FIX: Update Bulk Color input logic to exclude fixed colors
    document.getElementById('inputAllCol').oninput = (e) => {
        const v = e.target.value;
        const cleanedV = v.replace(/\s/g, '/').replace(/,/g, '/');
        const lowerV = cleanedV.toLowerCase();
        
        let valueToSave = cleanedV;
        if (lowerV.includes('multi') || lowerV === 'm') {
            valueToSave = getColorCode('multi'); // "Red/Blue/Green/Orange/Yellow"
        }

        Object.keys(data).forEach(k => { 
            data[k].forEach(it => { 
                // Only set bulk color for items that are NOT Garland, Shrub, or Cords, Wreath
                if(it.label && k !== 'garland' && k !== 'shrub' && k !== 'cords' && k !== 'wreath' && k !== 'label') { 
                    it.col = valueToSave; 
                }
            }); 
        });
        
        // Update the table's color input fields, excluding fixed-color lines
        const rows = document.getElementById('lenRows').children;
        for(let tr of rows) { 
            const lineTypeCell = tr.querySelector('td:first-child');
            const lineType = lineTypeCell.textContent.toLowerCase();
            
            // Skip updating the input field for fixed colors
            if (lineType !== 'garland' && lineType !== 'cord' && lineType !== 'shrub' && lineType !== 'wreath') { 
                const inputCol = tr.querySelector('input[placeholder="Col"]'); 
                if(inputCol) {
                    // Determine if input should display 'Multi'
                    if (lowerV.includes('multi') || lowerV === 'm' || lowerV.includes('multiple')) {
                        inputCol.value = 'Multi';
                    } else if (cleanedV.includes('/')) {
                        inputCol.value = cleanedV; 
                    } else {
                        inputCol.value = v; 
                    }
                }
            }
        }
        
        requestRender(); 
    };
    
    // Initialize scale displays
    const MIN_SCALE = 0.5;
    if (settings.iconScale === undefined || settings.lineScale === undefined || settings.labelScale === undefined || settings.junctionScale === undefined || settings.arrowFreqFactor === undefined) {
         settings.iconScale = 1.5;
         settings.junctionScale = 1.0; 
         settings.lineScale = 1.5;
         settings.labelScale = 3.0; 
         settings.arrowFreqFactor = 1.0;
    }
    
    // Ensure UI fields reflect initial/loaded state
    lineScaleInput.value = settings.lineScale;
    iconScaleInput.value = settings.iconScale;
    junctionScaleInput.value = settings.junctionScale; 
    labelScaleInput.value = settings.labelScale;
    arrowFreqInput.value = settings.arrowFreqFactor;

    updateLineScaleUI();
    updateIconScaleUI();
    updateJunctionScaleUI(); 
    updateLabelScaleUI();
    updateArrowFreqUI();
}

document.addEventListener('DOMContentLoaded', () => {
    initializeUI();
    initializeAndSizeContext();
    // Default back button trap setup.
    document.getElementById('btnStay').onclick = () => { document.getElementById('modalBack').style.display = 'none'; history.pushState(null, null, location.href); };
    document.getElementById('btnLeave').onclick = () => { document.getElementById('modalBack').style.display = 'none'; history.back(); };
    
    // Add relabeling listener
    document.getElementById('btnRelabelIDs').onclick = relabelIds;
    
    // --- SAFE BUTTON INITIALIZATION ---
    // Ensure splash buttons work regardless of GAPI state
    const gPickImg = document.getElementById('gPickImg');
    const gPickBlank = document.getElementById('gPickBlank');
    const gPickMap = document.getElementById('gPickMap');
    const gImg = document.getElementById('gImg');
    const gMap = document.getElementById('gMap');
    const closeGateBtn = document.getElementById('closeGateBtn'); // Added closeGateBtn

    if (gPickImg) gPickImg.onclick = () => { if (gImg) gImg.click(); };
    if (gPickBlank) gPickBlank.onclick = () => { startBlankMap(); }; // <-- FIX: Call startBlankMap to initialize state
    if (gPickMap) gPickMap.onclick = () => { if (gMap) gMap.click(); };
    if (closeGateBtn) closeGateBtn.onclick = () => { unlock(); }; // Attach listener in JS
    
    if (gImg) gImg.onchange = e => { handleImg(e.target.files[0]); e.target.value=''; };
    if (gMap) gMap.onchange = e => { handleMap(e.target.files[0]); e.target.value=''; };
});
})();
</script>
</body>
</html>
