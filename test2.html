<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Skedaddle Mobile Map Maker</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, interactive-widget=resizes-content"/>
<meta name="theme-color" content="#0f172a">

<!-- Fonts -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

<!-- Libraries -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="https://unpkg.com/lucide@latest"></script>
<script src="https://accounts.google.com/gsi/client" async defer></script>
<script src="https://apis.google.com/js/api.js"></script>
<script src="https://www.google.com/jsapi?autoload={'modules':[{'name':'picker','version':'1.0','callback':'pickerLoaded'}]}"></script>

<style>
:root {
    --bg: #0f172a;
    --panel: #1e293b;
    --panel-hover: #334155;
    --text: #f1f5f9;
    --text-muted: #94a3b8;
    --accent: #3b82f6;
    --accent-hover: #2563eb;
    --border: #334155;
    --border-highlight: #475569;
    --danger: #ef4444;
    --success: #22c55e;
    --warning: #eab308;
    --font-main: 'Inter', system-ui, -apple-system, sans-serif;
    --festive-gold: #fbbf24;
    --festive-red: #ef4444;
}

* { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
html, body { height: 100%; height: 100dvh; overflow: hidden; background: var(--bg); color: var(--text); font-family: var(--font-main); margin: 0; }

body.blurred #app { filter: blur(12px); pointer-events: none; transition: filter 0.3s ease; }

#gate {
    position: fixed; inset: 0; display: flex; align-items: center; justify-content: center; z-index: 999;
    background: radial-gradient(circle at center, rgba(15, 23, 42, 0.9), #0f172a);
    backdrop-filter: blur(10px);
    transition: opacity 0.3s, visibility 0.3s;
    padding: 16px;
}
#gate.hide { opacity: 0; visibility: hidden; pointer-events: none; }

.gcard {
    background: rgba(30, 41, 59, 0.8);
    border: 1px solid var(--border-highlight);
    border-radius: 24px;
    padding: 40px;
    width: min(480px, 100%);
    text-align: center;
    box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
    position: relative;
    overflow: hidden;
}
.gcard::before {
    content: ''; position: absolute; top: 0; left: 0; right: 0; height: 4px;
    background: linear-gradient(90deg, var(--festive-red), var(--festive-gold), var(--success));
}

.gcard h2 {
    margin: 16px 0 8px; font-size: 28px; font-weight: 700; letter-spacing: -0.5px;
    background: linear-gradient(135deg, #fff 0%, #cbd5e1 100%);
    -webkit-background-clip: text; -webkit-text-fill-color: transparent;
}
.gcard p { margin: 0 0 32px; color: var(--text-muted); font-size: 15px; line-height: 1.5; }

.close-btn {
    position: absolute; top: 16px; right: 16px; background: transparent; border: none;
    color: var(--text-muted); cursor: pointer; padding: 8px; border-radius: 50%;
    transition: all 0.2s; display: none;
}
.close-btn:hover { background: var(--panel-hover); color: var(--text); }

.grow { display: flex; flex-direction: column; gap: 12px; }

.gbtn {
    background: var(--panel); border: 1px solid var(--border); color: var(--text);
    padding: 16px; border-radius: 12px; cursor: pointer; font-size: 15px; font-weight: 600;
    display: flex; align-items: center; justify-content: center; gap: 12px;
    transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
}
.gbtn:hover { background: var(--panel-hover); border-color: var(--border-highlight); transform: translateY(-1px); }
.gbtn:active { transform: translateY(0); }
.gbtn:disabled { opacity: 0.5; cursor: not-allowed; pointer-events: none; }

.grow input[type=file] { position: absolute; width: 0; height: 0; opacity: 0; }

#app { display: flex; flex-direction: column; height: 100%; background: var(--bg); }

header {
    flex: 0 0 64px; display: flex; align-items: center; gap: 8px; padding: 0 16px;
    background: var(--panel); border-bottom: 1px solid var(--border);
    overflow-x: auto; white-space: nowrap; -webkit-overflow-scrolling: touch; scrollbar-width: none;
    z-index: 30; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
}
header::-webkit-scrollbar { display: none; }

#logoBtn { background: none; border: none; padding: 0; cursor: pointer; margin-right: 12px; }
#logo { width: 40px; height: 40px; border-radius: 10px; border: 1px solid var(--border); }
h1 { margin: 0 16px 0 0; font-size: 18px; font-weight: 600; color: var(--text); display: inline-block; vertical-align: middle; }

.btn {
    background: transparent; border: 1px solid transparent; color: var(--text-muted);
    border-radius: 8px; height: 40px; padding: 0 12px; cursor: pointer;
    display: inline-flex; align-items: center; justify-content: center; gap: 8px;
    font-size: 13px; font-weight: 500; transition: all 0.2s; white-space: nowrap;
}
.btn:hover:not(:disabled) { background: var(--panel-hover); color: var(--text); }
.btn:disabled { opacity: 0.4; cursor: not-allowed; }
.btn.toggled { background: rgba(59, 130, 246, 0.15); border-color: rgba(59, 130, 246, 0.3); color: var(--accent); }

#btnComplete.selectable { 
    color: var(--success); 
    background: rgba(34, 197, 94, 0.1); 
    border-color: rgba(34, 197, 94, 0.3); 
    opacity: 1;
}

#selectionQuickEdit {
    display: none;
    align-items: center;
    gap: 8px;
    background: var(--bg);
    padding: 4px 12px;
    border-radius: 12px;
    border: 1px solid var(--border-highlight);
    margin: 0 8px;
}

.pill {
    background: rgba(59, 130, 246, 0.1); border: 1px solid rgba(59, 130, 246, 0.2);
    color: var(--accent); border-radius: 20px; padding: 6px 16px; font-size: 12px; font-weight: 600;
    cursor: pointer; transition: all 0.2s; display: inline-flex; align-items: center; justify-content: center;
    margin-right: 8px;
}
.pill:hover { background: rgba(59, 130, 246, 0.2); }

.wrap { flex: 1; display: flex; position: relative; overflow: hidden; }
main { flex: 1; display: flex; flex-direction: column; position: relative; background: #050505; }

.canvasWrap {
    flex: 1; display: flex; align-items: center; justify-content: center; overflow: hidden; position: relative;
    background: #0f172a;
    background-image: radial-gradient(#1e293b 1px, transparent 1px);
    background-size: 20px 20px;
}
canvas {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    background: transparent; touch-action: none; display: block;
    box-shadow: 0 0 0 1px var(--border);
}
body.white-bg .canvasWrap { background: #ffffff; background-image: none; }

aside {
    width: 320px; background: var(--panel); border-right: 1px solid var(--border);
    display: flex; flex-direction: column; overflow-y: auto; padding: 16px;
    transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1); z-index: 20;
}
.overlay {
    position: fixed; inset: 0; background: rgba(0, 0, 0, 0.5); backdrop-filter: blur(2px);
    z-index: 19; opacity: 0; pointer-events: none; transition: opacity 0.3s;
}
.overlay.show { opacity: 1; pointer-events: auto; }

.group { background: var(--bg); border: 1px solid var(--border); border-radius: 12px; padding: 16px; margin-bottom: 16px; }
.group h3 {
    margin: 0 0 12px; font-size: 11px; font-weight: 700; color: var(--text-muted);
    text-transform: uppercase; letter-spacing: 0.05em;
}

.input {
    width: 100%; background: var(--panel); border: 1px solid var(--border); color: var(--text);
    border-radius: 8px; padding: 10px 12px; font-size: 14px; font-family: inherit;
    transition: border-color 0.2s;
}
.input:focus { outline: none; border-color: var(--accent); }
textarea.input { resize: vertical; min-height: 80px; }
.row2 { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
.lbl-row { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 4px; font-size: 11px; color: var(--text-muted); padding-left: 2px; }

.acc { border: 1px solid var(--border); border-radius: 8px; background: var(--panel); margin-bottom: 8px; overflow: hidden; }
.accHead {
    display: flex; align-items: center; justify-content: space-between; cursor: pointer;
    padding: 12px 14px; font-size: 14px; font-weight: 500; color: var(--text);
    transition: background 0.2s;
}
.accHead:hover { background: var(--panel-hover); }
.accHead svg { transition: transform 0.2s; width: 16px; height: 16px; color: var(--text-muted); }
.acc.open .accHead svg { transform: rotate(90deg); color: var(--accent); }
.accBody { display: none; padding: 10px; border-top: 1px solid var(--border); background: var(--bg); }
.acc.open .accBody { display: block; }

.grid4 { display: grid; grid-template-columns: repeat(auto-fill, minmax(75px, 1fr)); gap: 8px; }
.tool {
    background: var(--panel); border: 1px solid var(--border); color: var(--text-muted);
    border-radius: 8px; padding: 10px 4px; text-align: center; font-size: 11px;
    cursor: pointer; min-height: 60px; display: flex; flex-direction: column;
    align-items: center; justify-content: center; gap: 6px;
    transition: all 0.2s;
}
.tool svg { width: 20px; height: 20px; margin-bottom: 2px; }
.tool:hover { background: var(--panel-hover); color: var(--text); border-color: var(--border-highlight); }
.tool.active {
    background: rgba(59, 130, 246, 0.1); border-color: var(--accent); color: var(--accent);
    box-shadow: 0 0 0 1px var(--accent);
}

.slider-container { padding: 8px 0 16px; position: relative; }
input[type=range].input {
    -webkit-appearance: none; appearance: none; height: 6px; background: var(--border);
    border-radius: 3px; border: none; padding: 0;
}
input[type=range].input::-webkit-slider-thumb {
    -webkit-appearance: none; appearance: none; width: 18px; height: 18px;
    background: var(--accent); border: 4px solid var(--bg); border-radius: 50%;
    cursor: pointer; box-shadow: 0 0 0 1px var(--border-highlight); transition: transform 0.1s;
}
input[type=range].input::-webkit-slider-thumb:hover { transform: scale(1.1); }

#lenWrap {
    background: var(--panel); border-top: 1px solid var(--border);
    position: absolute; bottom: 0; left: 0; right: 0; max-height: 60%;
    display: flex; flex-direction: column; z-index: 25;
    transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1); transform: translateY(calc(100% - 48px));
    box-shadow: 0 -4px 20px rgba(0,0,0,0.3);
}
#lenWrap.open { transform: translateY(0); }
#lenHead {
    display: flex; justify-content: space-between; align-items: center; padding: 0 16px;
    background: var(--panel); cursor: pointer; height: 48px; flex: 0 0 48px;
    border-bottom: 1px solid var(--border); font-size: 14px; font-weight: 600;
}
#lenBody { overflow-y: auto; flex: 1; background: var(--bg); padding-bottom: 30px; }
table { width: 100%; border-collapse: collapse; }
th, td { border-bottom: 1px solid var(--border); padding: 12px 8px; font-size: 13px; text-align: left; vertical-align: middle; }
th { color: var(--text-muted); font-weight: 600; background: var(--panel); position: sticky; top: 0; z-index: 2; font-size: 12px; text-transform: uppercase; }
td .edit { background: var(--panel); border: 1px solid var(--border); color: var(--text); border-radius: 6px; padding: 6px 8px; width: 100%; }
.xbtn {
    background: rgba(239, 68, 68, 0.1); border: 1px solid rgba(239, 68, 68, 0.2);
    color: var(--danger); border-radius: 6px; width: 28px; height: 28px;
    display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s; font-size: 16px; line-height: 1;
}
.xbtn:hover { background: var(--danger); color: white; }

#modalBack, #modalAlert, #modalGallery {
    position: fixed; inset: 0; background: rgba(0,0,0,0.7); z-index: 10000;
    display: none; align-items: center; justify-content: center; backdrop-filter: blur(4px);
}
.card {
    background: var(--panel); border: 1px solid var(--border); border-radius: 16px;
    padding: 24px; width: 90%; max-width: 450px; text-align: center;
    box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.3);
    max-height: 80vh; display: flex; flex-direction: column;
}
.card h3 { margin: 0 0 12px; color: var(--text); font-size: 18px; font-weight: 600; }
.card p { margin: 0 0 24px; color: var(--text-muted); font-size: 14px; }
.card .row { display: flex; gap: 12px; justify-content: center; }
.card button { flex: 1; padding: 12px; border-radius: 8px; border: none; cursor: pointer; font-weight: 600; transition: opacity 0.2s; }
.btn-stay { background: var(--border); color: var(--text); }
.btn-leave { background: var(--danger); color: white; }
.btn-ok { background: var(--accent); color: white; width: 100%; }

.gallery-list {
    overflow-y: auto; flex: 1; text-align: left; margin: 16px 0;
    border: 1px solid var(--border); border-radius: 12px; background: var(--bg);
}
.gallery-item {
    padding: 12px 16px; border-bottom: 1px solid var(--border);
    display: flex; align-items: center; justify-content: space-between; cursor: pointer;
    transition: background 0.2s;
}
.gallery-item:hover { background: var(--panel-hover); }
.gallery-item span { font-size: 14px; color: var(--text); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; }
.gallery-item i { color: var(--text-muted); width: 18px; }

#lblEditor { position: fixed; z-index: 5000; transform: translate(-50%, -120%); }
#lblInput {
    background: var(--panel); color: white; border: 1px solid var(--accent);
    padding: 6px 12px; border-radius: 8px; font-size: 13px; min-width: 100px; text-align: center;
    box-shadow: 0 4px 15px rgba(0,0,0,0.3);
}

@media (max-width: 900px) {
    aside { position: absolute; top: 0; bottom: 0; left: 0; transform: translateX(-105%); box-shadow: 10px 0 30px rgba(0,0,0,0.5); }
    aside.open { transform: translateX(0); }
    #lenWrap { width: 100%; }
    h1 { display: none; }
    header { justify-content: space-between; }
    header .btn { padding: 0 8px; }
    .btn span { display: none; }
    .btn i { margin: 0; }
    #selectionQuickEdit span { display: none; }
}
</style>
</head>
<body class="blurred">
<div id="gate">
  <div class="gcard">
    <button class="close-btn" id="closeGateBtn" title="Continue Editing"><i data-lucide="x"></i></button>
    <div style="margin-bottom: 20px;">
        <img src="https://i.imgur.com/zdJfkpg.png" alt="logo" style="width:80px; height:80px; border-radius:16px; box-shadow: 0 10px 30px rgba(0,0,0,0.3); border: 2px solid var(--border);">
    </div>
    <h2>Christmas Map Maker</h2>
    <p>Design stunning holiday light displays.<br>Upload a photo or start from scratch.</p>
    <div class="grow">
      <div style="display:flex; gap:8px;">
          <button id="gPickImg" class="gbtn" style="flex:1"><i data-lucide="image-plus"></i> Upload Property Photo</button>
          <a href="https://earth.google.com/web/" target="_blank" class="gbtn" style="width:60px; padding:16px 0;" title="Google Earth"><i data-lucide="globe"></i></a>
      </div>
      <button id="gPickBlank" class="gbtn"><i data-lucide="file-plus"></i> Start Blank Map</button>
      <button id="gPickMap" class="gbtn"><i data-lucide="folder-open"></i> Load Existing Map</button>
      <button id="gOpenGallery" class="gbtn"><i data-lucide="layout-grid"></i> Map Gallery (Cloud)</button>
      <button id="gLoadDrive" class="gbtn" disabled><i data-lucide="cloud"></i> Load from Drive</button>
      
      <input id="gImg" type="file" accept="image/*"/>
      <input id="gMap" type="file" accept=".skmap,.json,application/json"/>
    </div>
  </div>
</div>

<div id="modalBack">
    <div class="card">
        <h3>Unsaved Changes</h3>
        <p>You have unsaved work. Are you sure you want to leave?</p>
        <div class="row"><button id="btnStay" class="btn-stay">Stay</button><button id="btnLeave" class="btn-leave">Leave</button></div>
    </div>
</div>
<div id="modalAlert">
    <div class="card">
        <h3>Notice</h3>
        <p id="alertMsg">Message</p>
        <div class="row"><button onclick="document.getElementById('modalAlert').style.display='none'" class="btn-ok">OK</button></div>
    </div>
</div>

<div id="modalGallery">
    <div class="card">
        <h3>Map Gallery</h3>
        <p>Recent maps saved to GitHub cloud.</p>
        <div id="galleryList" class="gallery-list">
            <div style="padding:20px; text-align:center; color:var(--text-muted)">Loading maps...</div>
        </div>
        <div class="row"><button onclick="document.getElementById('modalGallery').style.display='none'" class="btn-stay">Close</button></div>
    </div>
</div>

<div id="lblEditor"><input id="lblInput" placeholder="Note/Ft"></div>

<div id="app">
<header>
  <button id="logoBtn" title="Menu"><img id="logo" src="https://i.imgur.com/zdJfkpg.png" alt=""></button>
  <h1>Skedaddle</h1>
  <span id="modeTag" class="pill" onclick="toggleMenu()">Draw</span>
  
  <div style="flex:1"></div>

  <!-- Dynamic Selection Area -->
  <div id="selectionQuickEdit">
      <span id="editLabelPrefix" style="font-size:12px; color:var(--text-muted); font-weight:600">ID:</span>
      <input id="quickEditPrefix" class="input" style="width:70px; height:32px; padding:4px 8px; font-size:13px" placeholder="F1"/>
      <button id="moveLabelToggleBtn" class="btn" title="Move Label"><i data-lucide="move-diagonal"></i></button>
      <button id="quickDeleteBtn" class="btn" style="color:var(--danger); height:32px" title="Delete Selected"><i data-lucide="trash-2"></i></button>
  </div>

  <button id="btnDraw" class="btn" title="Draw Mode"><i data-lucide="pencil"></i><span>Draw</span></button>
  <button id="btnSelect" class="btn" title="Select Mode"><i data-lucide="mouse-pointer-2"></i><span>Select</span></button>
  <button id="btnMoveCanvas" class="btn" title="Pan Canvas"><i data-lucide="move"></i><span>Pan</span></button>
  <div style="width:1px; height:24px; background:var(--border); margin:0 4px"></div>
  <button id="btnUndo" class="btn" title="Undo"><i data-lucide="undo-2"></i></button>
  
  <button id="btnComplete" class="btn" disabled title="Finish Line"><i data-lucide="check-circle"></i></button>
  
  <button id="btnRedo" class="btn" disabled title="Redo"><i data-lucide="redo-2"></i></button>
  <div style="width:1px; height:24px; background:var(--border); margin:0 4px"></div>
  
  <button id="btnSwag" class="btn" style="display:none" title="Garland Swag"><i data-lucide="waves"></i><span>Swag</span></button>
  <button id="btnPillar" class="btn" style="display:none" title="Pillar Mode"><i data-lucide="columns-2"></i><span>Pillar</span></button>
  
  <button id="btnSnap" class="btn toggled" title="Snap to Points"><i data-lucide="magnet"></i></button>
  <button id="btnFit" class="btn" title="Reset View"><i data-lucide="maximize"></i></button>
  
  <div style="width:1px; height:24px; background:var(--border); margin:0 4px"></div>
  
  <button id="btnSaveAll" class="btn" title="Save All"><i data-lucide="save"></i><span>Save</span></button>
  <button id="btnSaveImageOnly" class="btn" title="Export PDF"><i data-lucide="file-down"></i></button>
  <button id="btnSaveMapOnly" class="btn" title="Save File"><i data-lucide="download"></i></button>
</header>

<div class="wrap">
  <div id="overlay" class="overlay"></div>
  <aside id="side">
    <div class="group">
      <h3>Toolbox</h3>
      <div id="accWrap"></div>
    </div>
    
    <div class="group">
      <h3>Project Details</h3>
      <div class="grow" style="gap:8px">
          <input id="customer" class="input" placeholder="Customer Name"/>
          <input id="address" class="input" placeholder="Property Address"/>
          <textarea id="jobNotes" class="input" placeholder="Installation notes..."></textarea>
      </div>
      
      <div style="font-size:11px; color:var(--text-muted); margin-top:12px; font-weight:600; text-transform:uppercase">Bulk Colour</div>
      <input id="inputAllCol" class="input" placeholder="Set color for all items..." style="margin-top:6px">
    </div>
    
    <div class="group">
        <h3>Timers</h3>
        <button id="btnCustomerControlled" class="btn" style="width:100%; margin-bottom:12px; justify-content:center;">Customer Controlled</button>
        <div id="timerInputs">
            <div class="lbl-row"><span>On</span><span>Off</span></div>
            <div class="row2"><input id="on1" type="time" class="input"/><input id="off1" type="time" class="input"/></div>
            <div class="lbl-row" style="margin-top:8px"><span>On</span><span>Off</span></div>
            <div class="row2"><input id="on2" type="time" class="input"/><input id="off2" type="time" class="input"/></div>
            <button id="btnStd" class="btn" style="width:100%; margin-top:12px; justify-content:center; font-size:12px;">Set Standard Times</button>
        </div>
    </div>
    
    <div class="group">
      <h3>Display Settings</h3>
      
      <div style="font-size:11px; margin-bottom:6px; color:var(--text-muted);">Line Thickness</div>
      <div class="slider-container" id="lineScaleContainer">
          <input id="lineScaleInput" type="range" class="input" min="0.5" max="3" step="0.1" value="1.0"/>
          <div style="font-size:10px; color:var(--text-muted); display:flex; justify-content:space-between; margin-top:4px;">
              <span>Thin</span><span id="lineScaleValue" style="color:var(--text)">1.0x</span><span>Thick</span>
          </div>
      </div>
      
      <div style="font-size:11px; margin-top:12px; margin-bottom:6px; color:var(--text-muted);">Flow Arrows Frequency</div>
      <div class="slider-container" id="arrowFreqContainer">
          <input id="arrowFreqInput" type="range" class="input" min="0.2" max="1.5" step="0.1" value="1.0"/>
          <div style="font-size:10px; color:var(--text-muted); display:flex; justify-content:space-between; margin-top:4px;">
              <span>Few</span><span id="arrowFreqValue" style="color:var(--text)">1.0x</span><span>Many</span>
          </div>
      </div>

      <div style="font-size:11px; margin-top:12px; margin-bottom:6px; color:var(--text-muted);">Flow Arrow Size</div>
      <div class="slider-container" id="arrowScaleContainer">
          <input id="arrowScaleInput" type="range" class="input" min="0.5" max="3" step="0.1" value="1.0"/>
          <div style="font-size:10px; color:var(--text-muted); display:flex; justify-content:space-between; margin-top:4px;">
              <span>Small</span><span id="arrowScaleValue" style="color:var(--text)">1.0x</span><span>Large</span>
          </div>
      </div>

      <div style="font-size:11px; margin-top:12px; margin-bottom:6px; color:var(--text-muted);">Decorations Size</div>
      <div class="slider-container" id="iconScaleContainer">
          <input id="iconScaleInput" type="range" class="input" min="0.5" max="5" step="0.1" value="1.5"/>
          <div style="font-size:10px; color:var(--text-muted); display:flex; justify-content:space-between; margin-top:4px;">
              <span>Small</span><span id="iconScaleValue" style="color:var(--text)">1.5x</span><span>Huge</span>
          </div>
      </div>

      <div style="font-size:11px; margin-top:12px; margin-bottom:6px; color:var(--text-muted);">Background Blur</div>
      <div class="slider-container" id="bgBlurContainer">
          <input id="bgBlurInput" type="range" class="input" min="0" max="100" step="1" value="0"/>
          <div style="font-size:10px; color:var(--text-muted); display:flex; justify-content:space-between; margin-top:4px;">
              <span>Clear</span><span id="bgBlurValue" style="color:var(--text)">0%</span><span>Blurry</span>
          </div>
      </div>
      
      <div style="font-size:11px; margin-top:12px; margin-bottom:6px; color:var(--text-muted);">Power/Junction Size</div>
      <div class="slider-container" id="junctionScaleContainer">
          <input id="junctionScaleInput" type="range" class="input" min="0.5" max="3" step="0.1" value="1.0"/>
          <div style="font-size:10px; color:var(--text-muted); display:flex; justify-content:space-between; margin-top:4px;">
              <span>Small</span><span id="junctionScaleValue" style="color:var(--text)">1.0x</span><span>Large</span>
          </div>
      </div>

      <div style="font-size:11px; margin-top:12px; margin-bottom:6px; color:var(--text-muted);">Label Size</div>
      <div class="slider-container" id="labelScaleContainer">
          <input id="labelScaleInput" type="range" class="input" min="0.5" max="5" step="0.1" value="3.0"/>
          <div style="font-size:10px; color:var(--text-muted); display:flex; justify-content:space-between; margin-top:4px;">
              <span>Small</span><span id="labelScaleValue" style="color:var(--text)">3.0x</span><span>Large</span>
          </div>
      </div>
    </div>
    
    <div class="group">
        <h3>Legend</h3>
        <dl class="clip-legend">
            <dt><div class="leg-sq"></div> PS</dt><dd>Power Source</dd>
            <dt><div class="leg-tri"></div> 3W</dt><dd>3-Way Adapter</dd>
            <dt>ST</dt><dd>Shingle Tab (Eaves/Ridges)</dd>
            <dt>T</dt><dd>Tuff Clip (Fascia)</dd>
            <dt>Mag</dt><dd>Magnetic Clip</dd>
            <dt>FRA</dt><dd>Flat Roof Adapter</dd>
            <dt>GG</dt><dd>Gutter Guard</dd>
        </dl>
    </div>
  </aside>

  <main>
    <div class="canvasWrap"><canvas id="cv"></canvas></div>
    <div id="lenWrap">
      <div id="lenHead">
          <div style="display:flex; align-items:center; gap:8px"><i data-lucide="ruler"></i> Line Information <span style="font-weight:400; color:var(--text-muted); font-size:12px">(Tap to view)</span></div>
          <i data-lucide="chevron-up" id="lenChevron"></i>
      </div>
      <div id="lenBody">
        <div style="padding:12px 16px; border-bottom:1px solid var(--border); display:flex; align-items:center; gap:16px; flex-wrap:wrap">
             <label style="display:flex; align-items:center; gap:6px; font-size:13px; color:var(--text); cursor:pointer;">
                <input id="chkAutoCalc" type="checkbox" checked style="accent-color:var(--accent)"/> Auto-calculate bulbs/feet
             </label>
             <button id="btnRelabelIDs" class="btn" style="height:32px; font-size:12px; margin-left:auto"><i data-lucide="list-ordered"></i> Relabel IDs</button>
        </div>

        <div style="overflow-x:auto">
          <table id="matTable">
            <thead><tr><th>Type</th><th style="width:60px">ID</th><th>Ft</th><th>Bulbs</th><th>Clip</th><th>Colour</th><th>Notes</th><th style="width:40px"></th></tr></thead>
            <tbody id="lenRows"></tbody>
          </table>
        </div>
      </div>
    </div>
  </main>
</div>
</div>

<div id="wreathPop" class="pop">
  <button data-bow="none">No Bow</button><button data-bow="bottom">Bot Bow</button><button data-bow="top">Top Bow</button>
</div>
<div id="tolPop" class="pop">
  <button data-size="3">3'</button><button data-size="6">6'</button><button data-size="9">9'</button><button data-size="12">12'</button><button data-size="15">15'</button>
</div>

<div id="imgUploadPop" class="pop" style="flex-direction: column; padding: 12px; min-width: 200px;">
  <label for="iconFile" class="btn" style="margin-bottom: 8px; justify-content:center"><i data-lucide="upload"></i> Upload Image</label>
  <input type="file" id="iconFile" accept="image/*" style="display:none;"/>
  <button id="cancelIconUpload" class="btn" style="justify-content:center">Cancel</button>
</div>

<script>
(()=>{
    
const iconMap = {
    'ridges': 'home',
    'fascia': 'minus',
    'peaks': 'triangle',
    'groundstakes': 'map-pin',
    'shrub': 'cloud',
    'windows': 'layout-grid',
    'garland': 'waves',
    'wreath': 'circle-dashed',
    'wreath32': 'circle',
    'wreath42': 'circle-dot',
    'bow': 'gift',
    'tree': 'tree-pine',
    'tree:Trunk + Branch (Minis)': 'tree-deciduous',
    'tree:Trunk + Canopy (Minis)': 'tree-pine',
    'tree:C9 Tree': 'triangle', 
    'tree:ToL': 'sprout',
    'cords': 'plug',
    'powersource': 'zap',
    'threeway': 'git-fork',
    'label': 'type',
    'custom_icon': 'image',
    'night_mode': 'moon'
};

/* ---------------------------------------------------------------------- */
/* ------------------------ BETA: GITHUB CLOUD SAVING ------------------- */
/* ---------------------------------------------------------------------- */
const githubConfig = {
    token: "",      // Paste your GitHub PAT here
    owner: "",      // Your GitHub Username
    repo: "",       // Your Repository Name (e.g., 'skedaddle-maps')
    path: "maps/",  // Folder where maps are stored
};

async function saveToGitHub(filename, content, isBase64 = false) {
    if (!githubConfig.token || !githubConfig.owner || !githubConfig.repo) return;
    const url = `https://api.github.com/repos/${githubConfig.owner}/${githubConfig.repo}/contents/${githubConfig.path}${filename}`;
    
    try {
        // 1. Get current file (if exists) to get the SHA
        let sha = null;
        const checkRes = await fetch(url, { headers: { "Authorization": `token ${githubConfig.token}` } });
        if (checkRes.ok) {
            const data = await checkRes.json();
            sha = data.sha;
        }

        // 2. Prepare content
        const body = {
            message: `Save map: ${filename}`,
            content: isBase64 ? content : btoa(unescape(encodeURIComponent(content))),
            sha: sha // Required to update existing file
        };

        const saveRes = await fetch(url, {
            method: "PUT",
            headers: {
                "Authorization": `token ${githubConfig.token}`,
                "Content-Type": "application/json"
            },
            body: JSON.stringify(body)
        });

        if (!saveRes.ok) console.error("GitHub Save Error:", await saveRes.text());
    } catch (err) { console.error("GitHub Connection Failed:", err); }
}

async function openGallery() {
    if (!githubConfig.token) { showAlert("GitHub token not configured. Please add your token in the code settings."); return; }
    const modal = document.getElementById('modalGallery');
    const list = document.getElementById('galleryList');
    modal.style.display = 'flex';
    list.innerHTML = '<div style="padding:20px; text-align:center; color:var(--text-muted)">Fetching cloud storage...</div>';

    try {
        const url = `https://api.github.com/repos/${githubConfig.owner}/${githubConfig.repo}/contents/${githubConfig.path}`;
        const res = await fetch(url, { headers: { "Authorization": `token ${githubConfig.token}` } });
        if (res.ok) {
            const files = await res.json();
            const mapFiles = files.filter(f => f.name.endsWith('.skmap'));
            if (mapFiles.length === 0) {
                list.innerHTML = '<div style="padding:20px; text-align:center; color:var(--text-muted)">No maps found in cloud folder.</div>';
                return;
            }
            list.innerHTML = '';
            mapFiles.forEach(f => {
                const item = document.createElement('div');
                item.className = 'gallery-item';
                item.innerHTML = `<span>${f.name}</span><i data-lucide="download"></i>`;
                item.onclick = () => loadFromGitHub(f.download_url);
                list.appendChild(item);
            });
            lucide.createIcons();
        } else { list.innerHTML = '<div style="padding:20px; text-align:center; color:var(--danger)">Error fetching repo. Verify owner/repo settings.</div>'; }
    } catch (err) { list.innerHTML = '<div style="padding:20px; text-align:center; color:var(--danger)">Connection failed.</div>'; }
}

async function loadFromGitHub(downloadUrl) {
    try {
        const res = await fetch(downloadUrl);
        const json = await res.json();
        const blob = new Blob([JSON.stringify(json)], { type: "application/json" });
        const file = new File([blob], "cloud_map.skmap");
        handleMap(file);
        document.getElementById('modalGallery').style.display = 'none';
    } catch (err) { showAlert("Error loading map content."); }
}

/* ---------------------------------------------------------------------- */
/* --------------------- GOOGLE DRIVE API INTEGRATION ------------------- */
/* ---------------------------------------------------------------------- */
const CLIENT_ID = '746571343552-88ogvei1lvtq9ojq3te7fn06d1rlgut4.apps.googleusercontent.com';
const API_KEY = 'AIzaSyCBB6UWp5-FCB7VMpRKsjQh7sR42qd4SN0';
const APP_ID = '746571343552';
const GDRIVE_SCOPES = 'https://www.googleapis.com/auth/drive.file https://www.googleapis.com/auth/drive.appdata'; 
const MAP_MIME_TYPE = 'application/json';
const MAP_FILE_EXTENSION = '.skmap';

let accessToken = null;
let tokenClient = null;
let gapiReady = false;
let gisReady = false;

const gLoadDriveBtn = document.getElementById('gLoadDrive');

gapi.load('client:picker', async () => {
    try {
        await gapi.client.setApiKey(API_KEY);
        await gapi.client.load('drive', 'v3'); 
        gapiReady = true;
        const checkGis = setInterval(() => {
            if (window.google && window.google.accounts) {
                clearInterval(checkGis);
                initGis();
            }
        }, 100);
    } catch (err) { console.error("Error loading GAPI:", err); }
});

function initGis() {
    try {
        tokenClient = google.accounts.oauth2.initTokenClient({
            client_id: CLIENT_ID, scope: GDRIVE_SCOPES,
            callback: (response) => {
                if (response.error !== undefined) showAlert('Authorization Failed: ' + response.error);
                else { accessToken = response.access_token; updateDriveUI(true); }
            },
        });
        gisReady = true; checkApiReadiness();
    } catch (err) { console.error("Error initializing GIS:", err); }
}

function checkApiReadiness() {
    if (gapiReady && gisReady) {
        gLoadDriveBtn.disabled = false;
        const authClickHandler = () => tokenClient.requestAccessToken({ prompt: '' });
        gLoadDriveBtn.onclick = authClickHandler;
    }
}

function updateDriveUI(isAuthenticated) {
    if (isAuthenticated) {
        gLoadDriveBtn.innerHTML = '<i data-lucide="cloud"></i> Load from Drive';
        gLoadDriveBtn.onclick = () => createPicker('load');
        lucide.createIcons();
    }
}

async function createPicker(pickerType) {
    if (!accessToken || !gapiReady || !gisReady) { showAlert('Please sign in to Google Drive first.'); return; }
    let view = new google.picker.View(google.picker.ViewId.DOCS);
    view.setMimeTypes(MAP_MIME_TYPE + ',text/plain,application/octet-stream'); 
    view.setQuery(MAP_FILE_EXTENSION);
    const picker = new google.picker.PickerBuilder()
        .setAppId(APP_ID).setOAuthToken(accessToken).setDeveloperKey(API_KEY)
        .addView(view).setCallback(pickerCallback).build();
    picker.setVisible(true);
}

function pickerCallback(data) {
    if (data.action === google.picker.Action.PICKED) {
        const file = data.docs[0];
        loadFromDrive(file[google.picker.Document.ID]);
    }
}

async function loadFromDrive(fileId) {
    showAlert('Loading map from Google Drive...');
    try {
        const response = await gapi.client.drive.files.get({ fileId: fileId, alt: 'media' });
        const mapDataString = response.body;
        const file = new File([mapDataString], 'downloaded_map.skmap', { type: MAP_MIME_TYPE });
        handleMap(file); 
        document.getElementById('modalAlert').style.display = 'none';
    } catch (error) { showAlert('Error loading map content from Drive.'); }
}

/* ---------------------------------------------------------------------- */
/* ------------------------ ORIGINAL MAP MAKER CODE --------------------- */
/* ---------------------------------------------------------------------- */

const cats=[{name:"C9's",key:'c9',list:['fascia','peaks','ridges','groundstakes']},{name:'Minis',key:'min',list:['shrub','windows']},{name:'Greenery',key:'grn',list:['wreath32','wreath42','garland','bow']},{name:'Trees',key:'tre',list:['tree:Trunk + Branch (Minis)','tree:Trunk + Canopy (Minis)','tree:C9 Tree','tree:ToL']},{name:'Power',key:'pwr',list:['powersource','cords','threeway']},
            {name:'Specials', key:'spec', list:['label', 'custom_icon', 'night_mode']}]; 
const pretty={ridges:'Ridges',fascia:'Fascia',peaks:'Peaks',groundstakes:'Stakes',shrub:'Shrub',windows:'Windows',garland:'Garland',wreath:'Wreath',bow:'Bow',cords:'Cord',powersource:'Source',threeway:'3-Way',tree:'Tree', label: 'Label', custom_icon: 'Image', night_mode: 'Night'};
const pfx={ridges:'R',fascia:'F',peaks:'P',groundstakes:'GS',shrub:'S',windows:'W',garland:'GA',wreath:'WR',bow:'B',cords:'C',powersource:'PS',tree:'T', label:'LBL', custom_icon: 'CI'};
const data={ridges:[],fascia:[],peaks:[],groundstakes:[],shrub:[],windows:[],garland:[],wreath:[],bow:[],cords:[],powersource:[],threeway:[],tree:[], label:[], custom_icon:[]}; 

function getColorCode(colorName) {
    if (!colorName) return '#ddd';
    const lowerName = colorName.toLowerCase();
    if (lowerName.includes('multi') || lowerName === 'm' || lowerName.includes('multiple')) return 'Red/Blue/Green/Orange/Yellow';
    if (colorName.includes(' ') || colorName.includes('/') || colorName.includes(',')) return colorName;
    const cleanName = lowerName.replace(/[^a-z0-9#]/g, '');
    switch (cleanName) {
        case 'warmwhite': case 'softwhite': case 'white': case 'ww': case 'sw': case '#fffdf0': return '#fffdf0';
        case 'red': return '#ef4444';
        case 'blue': return '#3b82f6';
        case 'green': return '#22c55e';
        case 'yellow': return '#eab308';
        case 'orange': return '#f97316';
        case 'purple': case 'violet': return '#a855f7';
        case 'pink': return '#ec4899';
        case 'black': return '#000000';
        default: if(colorName.startsWith('#') && colorName.length >= 4) return colorName; return '#ddd'; 
    }
}
const colorOf=L=>({ridges:'#fffdf0',fascia:'#fffdf0',peaks:'#fffdf0',groundstakes:'#fffdf0',shrub:'#22c55e',windows:'#7dd3fc',garland:'#22c55e',wreath:'#22c55e',bow:'#ef4444',cords:'#000000',powersource:'#ef4444',threeway:'#eab308',tree:'#22c55e'}[L]||'#ddd');

let settings = { iconScale: 1.5, junctionScale: 1.0, lineScale: 1.0, labelScale: 3.0, lineThickness: 3, arrowScale: 1.0, arrowFreqFactor: 1.0, bgBlur: 0 };
let isNightMode = false;

const aside=document.getElementById('side'), overlay=document.getElementById('overlay');
function toggleMenu(){
    const isOpen = aside.classList.contains('open');
    if(isOpen) { aside.classList.remove('open'); overlay.classList.remove('show'); }
    else { aside.classList.add('open'); overlay.classList.add('show'); }
}
document.getElementById('logoBtn').onclick=toggleMenu;
overlay.onclick=toggleMenu;
document.getElementById('modeTag').onclick=toggleMenu;

const closeGateBtn = document.getElementById('closeGateBtn');
function openGate(fromCanvas = false) {
    document.body.classList.add('blurred');
    document.getElementById('gate').classList.remove('hide');
    closeGateBtn.style.display = fromCanvas ? 'block' : 'none';
}
function unlock(){
    document.body.classList.remove('blurred');
    document.getElementById('gate').classList.add('hide');
    history.pushState(null, null, location.href);
}

const lenWrap = document.getElementById('lenWrap');
const lenChevron = document.getElementById('lenChevron');
document.getElementById('lenHead').onclick=()=>{
    lenWrap.classList.toggle('open');
    if (lenWrap.classList.contains('open')) {
        lenChevron.setAttribute('data-lucide', 'chevron-down');
    } else {
        lenChevron.setAttribute('data-lucide', 'chevron-up');
    }
    lucide.createIcons();
};

function showAlert(msg) {
    document.getElementById('alertMsg').textContent = msg;
    document.getElementById('modalAlert').style.display = 'flex';
}

const lineScaleInput = document.getElementById('lineScaleInput');
const lineScaleValue = document.getElementById('lineScaleValue');
const iconScaleInput = document.getElementById('iconScaleInput');
const iconScaleValue = document.getElementById('iconScaleValue');
const bgBlurInput = document.getElementById('bgBlurInput');
const bgBlurValue = document.getElementById('bgBlurValue');
const junctionScaleInput = document.getElementById('junctionScaleInput'); 
const junctionScaleValue = document.getElementById('junctionScaleValue'); 
const labelScaleInput = document.getElementById('labelScaleInput');
const labelScaleValue = document.getElementById('labelScaleValue');
const arrowFreqInput = document.getElementById('arrowFreqInput'); 
const arrowFreqValue = document.getElementById('arrowFreqValue'); 
const arrowScaleInput = document.getElementById('arrowScaleInput'); 
const arrowScaleValue = document.getElementById('arrowScaleValue'); 

function updateLineScaleUI() { settings.lineScale = parseFloat(lineScaleInput.value); lineScaleValue.textContent = `${settings.lineScale.toFixed(1)}x`; }
function updateIconScaleUI() { settings.iconScale = parseFloat(iconScaleInput.value); iconScaleValue.textContent = `${settings.iconScale.toFixed(1)}x`; }
function updateBgBlurUI() { settings.bgBlur = parseInt(bgBlurInput.value); bgBlurValue.textContent = `${settings.bgBlur}%`; }
function updateJunctionScaleUI() { settings.junctionScale = parseFloat(junctionScaleInput.value); junctionScaleValue.textContent = `${settings.junctionScale.toFixed(1)}x`; }
function updateLabelScaleUI() { settings.labelScale = parseFloat(labelScaleInput.value); labelScaleValue.textContent = `${settings.labelScale.toFixed(1)}x`; }
function updateArrowFreqUI() { settings.arrowFreqFactor = parseFloat(arrowFreqInput.value); arrowFreqValue.textContent = `${settings.arrowFreqFactor.toFixed(1)}x`; }
function updateArrowScaleUI() { settings.arrowScale = parseFloat(arrowScaleInput.value); arrowScaleValue.textContent = `${settings.arrowScale.toFixed(1)}x`; }

lineScaleInput.oninput = (e) => { settings.lineScale = parseFloat(e.target.value); updateLineScaleUI(); markPowerDirty(); requestRender(); };
iconScaleInput.oninput = (e) => { settings.iconScale = parseFloat(e.target.value); updateIconScaleUI(); requestRender(); };
bgBlurInput.oninput = (e) => { settings.bgBlur = parseInt(e.target.value); updateBgBlurUI(); requestRender(); };
junctionScaleInput.oninput = (e) => { settings.junctionScale = parseFloat(junctionScaleInput.value); updateJunctionScaleUI(); markPowerDirty(); requestRender(); };
labelScaleInput.oninput = (e) => { settings.labelScale = parseFloat(labelScaleInput.value); updateLabelScaleUI(); requestRender(); };
arrowFreqInput.oninput = (e) => { settings.arrowFreqFactor = parseFloat(arrowFreqInput.value); updateArrowFreqUI(); markPowerDirty(); requestRender(); };
arrowScaleInput.oninput = (e) => { settings.arrowScale = parseFloat(arrowScaleInput.value); updateArrowScaleUI(); markPowerDirty(); requestRender(); };

function toggleNightMode(isManualToggle=true) {
    isNightMode = !isNightMode;
    const nightModeToolButton = toolBtn['night_mode'];
    if (nightModeToolButton) {
        nightModeToolButton.classList.toggle('toggled', isNightMode);
        nightModeToolButton.classList.toggle('night-glow', isNightMode);
    }
    if (mode === 'night_mode') { mode = 'draw'; updateModeTag(); }
    requestRender();
}

const chkSnap = { checked: true };
const btnSnap = document.getElementById('btnSnap');
btnSnap.onclick = () => { chkSnap.checked = !chkSnap.checked; btnSnap.classList.toggle('toggled', chkSnap.checked); };

const chkSwag = { checked: false };
const btnSwag = document.getElementById('btnSwag');
btnSwag.onclick = () => { chkSwag.checked = !chkSwag.checked; btnSwag.classList.toggle('toggled', chkSwag.checked); };

const chkPillar = { checked: false };
const btnPillar = document.getElementById('btnPillar');
btnPillar.onclick = () => { chkPillar.checked = !chkPillar.checked; btnPillar.classList.remove('toggled'); };

function isMinis(L, item) {
    if(L === 'tree') return item && item.kind !== 'C9 Tree'; 
    const c = cats.find(x => x.key === 'min');
    return c && c.list.includes(L);
}
function isC9(L) { const c = cats.find(x => x.key === 'c9'); return c && c.list.includes(L); }

function relabelIds() {
    let itemsToRelabel = [];
    Object.keys(data).forEach(L => {
        if (L === 'cords' || L === 'threeway' || L === 'powersource' || L === 'bow' || L === 'custom_icon' || L === 'label') return; 
        data[L].forEach(item => {
            const prefix = pfx[L] || 'L';
            const isStandardLabel = !item.label || new RegExp('^' + prefix + '\\d+$', 'i').test(item.label);
            
            if (isStandardLabel) { 
                let centerX = 0;
                if (item.points && item.points.length > 0) {
                    item.points.forEach(p => centerX += p.x); centerX /= item.points.length;
                } else if (item.pt) centerX = item.pt.x;
                itemsToRelabel.push({ item, L, centerX });
            }
        });
    });
    itemsToRelabel.sort((a, b) => a.centerX - b.centerX);
    const nextIndices = {}; 
    itemsToRelabel.forEach(record => {
        const L = record.L; const prefix = pfx[L] || 'L';
        if (!nextIndices[L]) nextIndices[L] = 1;
        const newIndex = nextIndices[L]++;
        record.item.label = prefix + newIndex;
    });
    refreshTable(); markPowerDirty(); requestRender();
}

function shouldShowGutterGuard(layer, clipType) {
    return layer === 'fascia' && (clipType === 'T' || clipType === 'ST');
}

function refreshTable(){
    const tbody = document.getElementById('lenRows'); tbody.innerHTML='';
    let rows=[];
    const EXCLUDED_LAYERS = ['label', 'custom_icon', 'bow', 'cords', 'powersource', 'threeway'];
    Object.keys(data).forEach(k=>{
        if (EXCLUDED_LAYERS.includes(k)) return;
        data[k].forEach(it=>{ rows.push({item: it, L:k}); });
    });
    rows.sort((a,b)=> (a.item.label||'').localeCompare(b.item.label||'', undefined, {numeric:true}));
    const chkAuto = document.getElementById('chkAutoCalc');

    rows.forEach(r=>{
        const tr=document.createElement('tr');
        let clipHtml = '', showFRA = false, showGutterGuard = false, fraHtml = '', gguardHtml = '';
        let clipFraContainerStart = '<div class="clip-fra-container">', clipFraContainerEnd = '</div>';

        if(isC9(r.L)) {
            if(r.L === 'groundstakes') { clipHtml = '<span style="color:#555">-</span>'; clipFraContainerStart = ''; clipFraContainerEnd = ''; } 
            else {
                if(!r.item.clip) r.item.clip = (r.L === 'ridges' || r.L === 'peaks') ? 'ST' : 'T';
                let opts = [];
                if(r.L === 'ridges') opts = [{v:'ST', l:'Shingle'}]; 
                else if (r.L === 'peaks') opts = [{v:'ST', l:'Shingle'}, {v:'Mag', l:'Mag'}];
                else if (r.L === 'fascia') opts = [{v:'T', l:'Tuff'}, {v:'ST', l:'Shingle'}, {v:'Mag', l:'Mag'}];
                
                let optStr = opts.map(o => `<option value="${o.v}" ${r.item.clip===o.v?'selected':''}>${o.l}</option>`).join('');
                clipHtml = `<select class="edit clip-select" style="width:auto; padding:4px;">${optStr}</select>`;

                if (r.item.clip === 'ST') {
                    showFRA = true; if (r.item.fra === undefined) r.item.fra = false;
                    fraHtml = `<label class="fra-checkbox-label" title="Flat Roof Adapter"><input type="checkbox" class="fra-checkbox" ${r.item.fra ? 'checked' : ''}/> FRA</label>`;
                }
                if (shouldShowGutterGuard(r.L, r.item.clip)) {
                     showGutterGuard = true; if (r.item.gguard === undefined) r.item.gguard = false; 
                     gguardHtml = `<label class="gg-checkbox-label" title="Gutter Guard"><input type="checkbox" class="gg-checkbox" ${r.item.gguard ? 'checked' : ''}/> GG</label>`;
                }
            }
        } else { clipHtml = '<span style="color:#555">-</span>'; clipFraContainerStart = ''; clipFraContainerEnd = ''; }
        const clipCellContent = clipFraContainerStart + clipHtml + fraHtml + gguardHtml + clipFraContainerEnd;

        let colorInputHtml = '';
        const rawColorValue = r.item.col || '';
        const processedColorCode = getColorCode(rawColorValue);

        if (r.L === 'garland' || r.L === 'wreath') { 
             const color = getColorCode('green');
             colorInputHtml = `<span style="color:#0f172a; font-weight:bold; background:${color}; padding: 2px 6px; border-radius: 4px; font-size:11px;">Green</span>`; 
        } else if (r.L === 'cords') {
             const color = getColorCode('black');
             colorInputHtml = `<span style="color:#fff; font-weight:bold; background:${color}; padding: 2px 6px; border-radius: 4px; font-size:11px;">Black</span>`; 
        } else {
             const displayValue = (processedColorCode.toLowerCase().includes('red/blue') || rawColorValue.toLowerCase().includes('multi') || rawColorValue.toLowerCase() === 'm') ? 'Multi' : rawColorValue;
             colorInputHtml = `<input class="edit" placeholder="Col" value="${displayValue}">`;
        }

        const bulbsVal = r.item.kind === 'ToL' ? '' : (r.item.bulbs || '');
        let typeDisplay = pretty[r.L];
        if (r.item.kind === 'ToL') typeDisplay = 'Tree of Lights';

        tr.innerHTML=`
            <td>${typeDisplay}</td>
            <td><input class="edit" style="width:50px" value="${r.item.label||''}"></td>
            <td><input class="edit" placeholder="ft" style="width:40px" value="${r.item.ft||''}"></td>
            <td><input class="edit" placeholder="#" style="width:40px" value="${bulbsVal}" ${r.item.kind === 'ToL' ? 'disabled' : ''}></td>
            <td>${clipCellContent}</td>
            <td>${colorInputHtml}</td>
            <td><input class="edit" placeholder="Notes" style="min-width:80px" value="${r.item.notes||''}"></td>
            <td><button class="xbtn">Ã—</button></td>`;
        
        const select = tr.querySelector('.clip-select');
        const fraCheck = tr.querySelector('.fra-checkbox');
        const gguardCheck = tr.querySelector('.gg-checkbox'); 
        const inputId = tr.querySelector('input[style*="width:50px"]');
        const inputCol = tr.querySelector('input[placeholder="Col"]');
        const inputFt = tr.querySelector('input[placeholder="ft"]');
        const inputBulbs = tr.querySelector('input[placeholder="#"]');
        const inputNotes = tr.querySelector('input[placeholder="Notes"]');
        
        if (inputId) inputId.onchange = e => { r.item.label = e.target.value; markPowerDirty(); requestRender(); refreshTable(); };
        if (inputCol) {
            inputCol.oninput=e=>{
                 const val = e.target.value; const lowerVal = val.toLowerCase();
                 const cleanedV = val.replace(/\s/g, '/').replace(/,/g, '/');
                 if (lowerVal.includes('multi') || lowerVal === 'm' || lowerVal.includes('multiple')) {
                     r.item.col = getColorCode('multi'); e.target.value = 'Multi'; 
                 } else {
                     r.item.col = cleanedV; 
                     if (cleanedV.includes('/')) e.target.value = cleanedV; else e.target.value = val;
                 }
            };
            inputCol.onchange=()=>requestRender(); 
        }
        if (inputFt) {
            inputFt.oninput=e=>{ r.item.ft = e.target.value; };
            inputFt.onchange=e=>{
                if(chkAuto.checked && e.target.value) {
                    if(r.L === 'garland' || r.L === 'wreath' || r.item.kind === 'ToL') return; 
                    const val = parseFloat(e.target.value);
                    if(!isNaN(val)) {
                        let b = Math.round(val / 0.8);
                        if(isMinis(r.L, r.item)) {
                            b = val * 2; b = Math.ceil(b / 50) * 50; const balls = b / 50;
                            if(inputNotes) inputNotes.value = `${balls} Ball${balls > 1 ? 's' : ''}`;
                            r.item.notes = inputNotes ? inputNotes.value : r.item.notes;
                            r.item.ft = b / 2; inputFt.value = b / 2;
                        }
                        if(inputBulbs) inputBulbs.value = b; r.item.bulbs = b;
                    }
                }
            };
        }
        if (inputBulbs) {
            inputBulbs.oninput=e=>{ r.item.bulbs = e.target.value; };
            inputBulbs.onchange=e=>{
                if(chkAuto.checked && e.target.value) {
                    if(r.L === 'garland' || r.L === 'wreath' || r.item.kind === 'ToL') return; 
                    const val = parseFloat(e.target.value);
                    if(!isNaN(val)) {
                        let f = Math.round(val / 0.8); 
                        if(isMinis(r.L, r.item)) {
                            const balls = Math.ceil(val / 50); const exactBulbs = balls * 50;
                            f = exactBulbs / 2; 
                            if(inputNotes) inputNotes.value = `${balls} Ball${balls > 1 ? 's' : ''}`;
                            r.item.notes = inputNotes ? inputNotes.value : r.item.notes;
                            r.item.bulbs = exactBulbs; inputBulbs.value = exactBulbs;
                        }
                        if(inputFt) inputFt.value = f; r.item.ft = f;
                    }
                }
            };
        }
        if (inputNotes) inputNotes.oninput=e=>r.item.notes=e.target.value;
        if(select) select.onchange = e => { 
            r.item.clip = e.target.value; r.item.fra = false; r.item.gguard = false; 
            refreshTable(); requestRender(); 
        };
        if(fraCheck) fraCheck.onchange = e => { r.item.fra = e.target.checked; requestRender(); };
        if(gguardCheck) gguardCheck.onchange = e => { r.item.gguard = e.target.checked; requestRender(); };
        tr.querySelector('.xbtn').onclick=()=>{ 
            const idx=data[r.L].indexOf(r.item); 
            if(idx>-1){ data[r.L].splice(idx,1); refreshTable(); markPowerDirty(); requestRender(); } 
        };
        tbody.appendChild(tr);
    });
}

let cv = document.getElementById('cv');
let ctx = cv.getContext('2d', {alpha: true}); 
const canvasWrap = cv.parentElement;
let DPR=1; let scale=1, panX=0, panY=0; 
let imgReady=false; let imgDataUrl=null;
const bg=new Image(); const logo=new Image(); logo.crossOrigin='anonymous'; logo.src='https://i.imgur.com/zdJfkpg.png'; logo.onload=()=>requestRender();
let lastWidth = 0, lastHeight = 0; let actionCounter = 0; let isTapCandidate = false; let tapDownX = 0, tapDownY = 0;
const TAP_THRESHOLD = 25; let activeLabelTarget = null; let dragStartPt = null; let isMovingLabel = false;

function initializeAndSizeContext() {
    const r = canvasWrap.getBoundingClientRect();
    const width = r.width; const height = r.height;
    if (width === 0 || height === 0) { requestRender(); return; }
    if (width !== lastWidth || height !== lastHeight) {
        DPR = Math.min(devicePixelRatio || 1, 2);
        cv.width = Math.floor(width * DPR); cv.height = Math.floor(height * DPR);
        lastWidth = width; lastHeight = height;
        if (!ctx) ctx = cv.getContext('2d', {alpha: true});
        if (ctx) ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
        cv.style.width = width + 'px'; cv.style.height = height + 'px';
        requestRender();
    }
    requestRender();
}
function resetView(){
  if(!imgReady) return;
  const r = canvasWrap.getBoundingClientRect();
  const imgW = bg.naturalWidth || bg.width || 1000;
  const imgH = bg.naturalHeight || bg.height || 1000;
  const targetWidth = r.width * 0.9; 
  scale = targetWidth / imgW;
  if(!isFinite(scale) || scale <= 0) scale = 0.1;
  panX = (r.width - imgW * scale) / 2;
  panY = (r.height - imgH * scale) / 2;
  requestRender();
}
document.getElementById('btnFit').onclick=resetView;

const accWrap=document.getElementById('accWrap'); const toolBtn={};
function buildTools(){
  accWrap.innerHTML='';
  cats.forEach(cat=>{
    const acc=document.createElement('div');acc.className='acc';
    const head=document.createElement('div');head.className='accHead';
    head.innerHTML=`<b>${cat.name}</b><i data-lucide="chevron-right"></i>`;
    head.onclick=()=>{
        document.querySelectorAll('.acc.open').forEach(el=>{if(el!==acc)el.classList.remove('open')});
        acc.classList.toggle('open');
    };
    const body=document.createElement('div');body.className='accBody';
    const grid=document.createElement('div');grid.className='grid4';
    cat.list.forEach(k=>{
      const btn=document.createElement('button');btn.className='tool';
      const iconName = iconMap[k] || 'circle';
      const iconHtml = `<i data-lucide="${iconName}"></i>`;
      
      let displayText = pretty[k]||k;
      if(k.startsWith('tree:')) displayText = k.slice(5).split('(')[0].trim();
      else if(k.startsWith('wreath')) displayText = k==='wreath32'?'Wr 32"':'Wr 42"';
      else if (k === 'custom_icon') displayText = 'Image';
      else if (k === 'night_mode') displayText = 'Night';

      btn.innerHTML = `${iconHtml}<span>${displayText}</span>`;
      
      if(k.startsWith('tree:')){
          const t=k.slice(5); btn.onclick=()=>selectTool('tree',t); toolBtn[k]=btn;
      } else if(k.startsWith('wreath')){
          btn.onclick=()=>selectTool('wreath', k==='wreath32'?'32"':'42"'); toolBtn[k]=btn;
      } else if (k === 'custom_icon') {
          btn.onclick=()=>selectTool(k); toolBtn[k]=btn;
      } else if (k === 'night_mode') {
          btn.onclick=()=>toggleNightMode(); toolBtn[k]=btn;
          btn.classList.toggle('toggled', isNightMode); 
          btn.classList.toggle('night-glow', isNightMode);
      } else {
          btn.onclick=()=>selectTool(k); toolBtn[k]=btn;
      }
      grid.appendChild(btn);
    });
    body.appendChild(grid);acc.append(head,body);accWrap.appendChild(acc);
  });
  if(window.lucide) lucide.createIcons();
}

let mode='draw',currLayer='ridges',currTreeKind='Trunk + Branch (Minis)',currWreathSize='32"', currLabelTarget='point'; 
function selectTool(L, variant=null){
    currLayer=L;
    if(L==='tree') currTreeKind=variant;
    else if(L==='wreath') currWreathSize=variant;
    for(const k in toolBtn) toolBtn[k].classList.remove('active');
    if(L==='tree') toolBtn['tree:'+currTreeKind]?.classList.add('active');
    else if(L==='wreath') toolBtn[currWreathSize==='32"'?'wreath32':'wreath42']?.classList.add('active');
    else toolBtn[L]?.classList.add('active');
    if(matchMedia('(max-width:900px)').matches) toggleMenu();
    document.getElementById('imgUploadPop').style.display = 'none';
    mode='draw'; 
    if (L === 'label') mode = 'label'; 
    updateModeTag(); startNewSketch();
    
    if(currLayer === 'garland') {
        document.getElementById('btnSwag').style.display = 'inline-flex';
        document.getElementById('btnPillar').style.display = 'inline-flex'; 
    } else {
        document.getElementById('btnSwag').style.display = 'none';
        document.getElementById('btnPillar').style.display = 'none'; 
        chkPillar.checked = false; btnPillar.classList.remove('toggled');
    }
    redoStack = []; document.getElementById('btnRedo').disabled = true;
}
document.getElementById('btnDraw').onclick=()=>{mode='draw';updateModeTag()};
document.getElementById('btnSelect').onclick=()=>{mode='select';updateModeTag()};
document.getElementById('btnMoveCanvas').onclick=()=>{mode='move-canvas';updateModeTag()};

const quickEditPrefix = document.getElementById('quickEditPrefix');
quickEditPrefix.oninput = (e) => {
    if (selectedItem && selectedItem.obj) {
        selectedItem.obj.label = e.target.value;
        if (selectedItem.type === 'label') selectedItem.obj.text = e.target.value;
        markPowerDirty();
        requestRender();
    }
};
quickEditPrefix.onchange = () => {
    refreshTable();
};

const moveLabelToggleBtn = document.getElementById('moveLabelToggleBtn');
moveLabelToggleBtn.onclick = () => {
    if (mode === 'move-label') {
        mode = 'select';
    } else {
        mode = 'move-label';
    }
    updateModeTag();
};

document.getElementById('quickDeleteBtn').onclick = () => {
    if (selectedItem) {
        deleteItem(selectedItem);
        selectedItem = null;
        updateModeTag();
    }
};

function updateModeTag(){
    const t = document.getElementById('modeTag');
    document.getElementById('btnDraw').classList.remove('toggled');
    document.getElementById('btnSelect').classList.remove('toggled');
    document.getElementById('btnMoveCanvas').classList.remove('toggled'); 
    
    document.getElementById('selectionQuickEdit').style.display = 'none';
    moveLabelToggleBtn.classList.remove('toggled');

    if (mode === 'draw') {
         t.textContent = pretty[currLayer] || 'Draw'; t.style.borderColor = '#64b5ff'; t.style.color = '#64b5ff';
         document.getElementById('btnDraw').classList.add('toggled');
    } else if (mode === 'select' || mode === 'move-label') {
         t.textContent = mode === 'select' ? 'Select' : 'Label Move'; 
         t.style.borderColor = mode === 'select' ? '#fbbf24' : '#3b82f6'; 
         t.style.color = mode === 'select' ? '#fbbf24' : '#3b82f6';
         document.getElementById('btnSelect').classList.add('toggled');
         if (selectedItem) {
             const sqe = document.getElementById('selectionQuickEdit');
             sqe.style.display = 'flex';
             const isLabelable = !['powersource','threeway'].includes(selectedItem.type);
             document.getElementById('editLabelPrefix').style.display = isLabelable ? 'inline' : 'none';
             quickEditPrefix.style.display = isLabelable ? 'inline' : 'none';
             moveLabelToggleBtn.style.display = isLabelable ? 'inline-flex' : 'none';
             if (isLabelable) quickEditPrefix.value = selectedItem.obj.label || '';
             if (mode === 'move-label') moveLabelToggleBtn.classList.add('toggled');
         }
    } else if (mode === 'label') {
         t.textContent = 'Label'; t.style.borderColor = '#22c55e'; t.style.color = '#22c55e';
    } else if (mode === 'move-canvas') { 
         t.textContent = 'Pan'; t.style.borderColor = '#f87171'; t.style.color = '#f87171';
         document.getElementById('btnMoveCanvas').classList.add('toggled');
    } else if (mode === 'move') {
         t.textContent = 'Move'; t.style.borderColor = '#ff3b3b'; t.style.color = '#ff3b3b';
    }
    
    updateLineScaleUI(); updateIconScaleUI(); updateJunctionScaleUI(); updateLabelScaleUI(); updateArrowScaleUI();
    requestRender();
}

let powerGraph = null, powerDirty = true;
function markPowerDirty(){ powerDirty = true; }
function analyzePower(){
  if(!powerDirty && powerGraph) return powerGraph;
  const nodes = []; const edges = []; const TOL_SQR = 0.5 * 0.5;
  function getId(p){
    for(let i=0; i<nodes.length; i++){
      const dx = nodes[i].x - p.x; const dy = nodes[i].y - p.y;
      if(dx*dx + dy*dy < TOL_SQR) return i;
    }
    return nodes.push({x:p.x, y:p.y, dist:Infinity, adj:[], type: null}) - 1;
  }
  const singlePathLayers = ['groundstakes']; const singlePathEdges = new Map(); 
  const lineLayers = ['ridges','fascia','peaks','groundstakes','garland','cords','shrub','windows'];
  const decorationLayers = ['powersource', 'threeway', 'wreath', 'tree', 'bow', 'custom_icon'];

  decorationLayers.forEach(L => { if(data[L]) data[L].forEach(it => { if(it.pt) getId(it.pt); }); });
  lineLayers.forEach(L => { if(data[L]) data[L].forEach(it => { if(it.points) it.points.forEach(p => getId(p)); }); });
  
  lineLayers.forEach(L => {
    if(!data[L]) return;
    data[L].forEach(it => {
       if(!it.points || it.points.length < 2) return;
       for(let i=0; i<it.points.length-1; i++){
          const p1 = it.points[i];
          const p2 = it.points[i+1];
          const u = getId(p1);
          const v = getId(p2);
          
          let midNodes = [];
          for(let k=0; k<nodes.length; k++){
              if(k === u || k === v) continue;
              const node = nodes[k];
              const proj = projOnSeg(node, p1, p2);
              if(proj.t > 0.01 && proj.t < 0.99) {
                  const d = Math.hypot(node.x - proj.q.x, node.y - proj.q.y);
                  if(d < 0.8) midNodes.push({ id: k, t: proj.t });
              }
          }
          midNodes.sort((a,b) => a.t - b.t);
          
          let lastNode = u;
          [...midNodes, {id: v}].forEach(step => {
              const edge = {u: lastNode, v: step.id, type:L, cps:(it.cps?.[i] || null), index: i, line: it};
              edges.push(edge);
              nodes[lastNode].adj.push(step.id);
              nodes[step.id].adj.push(lastNode);
              lastNode = step.id;
          });

          if (singlePathLayers.includes(L)) {
              const cp = it.cps ? it.cps[i] : null;
              const len = segmentLength(p1, p2, cp);
              if(!singlePathEdges.has(it)) singlePathEdges.set(it, { totalLength: 0, segments: [] });
              const info = singlePathEdges.get(it);
              info.segments.push({ u, v, length: len, startDist: info.totalLength, edgeRef: {u,v,type:L,line:it,index:i,cps:cp} });
              info.totalLength += len;
          }
       }
    });
  });
  
  const queue = [];
  data.powersource.forEach(ps => { const id = getId(ps.pt); if(nodes[id]){ nodes[id].dist = 0; queue.push(id); } });
  let head = 0;
  while(head < queue.length){
    const u = queue[head++]; const d = nodes[u].dist + 1;
    nodes[u].adj.forEach(v => { if(nodes[v].dist === Infinity){ nodes[v].dist = d; queue.push(v); } });
  }
  const deadTips = [];
  nodes.forEach((n, i)=>{ 
    if(n.dist !== Infinity && n.dist > 0 && n.adj.length === 1){ 
      const worldPos = {x:n.x, y:n.y}; let isDecoration = false;
      ['wreath', 'tree', 'bow', 'custom_icon'].forEach(L => {
        data[L].forEach(item => { if (item.pt && Math.hypot(item.pt.x - worldPos.x, item.pt.y - worldPos.y) < TOL_SQR) isDecoration = true; });
      });
      deadTips.push(i); 
    } 
  });
  const singleArrowEdges = [];
  singlePathEdges.forEach((pathInfo, line) => {
      const totalLength = pathInfo.totalLength; if (totalLength < 0.1) return;
      const uFirst = getId(line.points[0]);
      const vLast = getId(line.points[line.points.length-1]);
      if (nodes[uFirst].dist === Infinity && nodes[vLast].dist === Infinity) return;
      
      const targetDist = totalLength * 0.5; let bestSegment = null;
      for (const seg of pathInfo.segments) { if (targetDist >= seg.startDist && targetDist <= (seg.startDist + seg.length)) { bestSegment = seg; break; } }
      if (bestSegment) {
          const edge = bestSegment.edgeRef; const distInSegment = targetDist - bestSegment.startDist;
          const uNode = nodes[bestSegment.u]; const vNode = nodes[bestSegment.v];
          let isReversed = uNode.dist > vNode.dist;
          singleArrowEdges.push({ edge: edge, distInSegment: distInSegment, isReversed: isReversed });
      }
  });
  powerGraph = {nodes, edges, deadTips, singleArrowEdges}; powerDirty = false; return powerGraph;
}
function projOnSeg(p,a,b){ const ABx=b.x-a.x, ABy=b.y-a.y; const d=ABx*ABx+ABy*ABy||1; const t=((p.x-a.x)*ABx+(p.y-a.y)*ABy)/d; return{t,q:{x:a.x+ABx*t,y:a.y+ABy*t}}; }
function nextIndex(prefix){const re=new RegExp('^'+prefix+'(\\d+)$','i');const used=new Set();for(const L in data){for(const it of data[L]){const m=(it.label||'').match(re);if(m)used.add(+m[1])}}let i=1;while(used.has(i))i++;return i}

function getSnapLineOnly(wx, wy, thresholdW){
    let best = null; let minD = thresholdW; const p = {x:wx, y:wy};
    ['ridges','fascia','peaks','groundstakes','garland','shrub','windows'].forEach(L=>{
        data[L].forEach(line=>{
            for(let i=0; i<line.points.length-1; i++){
                const a=line.points[i]; const b=line.points[i+1]; const proj=projOnSeg(p,a,b); const d=Math.hypot(p.x-proj.q.x, p.y-proj.q.y);
                if(d<minD){ minD=d; best={x:proj.q.x, y:proj.q.y, type:'mid', host:line, seg:i}; }
            }
        });
    });
    return best;
}

function getSnap(sx, sy, thresholdS, excludeObj = null){
    const w=toWorld(sx, sy); const thresholdW=thresholdS/scale; let best=null; let minD=thresholdW; const p = w;
    ['ridges','fascia','peaks','groundstakes','garland','cords','shrub','windows'].forEach(L=>{
        data[L].forEach(line=>{ 
            if(line === excludeObj) return;
            if(line.points.length>0){ [line.points[0], line.points[line.points.length-1]].forEach(pt=>{ const d=Math.hypot(p.x-pt.x, p.y-pt.y); if(d<minD){ minD=d; best={x:pt.x, y:pt.y, type:'end', host:line}; } }); } 
        });
    });
    ['powersource','threeway','wreath','bow','tree', 'custom_icon'].forEach(L=>{
        data[L].forEach(it=>{ 
            if(it === excludeObj) return;
            if(it.pt){ const d=Math.hypot(p.x-it.pt.x, p.y-it.pt.y); if(d<minD){ minD=d; best={x:it.pt.x, y:it.pt.y, type:'junction', host:it}; } } 
        });
    });
    if(!best){
        minD = thresholdW;
        ['ridges','fascia','peaks','groundstakes','garland','shrub','windows'].forEach(L=>{
            data[L].forEach(line=>{
                if(line === excludeObj) return;
                for(let i=0; i<line.points.length-1; i++){
                    const a=line.points[i]; const b=line.points[i+1]; const proj=projOnSeg(p,a,b);
                    if(proj.t>=0 && proj.t<=1 && Math.hypot(p.x-proj.q.x, p.y-proj.q.y)<minD){ minD=Math.hypot(p.x-proj.q.x, p.y-proj.q.y); best={x:proj.q.x, y:proj.q.y, type:'proj', host:line, seg:i}; }
                }
            });
        });
    }
    return best;
}

function countConnections(junction) {
    let count = 0; const junctionWorld = junction.pt; const TOL_SQR = 0.5 * 0.5;
    ['ridges', 'fascia', 'peaks', 'groundstakes', 'garland', 'cords', 'shrub', 'windows'].forEach(L => {
        data[L].forEach(line => {
            if (line.points.length > 0) {
                if (Math.hypot(line.points[0].x - junctionWorld.x, line.points[0].y - junctionWorld.y) < TOL_SQR) count++;
                const end = line.points[line.points.length - 1];
                if (line.points.length > 1 && Math.hypot(end.x - junctionWorld.x, end.y - junctionWorld.y) < TOL_SQR) count++;
            }
        });
    });
    return count;
}
function find3WayAt(pt) { const TOL_SQR = 0.5 * 0.5; for(const tw of data.threeway){ if(Math.hypot(tw.pt.x - pt.x, tw.pt.y - pt.y) < TOL_SQR) return tw; } return null; }

let pendingCustomIcon = null;
function placeCustomIcon(w, sx, sy, label, index) {
    pendingCustomIcon = { pt: w, label: label, index: index, kind: 'custom_icon', tempX: sx, tempY: sy };
    const popEl = document.getElementById('imgUploadPop');
    popEl.style.left = sx + 'px'; popEl.style.top = sy + 'px'; popEl.style.transform = 'translate(-50%, -100%)'; popEl.style.display = 'flex';
}

function placeItem(L, w, sx, sy){
    let item; const {label, index} = getNewItemData(L);
    if(L==='tree') { placeTree(L, w, sx, sy, label, index); return; } 
    else if(L==='wreath') { placeWreath(L, w, sx, sy, label, index); return; } 
    else if(L==='custom_icon') { placeCustomIcon(w, sx, sy, label, index); return; }
    item = {pt:w, label:label, index:index, kind: L};
    data[L].push(item); markPowerDirty(); requestRender(); refreshTable();
}

function placeTree(L, w, sx, sy, label, index) {
    if (currTreeKind === 'ToL') {
        openPop(document.getElementById('tolPop'), sx, sy, (size) => {
            const item = {pt:w, label:label, index:index, kind: currTreeKind, size: parseInt(size), ft: size};
            data[L].push(item); markPowerDirty(); requestRender(); refreshTable();
        });
    } else {
        const item = {pt:w, label:label, index:index, kind: currTreeKind};
        data[L].push(item); markPowerDirty(); requestRender(); refreshTable();
    }
}
function placeWreath(L, w, sx, sy, label, index) {
    openPop(document.getElementById('wreathPop'), sx, sy, (bow) => {
        const item = {pt:w, label:label, index:index, size: currWreathSize, bow: bow};
        data[L].push(item); markPowerDirty(); requestRender(); refreshTable();
    });
}

function completeSketch() {
    if (!sketch || sketch.points.length < 2) return;
    data[sketch.layer].push(sketch); 
    sketch = null; document.getElementById('btnComplete').disabled = true; startNewSketch(); 
    markPowerDirty(); refreshTable(); requestRender(); 
}

let pointers=new Map(),gesture=false,gMid=null,gScale=1,gPanX=0,gPanY=0,gDist=0;
function mp(a,b){return{x:(a.x+b.x)/2,y:(a.y+b.y)/2}}
function ds(a,b){return Math.hypot(a.x-b.x,a.y-b.y)}
const toWorld=(sx,sy)=>({x:(sx-panX)/scale,y:(sy-panY)/scale});
const toScr=p=>({x:p.x*scale+panX,y:p.y*scale+panY});

let selectedItem = null, draggingPoint = null;
let currentSnapLine = null; let draggedLabelTarget = null;
let dragStartX=0, dragStartY=0, dragPanStartX=0, dragPanStartY=0;

cv.addEventListener('pointerdown',e=>{
    cv.setPointerCapture(e.pointerId); const r=canvasWrap.getBoundingClientRect(); const ex = e.clientX-r.left, ey = e.clientY-r.top;
    pointers.set(e.pointerId,{x:ex,y:ey,id:e.pointerId});
    
    if (!e.target.closest('#lblEditor')) {
        document.getElementById('lblEditor').style.display = 'none';
    }
    document.getElementById('imgUploadPop').style.display = 'none';

    if(pointers.size === 1) {
        isTapCandidate = true; tapDownX = ex; tapDownY = ey; dragStartX = ex; dragStartY = ey; dragPanStartX = panX; dragPanStartY = panY;
        
        if (mode === 'select' && selectedItem) {
            handleSelectDown(ex, ey); 
            if (draggingPoint) {
                isTapCandidate = false;
                return;
            }
        }

        if (mode === 'move' && selectedItem) {
             dragStartPt = { x: selectedItem.obj.pt ? selectedItem.obj.pt.x : (selectedItem.obj.points ? getItemCenter(selectedItem.obj).x : 0),
                             y: selectedItem.obj.pt ? selectedItem.obj.pt.y : (selectedItem.obj.points ? getItemCenter(selectedItem.obj).y : 0) };
             return;
        } else if (mode === 'move-label' && selectedItem) { 
             const w = toWorld(ex, ey);
             draggedLabelTarget = { item: selectedItem.obj, type: 'primary' };
             isTapCandidate = false;
             return;
        }
    }
    if(pointers.size >= 2){
        isTapCandidate = false; gesture=true; const v=[...pointers.values()];
        gDist=ds(v[0],v[1]); gMid=mp(v[0],v[1]); gScale=scale; gPanX=panX; gPanY=panY; return;
    }
});

function attemptHeal(pt) {
    const lineLayers = ['ridges','fascia','peaks','groundstakes','garland','cords','shrub','windows'];
    let candidates = [];
    lineLayers.forEach(L => {
        data[L].forEach(line => {
            if(line.points) {
                const pStart = line.points[0]; const pEnd = line.points[line.points.length-1];
                if(Math.hypot(pStart.x-pt.x, pStart.y-pt.y) < 0.1) candidates.push({line, L, end:'start'});
                else if(Math.hypot(pEnd.x-pt.x, pEnd.y-pt.y) < 0.1) candidates.push({line, L, end:'end'});
            }
        });
    });
    if(candidates.length === 2 && candidates[0].L === candidates[1].L) {
        const A = candidates[0].line; const B = candidates[1].line;
        if (!A.isSplit || !B.isSplit) return; 
        if(candidates[0].end === 'end' && candidates[1].end === 'start') mergeLines(candidates[0].L, A, B);
        else if (candidates[1].end === 'end' && candidates[0].end === 'start') mergeLines(candidates[0].L, B, A);
    }
}
function mergeLines(L, keepLine, mergeLine) {
    const newPoints = keepLine.points.concat(mergeLine.points.slice(1));
    const newCps = (keepLine.cps || []).concat(mergeLine.cps || []);
    keepLine.points = newPoints; keepLine.cps = newCps;
    const idx = data[L].indexOf(mergeLine);
    if(idx > -1) data[L].splice(idx, 1);
    refreshTable(); markPowerDirty();
}

cv.addEventListener('pointermove',e=>{
    const r=canvasWrap.getBoundingClientRect(); const x=e.clientX-r.left, y=e.clientY-r.top;
    if(pointers.has(e.pointerId)) pointers.set(e.pointerId,{x,y,id:e.pointerId});
    cv._mx=x; cv._my=y;
    if(gesture && pointers.size>=2){
        const v=[...pointers.values()];
        const currDist=ds(v[0],v[1]); const currMid=mp(v[0],v[1]);
        if(gDist>0){
            const nz = Math.max(0.1, Math.min(10, gScale * (currDist/gDist)));
            const worldMid = {x:(gMid.x-gPanX)/gScale, y:(gMid.y-gPanY)/gScale};
            scale = nz; panX = currMid.x - worldMid.x*scale; panY = currMid.y - worldMid.y*scale; requestRender();
        }
        return;
    }
    
    if(mode === 'select' && draggingPoint){
        const w = toWorld(x, y); currentSnapLine = null; 
        if (draggingPoint.index === -1 && (draggingPoint.type === 'powersource' || draggingPoint.type === 'threeway' || draggingPoint.type === 'wreath' || draggingPoint.type === 'bow' || draggingPoint.type === 'tree' || draggingPoint.type === 'label')) {
             if (draggingPoint.type === 'label') {
                 draggingPoint.obj.pt = w;
             } else {
                 const snap = getSnapLineOnly(w.x, w.y, 25 / scale); 
                 if (snap) { draggingPoint.obj.pt = {x: snap.x, y: snap.y}; if(snap.type === 'mid') currentSnapLine = snap; } 
                 else { draggingPoint.obj.pt = w; }
             }
        } else if (draggingPoint.type === 'custom_icon') {
            const ci = draggingPoint.obj;
            if (draggingPoint.handle === 'move' || draggingPoint.index === -1) { ci.pt.x = w.x; ci.pt.y = w.y; } 
            else if (draggingPoint.handle === 'scale' || draggingPoint.index === -2) {
                 const tlW = ci.pt; const newWorldW = w.x - tlW.x;
                 if (newWorldW > 0.05) { const newScale = newWorldW / ci.w; ci.scale = newScale; }
            }
        } else {
            let snap = getSnap(x, y, 25, draggingPoint.obj); 
            const ptVal = snap ? {x:snap.x, y:snap.y} : w;
            if (draggingPoint.index === -1 && draggingPoint.obj.pt) draggingPoint.obj.pt = ptVal;
            else if (draggingPoint.obj.points) draggingPoint.obj.points[draggingPoint.index] = ptVal;
        }
        markPowerDirty(); requestRender(); return;
    } else if (mode === 'move' && selectedItem && dragStartPt) {
        const w = toWorld(x, y); const wStart = toWorld(dragStartX, dragStartY); const dx = w.x - wStart.x; const dy = w.y - wStart.y;
        const obj = selectedItem.obj;
        if (obj.pt) { obj.pt.x = dragStartPt.x + dx; obj.pt.y = dragStartPt.y + dy; } 
        else if (obj.points) {
            obj.points.forEach(p => { p.x += dx; p.y += dy; });
            dragStartX = x; dragStartY = y; dragStartPt.x = obj.points[0].x; dragStartPt.y = obj.points[0].y; 
            if (obj.cps) obj.cps.forEach(cp => { if (cp) { cp.x += dx; cp.y += dy; } });
        }
        markPowerDirty(); requestRender(); return;
    } else if (mode === 'move-label' && draggedLabelTarget) {
        const w = toWorld(x, y); 
        const obj = draggedLabelTarget.item; 
        if (draggedLabelTarget.type === 'primary') {
            obj.customLabelPos = { x: w.x, y: w.y };
        } else if (draggedLabelTarget.type === 'point') { 
            if(!obj.ptLabelPos) obj.ptLabelPos = {}; obj.ptLabelPos[draggedLabelTarget.index] = {x: w.x, y: w.y}; 
        } else if (draggedLabelTarget.type === 'seg') { 
            if(!obj.segLabelPos) obj.segLabelPos = {}; obj.segLabelPos[draggedLabelTarget.index] = {x: w.x, y: w.y}; 
        } else if (draggedLabelTarget.type === 'simple') { 
            obj.pt.x = w.x; obj.pt.y = w.y; 
        }
        requestRender(); return;
    }

    if (pointers.size === 1) {
        const dx = x - dragStartX; const dy = y - dragStartY;
        if (Math.hypot(dx, dy) > TAP_THRESHOLD) {
            isTapCandidate = false;
            panX = dragPanStartX + dx; 
            panY = dragPanStartY + dy; 
            requestRender();
        }
    }
    requestRender();
});

cv.addEventListener('pointerup',e=>{
    const wasGesture = gesture;
    if (pointers.size === 1 && !wasGesture) { 
        if (draggingPoint) {
            draggingPoint = null; 
            markPowerDirty(); 
            requestRender();
            refreshTable();
        } 
    }
    if (mode === 'move' && dragStartPt) dragStartPt = null;
    if (mode === 'move-label' && draggedLabelTarget) draggedLabelTarget = null;
    
    if (!wasGesture && pointers.size === 1 && isTapCandidate) {
        const r=canvasWrap.getBoundingClientRect(); 
        const ex = e.clientX-r.left, ey = e.clientY-r.top;
        if (mode === 'draw') handleTap(ex, ey);
        else if (mode === 'label') checkCordLabelClick(ex, ey);
        else if (mode === 'select' || mode === 'move' || mode === 'move-label') handleSelectDown(ex, ey);
    }

    pointers.delete(e.pointerId);
    if (wasGesture) { dragStartX = cv._mx; dragStartY = cv._my; dragPanStartX = panX; dragPanStartY = panY; isTapCandidate = false; }
    if(pointers.size<2) gesture=false;
});

const iconFile = document.getElementById('iconFile'); const imgUploadPop = document.getElementById('imgUploadPop');
const cancelIconUpload = document.getElementById('cancelIconUpload');
cancelIconUpload.onclick = () => { imgUploadPop.style.display = 'none'; pendingCustomIcon = null; iconFile.value = ''; requestRender(); }
iconFile.onchange = (e) => {
    const file = e.target.files[0]; if (!file || !pendingCustomIcon) { imgUploadPop.style.display = 'none'; pendingCustomIcon = null; return; }
    const reader = new FileReader();
    reader.onload = (event) => {
        const img = new Image();
        img.onload = () => {
            const iconData = pendingCustomIcon; iconData.url = event.target.result;
            iconData.w = img.naturalWidth || 100; iconData.h = img.naturalHeight || 100; iconData.scale = 0.15; iconData.imageObj = img; 
            data.custom_icon.push(iconData); pendingCustomIcon = null; imgUploadPop.style.display = 'none'; iconFile.value = ''; 
            selectedItem = { type: 'custom_icon', obj: iconData }; markPowerDirty(); requestRender(); refreshTable();
        };
        img.onerror = () => { showAlert("Failed to load image"); pendingCustomIcon = null; imgUploadPop.style.display = 'none'; };
        img.src = event.target.result;
    };
    reader.readAsDataURL(file);
}

function checkCordLabelClick(sx, sy) {
    const w = toWorld(sx, sy);
    for (const item of data.label) { const s = toScr(item.pt); if(Math.hypot(s.x - sx, s.y - sy) < 40) { showLabelEditor({ item: item, type: 'simple', index: -1, x: sx, y: sy }); return; } }
    let best = checkLabelClick(sx, sy); if (best) { showLabelEditor(best); return; }
    const {label, index} = getNewItemData('label');
    if (!data.label) data.label = []; 
    const newItem = {pt: w, label: label, index: index, text: ''};
    data.label.push(newItem);
    showLabelEditor({ item: newItem, type: 'simple', index: -1, x: sx, y: sy });
}

function checkLabelClick(sx, sy, specificItem=null, specificType=null) {
    const w = toWorld(sx, sy); let best = null;
    const search = (item, L) => {
        if (item.points) {
            if(item.ptLabels) {
                Object.keys(item.ptLabels).forEach(idx => {
                    const i = parseInt(idx);
                    const labelPos = item.ptLabelPos && item.ptLabelPos[i] ? item.ptLabelPos[i] : item.points[i];
                    const sc = toScr(labelPos);
                    if(Math.hypot(sc.x - sx, sc.y - sy) < 30) {
                        if (!best || Math.hypot(sc.x - sx, sc.y - sy) < best.d) best = { item: item, type: 'point', index: i, x: sc.x, y: sc.y, L, d: Math.hypot(sc.x - sx, sc.y - sy) };
                    }
                });
            }
            if(item.segLabels) {
                Object.keys(item.segLabels).forEach(idx => {
                    const i = parseInt(idx);
                    let labelPos;
                    if (item.segLabelPos && item.segLabelPos[i]) labelPos = item.segLabelPos[i];
                    else labelPos = getPolylineMidpoint([item.points[i], item.points[i+1]]);
                    const sc = toScr(labelPos);
                    if(Math.hypot(sc.x - sx, sc.y - sy) < 30) {
                        if (!best || Math.hypot(sc.x - sx, sc.y - sy) < best.d) best = { item: item, type: 'point', index: i, x: sc.x, y: sc.y, L, d: Math.hypot(sc.x - sx, sc.y - sy) };
                        if (!best || Math.hypot(sc.x - sx, sc.y - sy) < best.d) best = { item: item, type: 'seg', index: i, x: sc.x, y: sc.y, L, d: Math.hypot(sc.x - sx, sc.y - sy) };
                    }
                });
            }
        }
    }
    if (specificItem) search(specificItem, specificType);
    else Object.keys(data).forEach(L => { if (L === 'label') return; data[L].forEach(item => search(item, L)); });
    return best;
}

function showLabelEditor(target) {
    activeLabelTarget = target; 
    const el = document.getElementById('lblEditor'); 
    const inp = document.getElementById('lblInput'); 
    let val = '';
    
    let worldPos;
    if (target.type === 'simple') worldPos = target.item.pt;
    else if (target.type === 'point') worldPos = target.item.ptLabelPos && target.item.ptLabelPos[target.index] ? target.item.ptLabelPos[target.index] : target.item.points[target.index];
    else if (target.type === 'seg') worldPos = target.item.segLabelPos && target.item.segLabelPos[target.index] ? target.item.segLabelPos[target.index] : getPolylineMidpoint([target.item.points[target.index], target.item.points[target.index+1]]);
    
    const s = toScr(worldPos);
    if (target.type === 'point') { 
        if(!target.item.ptLabels) target.item.ptLabels = {}; 
        val = target.item.ptLabels[target.index] || ''; 
        inp.placeholder = 'Point Note'; 
    } 
    else if (target.type === 'seg') { 
        if(!target.item.segLabels) target.item.segLabels = {}; 
        val = target.item.segLabels[target.index] || ''; 
        inp.placeholder = 'Line Note'; 
    } 
    else if (target.type === 'simple') { 
        val = target.item.text || ''; 
        inp.placeholder = 'Label Text'; 
    }
    
    inp.value = val; 
    el.style.left = s.x + 'px'; 
    el.style.top = s.y + 'px'; 
    el.style.display = 'block'; 
    
    setTimeout(() => {
        inp.focus();
        inp.select();
    }, 50);
}

document.getElementById('lblInput').onchange = (e) => {
    if(!activeLabelTarget) return; 
    const val = e.target.value; 
    const item = activeLabelTarget.item;
    if(activeLabelTarget.type === 'point') { item.ptLabels[activeLabelTarget.index] = val; } 
    else if (activeLabelTarget.type === 'seg') { item.segLabels[activeLabelTarget.index] = val; } 
    else if (activeLabelTarget.type === 'simple') { 
        item.text = val; 
        if (val === '') { 
            const idx = data.label.indexOf(item); 
            if(idx > -1) data.label.splice(idx, 1); 
        } 
    }
    document.getElementById('lblEditor').style.display = 'none'; requestRender();
};

document.getElementById('lblInput').addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
        document.getElementById('lblInput').onchange({target: e.target});
    }
});

document.getElementById('lblInput').onblur = (e) => {
    setTimeout(() => {
        if (activeLabelTarget && activeLabelTarget.type === 'simple' && (!activeLabelTarget.item.text || activeLabelTarget.item.text.trim() === '')) {
            const idx = data.label.indexOf(activeLabelTarget.item);
            if (idx > -1) data.label.splice(idx, 1);
            requestRender();
        }
    }, 150);
};

cv.addEventListener('wheel',e=>{
    e.preventDefault(); const r=canvasWrap.getBoundingClientRect(); const mx=e.clientX-r.left, my=e.clientY-r.top;
    const w=toWorld(mx,my); const f = e.deltaY<0 ? 1.1 : 0.9; const nz = Math.max(0.1, Math.min(10, scale*f));
    panX = mx - w.x*nz; panY = my - w.y*nz; scale=nz; requestRender();
},{passive:false});

let redoStack = [];
function getNewItemData(L){
    actionCounter++; const p = pfx[L] || 'L'; let label = '';
    if (L === 'wreath' || L === 'wreath32' || L === 'wreath42') { 
        const pWreath = 'WR'; const indexWreath = nextIndex(pWreath); label = pWreath + indexWreath; 
    } 
    else if (L === 'label') { label = pfx.label + nextIndex(pfx.label); } 
    else { label = (L==='cords'||L==='threeway'||L==='powersource'||L==='bow' || L==='custom_icon') ? '' : p + nextIndex(p); }
    return {label, index: actionCounter};
}

document.getElementById('btnUndo').onclick=()=>{
    if (sketch && sketch.points.length > 0) {
        sketch.points.pop(); 
        if (sketch.cps) sketch.cps.pop(); 
        const canComplete = sketch.points.length >= 2;
        document.getElementById('btnComplete').disabled = !canComplete;
        if (canComplete) document.getElementById('btnComplete').classList.add('selectable');
        else document.getElementById('btnComplete').classList.remove('selectable');
        markPowerDirty(); requestRender(); return;
    }
    let maxIndex = -1; let targetObj = null; let targetLayer = null; let targetIdxInArray = -1;
    for (const L in data) {
        if (!data[L]) continue; data[L].forEach((item, idx) => { if (item.index > maxIndex) { maxIndex = item.index; targetObj = item; targetLayer = L; targetIdxInArray = idx; } });
    }
    if (targetObj && targetLayer) {
        redoStack.push({layer: targetLayer, item: targetObj}); document.getElementById('btnRedo').disabled = false;
        data[targetLayer].splice(targetIdxInArray, 1); markPowerDirty(); requestRender(); refreshTable();
    }
};
document.getElementById('btnRedo').onclick = () => {
    if(redoStack.length === 0) return; const record = redoStack.pop(); if(redoStack.length === 0) document.getElementById('btnRedo').disabled = true;
    if (record.layer === 'custom_icon' && record.item.url) { const img = new Image(); img.src = record.item.url; record.item.imageObj = img; }
    data[record.layer].push(record.item); markPowerDirty(); requestRender(); refreshTable();
};

let sketch=null; 
function startNewSketch(){
    const d = getNewItemData(currLayer);
    sketch={points:[],cps:[],layer:currLayer,label:d.label, index: d.index, firstHost:null, isPillarMode: chkPillar.checked}; 
    document.getElementById('btnComplete').disabled=true;
    document.getElementById('btnComplete').classList.remove('selectable');
}
document.getElementById('btnComplete').onclick = completeSketch;

function handleTap(sx,sy){
    if(!imgReady || mode!=='draw' || draggingPoint) return;
    const w=toWorld(sx,sy); redoStack = []; document.getElementById('btnRedo').disabled = true;

    if(['powersource','threeway','tree','wreath','bow', 'custom_icon'].includes(currLayer)){ placeItem(currLayer, w, sx, sy); return; }
    if(!sketch) startNewSketch();
    let pt = w; 
    if(chkSnap.checked){
        const sn = getSnap(sx,sy,25); 
        if(sn) {
            pt = {x:sn.x, y:sn.y}; if(sketch.points.length===0) sketch.firstHost = sn.host;
            if(sn.host && data.threeway.includes(sn.host)){ if(countConnections(sn.host) >= 4){ showAlert("3-Way limit reached."); if(sketch.points.length === 0) return; } }
        }
    }
    if(sketch.points.length > 0 && pt) {
        const dest3Way = find3WayAt(pt); if(dest3Way) { if(countConnections(dest3Way) >= 4){ showAlert("Destination 3-Way limit reached."); return; } }
    }
    sketch.points.push(pt);
    if(['garland','groundstakes','cords'].includes(currLayer)) {
        if(sketch.points.length > 1) {
            const p1 = sketch.points[sketch.points.length - 2]; const p2 = sketch.points[sketch.points.length - 1];
            if(chkSwag.checked && currLayer === 'garland') {
                const mx = (p1.x + p2.x) / 2; const my = (p1.y + p2.y) / 2; const dist = Math.hypot(p2.x - p1.x, p2.y - p1.y);
                sketch.cps.push({x: mx, y: my + (dist * 0.2)}); 
            } else { if (!sketch.cps) sketch.cps = []; sketch.cps.push(null); }
        }
    }

    const canComplete = sketch.points.length >= 2;
    document.getElementById('btnComplete').disabled = !canComplete;
    if (canComplete) document.getElementById('btnComplete').classList.add('selectable');
    else document.getElementById('btnComplete').classList.remove('selectable');
    markPowerDirty(); requestRender();
}

function handleSelectDown(sx, sy){
    isMovingLabel = false;
    let hitPoint = null; let bestPointDist = 45; 

    const searchPoints = (list, type, overrideHitbox=30) => {
        list.forEach((obj, i) => {
            const currentHitbox = (type === 'threeway' || type === 'powersource') ? 45 : overrideHitbox; 
            if (obj.points) {
                obj.points.forEach((p, index) => {
                    const d = Math.hypot(sx - toScr(p).x, sy - toScr(p).y);
                    if (d < currentHitbox) { if (!hitPoint || d < hitPoint.d) hitPoint = { obj, index, type, d: d }; }
                });
            } else if (obj.pt) {
                const scaleFactor = (type === 'threeway' || type === 'powersource') ? settings.junctionScale : settings.iconScale;
                const scaledHitbox = (type === 'label') ? 40 : 30 * scaleFactor; 
                const d = Math.hypot(sx - toScr(obj.pt).x, sy - toScr(obj.pt).y);
                if (d < scaledHitbox) { if (!hitPoint || d < hitPoint.d) hitPoint = { obj, index: -1, type, d: d }; }
            }
        });
    };

    if (selectedItem && selectedItem.obj) {
        searchPoints([selectedItem.obj], selectedItem.type, 50); 
    }

    if (!hitPoint) {
        Object.keys(data).forEach(k => searchPoints(data[k], k, bestPointDist)); 
    }

    let isCustomIconHandleDrag = false;
    data.custom_icon.forEach(ci => {
        const sTL = toScr(ci.pt); const scaledW = ci.w * ci.scale * scale; const scaledH = ci.h * ci.scale * scale;
        const handles = [ { pos: sTL, handle: 'move' }, { pos: {x: sTL.x + scaledW, y: sTL.y + scaledH}, handle: 'scale' } ];
        for (const { pos, handle } of handles) {
            const d = Math.hypot(sx - pos.x, sy - pos.y);
            if (d < 30) { draggingPoint = { obj: ci, index: (handle === 'scale') ? -2 : -1, type: 'custom_icon', d: d, handle: handle }; isCustomIconHandleDrag = true; break; }
        }
        if(isCustomIconHandleDrag) return;
    });

    if (isCustomIconHandleDrag) { selectedItem = { type: 'custom_icon', obj: draggingPoint.obj }; updateModeTag(); requestRender(); return; }
    if (hitPoint) { 
        draggingPoint = hitPoint; 
        selectedItem = { type: hitPoint.type, obj: hitPoint.obj }; 
        updateModeTag(); 
        requestRender(); 
        return; 
    }

    let bestObject = null; let bestObjectDist = 30; const w = toWorld(sx, sy);
    const searchObjects = (list, type) => {
        list.forEach(obj => {
            if (obj.points) {
                for (let i = 0; i < obj.points.length - 1; i++) {
                    const p = projOnSeg(w, obj.points[i], obj.points[i + 1]); const s = toScr(p.q); const d = Math.hypot(sx - s.x, sy - s.y);
                    if (p.t >= 0 && p.t <= 1 && d < bestObjectDist) { bestObjectDist = d; bestObject = { type, obj }; }
                }
            } else if (obj.pt) {
                 const d = Math.hypot(sx - toScr(obj.pt).x, sy - toScr(obj.pt).y);
                 if (d < bestObjectDist) { bestObjectDist = d; bestObject = { type, obj }; }
            }
        });
    };
    Object.keys(data).forEach(k => searchObjects(data[k], k));
    if (bestObject) {
        selectedItem = bestObject;
        if (mode === 'move-label') mode = 'select'; // Switch back if we clicked a new object
        updateModeTag();
    } else { selectedItem = null; mode = 'select'; updateModeTag(); }
    requestRender();
}

function getItemCenter(obj){
    if(obj.pt) { if (obj.kind === 'custom_icon') { const scaledW = obj.w * obj.scale; const scaledH = obj.h * obj.scale; return { x: obj.pt.x + scaledW / 2, y: obj.pt.y + scaledH / 2 }; } return obj.pt; }
    if(obj.points){ let sx=0, sy=0; obj.points.forEach(p=>{sx+=p.x; sy+=p.y}); return {x:sx/obj.points.length, y:sy/obj.points.length}; } return {x:0,y:0};
}
function deleteItem(sel){
    const arr = data[sel.type]; const idx = arr.indexOf(sel.obj); if(idx > -1) arr.splice(idx, 1);
    markPowerDirty(); refreshTable(); redoStack = []; document.getElementById('btnRedo').disabled = true;
}

function openPop(el, x, y, cb){
    el.style.display='flex'; el.style.left = '50%'; el.style.top = '50%'; el.style.transform = 'translate(-50%, -50%)';
    const h = e=>{ const v = e.target.dataset.bow || e.target.dataset.size; if(v){ cb(v); el.style.display='none'; el.removeEventListener('click',h); } }
    el.addEventListener('click',h);
}

function getPolylineMidpoint(points){
    if(points.length < 2) return points[0];
    let totalDist = 0; const segs = [];
    for(let i=0; i<points.length-1; i++){ const d = Math.hypot(points[i+1].x - points[i].x, points[i+1].y - points[i].y); totalDist += d; segs.push(d); }
    let target = totalDist / 2;
    for(let i=0; i<segs.length; i++){
        if(target <= segs[i]){ const t = target / segs[i]; return { x: points[i].x + (points[i+1].x - points[i].x) * t, y: points[i].y + (points[i+1].y - points[i].y) * t }; }
        target -= segs[i];
    }
    return points[points.length-1];
}

function drawTreeIcon(ctx, p, kind, size, scale, itemScale) { 
    const baseScale = 3.0; scale *= (itemScale * 0.25 * baseScale);
    if(kind.includes('Branch')) { 
        const h = 25 * scale;
        ctx.strokeStyle = 'black'; ctx.lineWidth = 5 * scale; ctx.lineCap = 'round'; ctx.lineJoin = 'round';
        ctx.beginPath(); ctx.moveTo(p.x, p.y); ctx.lineTo(p.x, p.y - h); ctx.moveTo(p.x - 12*scale, p.y - h*0.4); ctx.quadraticCurveTo(p.x, p.y - h*0.1, p.x + 12*scale, p.y - h*0.4); ctx.moveTo(p.x - 10*scale, p.y - h*0.7); ctx.quadraticCurveTo(p.x, p.y - h*0.4, p.x + 10*scale, p.y - h*0.7); ctx.stroke();
        ctx.strokeStyle = '#d4b483'; ctx.lineWidth = 3 * scale; ctx.beginPath(); ctx.moveTo(p.x, p.y); ctx.lineTo(p.x, p.y - h); ctx.stroke(); ctx.beginPath(); ctx.moveTo(p.x - 12*scale, p.y - h*0.4); ctx.quadraticCurveTo(p.x, p.y - h*0.1, p.x + 12*scale, p.y - h*0.4); ctx.stroke(); ctx.beginPath(); ctx.moveTo(p.x - 10*scale, p.y - h*0.7); ctx.quadraticCurveTo(p.x, p.y - h*0.4, p.x + 10*scale, p.y - h*0.7); ctx.stroke();
    } else if(kind.includes('Canopy')) {
        const h = 30 * scale; ctx.strokeStyle = 'black'; ctx.lineWidth = 5 * scale; ctx.beginPath(); ctx.moveTo(p.x, p.y); ctx.lineTo(p.x, p.y - h/2); ctx.stroke(); ctx.beginPath(); ctx.arc(p.x, p.y - h*0.6, 12*scale, 0, Math.PI*2); ctx.stroke();
        ctx.strokeStyle = '#fff'; ctx.lineWidth = 3 * scale; ctx.beginPath(); ctx.moveTo(p.x, p.y); ctx.lineTo(p.x, p.y - h/2); ctx.stroke(); ctx.strokeStyle = '#22c55e'; ctx.beginPath(); ctx.arc(p.x, p.y - h*0.6, 12*scale, 0, Math.PI*2); ctx.stroke();
    } else if(kind === 'C9 Tree') {
        const startY = p.y - 8*scale; const triH = 12 * scale; const triW = 14 * scale;
        ctx.strokeStyle = 'black'; ctx.lineWidth = 5 * scale; ctx.lineJoin = 'round'; ctx.beginPath(); ctx.moveTo(p.x, p.y); ctx.lineTo(p.x, p.y - 8*scale); ctx.stroke();
        for(let i=0; i<3; i++){ const yBase = startY - (i * triH * 0.6); ctx.beginPath(); ctx.moveTo(p.x - triW * (1 - i*0.1), yBase); ctx.lineTo(p.x + triW * (1 - i*0.1), yBase); ctx.lineTo(p.x, yBase - triH); ctx.closePath(); ctx.stroke(); }
        ctx.strokeStyle = '#fff'; ctx.lineWidth = 3 * scale; ctx.beginPath(); ctx.moveTo(p.x, p.y); ctx.lineTo(p.x, p.y - 8*scale); ctx.stroke();
        ctx.strokeStyle = '#22c55e'; for(let i=0; i<3; i++){ const yBase = startY - (i * triH * 0.6); ctx.beginPath(); ctx.moveTo(p.x - triW * (1 - i*0.1), yBase); ctx.lineTo(p.x + triW * (1 - i*0.1), yBase); ctx.lineTo(p.x, yBase - triH); ctx.closePath(); ctx.stroke(); }
    } else if (kind === 'ToL') {
        const h = (size || 9) * 3 * scale; 
        const w = 8 * scale; 
        ctx.beginPath(); ctx.moveTo(p.x, p.y - h); ctx.lineTo(p.x - w, p.y); ctx.lineTo(p.x + w, p.y); ctx.closePath(); 
        ctx.strokeStyle = 'black'; ctx.lineWidth = 2 * scale; ctx.stroke(); 
        ctx.fillStyle = '#22c55e'; ctx.fill(); 
        ctx.lineWidth = 0.6 * scale; ctx.stroke();
    } else { ctx.fillStyle = '#22c55e'; ctx.beginPath(); ctx.arc(p.x, p.y, 10*scale, 0, Math.PI*2); ctx.fill(); ctx.stroke(); }
}

function requestRender(){ window.requestAnimationFrame(draw); }

function drawArrow(p, dir, color){
    const arrowS = settings.arrowScale || 1.0;
    const L = 10 * arrowS * scale; const ang = Math.atan2(dir.y, dir.x); 
    const baseWidth = 4 * arrowS * scale; const colorWidth = 2 * arrowS * scale;
    ctx.beginPath(); ctx.moveTo(p.x, p.y); ctx.lineTo(p.x - L*Math.cos(ang-Math.PI/6), p.y - L*Math.sin(ang-Math.PI/6)); ctx.moveTo(p.x, p.y); ctx.lineTo(p.x - L*Math.cos(ang+Math.PI/6), p.y - L*Math.sin(ang+Math.PI/6)); ctx.strokeStyle = 'black'; ctx.lineWidth = baseWidth; ctx.stroke();
    ctx.beginPath(); ctx.moveTo(p.x, p.y); ctx.lineTo(p.x - L*Math.cos(ang-Math.PI/6), p.y - L*Math.sin(ang-Math.PI/6)); ctx.moveTo(p.x, p.y); ctx.lineTo(p.x - L*Math.cos(ang+Math.PI/6), p.y - L*Math.sin(ang+Math.PI/6)); ctx.strokeStyle = '#ef4444'; ctx.lineWidth = colorWidth; ctx.stroke();
}
function drawDeadEnd(p, neighbor, color){
    const capLen = 7.5 * settings.lineScale * scale; 
    const sP = toScr(p); const sN = toScr(neighbor); 
    const dx = sP.x - sN.x, dy = sP.y - sN.y; 
    const ang = Math.atan2(dy, dx); 
    const px = Math.cos(ang + Math.PI/2) * capLen; 
    const py = Math.sin(ang + Math.PI/2) * capLen;
    ctx.beginPath(); 
    ctx.moveTo(sP.x - px, sP.y - py); 
    ctx.lineTo(sP.x + px, sP.y + py); 
    ctx.strokeStyle = '#000'; ctx.lineWidth = 4 * settings.lineScale * scale; ctx.stroke(); 
    ctx.strokeStyle = color; ctx.lineWidth = 2 * settings.lineScale * scale; ctx.stroke();
}
function drawBow(x, y, scale, itemScale){
    const baseBowSize = 20; const s = baseBowSize * itemScale * scale * 0.4; 
    ctx.fillStyle = '#ef4444'; ctx.strokeStyle='black'; ctx.lineWidth=1 * itemScale * scale;
    ctx.beginPath(); ctx.arc(x, y, s*0.25, 0, Math.PI*2); ctx.fill(); ctx.stroke();
    ctx.beginPath(); ctx.ellipse(x-s*0.5, y-s*0.15, s*0.5, s*0.35, -0.3, 0, Math.PI*2); ctx.fill(); ctx.stroke();
    ctx.beginPath(); ctx.ellipse(x+s*0.5, y-s*0.15, s*0.5, s*0.35, 0.3, 0, Math.PI*2); ctx.fill(); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(x,y); ctx.quadraticCurveTo(x-s*0.5, y+s*0.8, x-s*0.6, y+s*1.2); ctx.lineTo(x-s*0.3, y+s*1.2); ctx.quadraticCurveTo(x-s*0.2, y+s*0.8, x,y); ctx.fill();
    ctx.beginPath(); ctx.moveTo(x,y); ctx.quadraticCurveTo(x+s*0.5, y+s*0.8, x+s*0.6, y+s*1.2); ctx.lineTo(x+s*0.3, y+s*1.2); ctx.quadraticCurveTo(x+s*0.2, y+s*0.8, x,y); ctx.fill(); ctx.stroke();
}

function segmentLength(p1, p2, cp = null) {
    if (!cp) return Math.hypot(p2.x - p1.x, p2.y - p1.y);
    const steps = 15; let len = 0; let last = p1;
    for (let i = 1; i <= steps; i++) {
        const t = i / steps; const mt = 1-t;
        const qx = mt*mt*p1.x + 2*mt*t*cp.x + t*t*p2.x;
        const qy = mt*mt*p1.y + 2*mt*t*cp.y + t*t*p2.y;
        len += Math.hypot(qx-last.x, qy-last.y); last = {x:qx, y:qy};
    }
    return len;
}
function getPointOnSegmentAtDist(p1, p2, dist, targetDist, cp = null) {
    if (!cp) { const t = targetDist / dist; return { x: p1.x + (p2.x - p1.x) * t, y: p1.y + (p2.y - p1.y) * t, t: t, dx: (p2.x - p1.x) / dist, dy: (p2.y - p1.y) / dist }; }
    const steps = 20; let accumulatedDist = 0; let prevP = p1;
    for (let i = 1; i <= steps; i++) {
        const t = i / steps; const mt = 1 - t; const qx = mt * mt * p1.x + 2 * mt * t * cp.x + t * t * p2.x; const qy = mt * mt * p1.y + 2 * mt * t * cp.y + t * t * p2.y; const currentP = { x: qx, y: qy };
        const stepDist = Math.hypot(currentP.x - prevP.x, currentP.y - prevP.y);
        if (accumulatedDist + stepDist >= targetDist) { const remaining = targetDist - accumulatedDist; const subT = remaining / stepDist; const px = prevP.x + (currentP.x - prevP.x) * subT; const py = prevP.y + (currentP.y-prevP.y) * subT; const dx = (currentP.x - prevP.x) / stepDist; const dy = (currentP.y - prevP.y) / stepDist; return { x: px, y: py, t: t, dx, dy }; }
        accumulatedDist += stepDist; prevP = currentP;
    }
    return { x: p2.x, y: p2.y, t: 1, dx: 0, dy: 0 };
}

function drawContinuousLine(it, col, layerName, isForExport = false, arrowDensityScale = 1) {
    if (it.points.length < 2) return;
    const points = it.points.map(p => toScr(p)); const cps = it.cps ? it.cps.map(p => p ? toScr(p) : null) : [];
    const baseWidth = settings.lineThickness * settings.lineScale * scale; const strokeWidth = baseWidth + (4 * settings.lineScale * scale); 
    const rawColorString = it.col || '';
    const normalizedColorString = rawColorString.toLowerCase().replace(/\s/g, '/').replace(/,/g, '/');
    let colors = [];
    normalizedColorString.split('/').forEach(c => { const resolvedColor = getColorCode(c); if (resolvedColor.includes('/')) { resolvedColor.split('/').forEach(subC => { const subHex = getColorCode(subC); if (subHex !== '#ddd') colors.push(subHex); }); } else if (resolvedColor !== '#ddd') { colors.push(resolvedColor); } });
    
    if (layerName === 'garland' || layerName === 'wreath') colors = [getColorCode('green')];
    else if (layerName === 'cords') colors = ['#000000']; 
    else if (layerName === 'shrub' && colors.length === 0) colors = [getColorCode('green')];
    
    const finalColors = colors.length > 0 ? colors : [(isC9(layerName) ? colorOf('ridges') : col)]; 
    let glowStrength = 0; let isLightElement = isC9(layerName) || ['windows', 'wreath', 'tree', 'bow', 'shrub'].includes(layerName);
    const CORE_GLOW_BLUR = 2 * scale + (baseWidth * 1.5); 

    if (isNightMode && isLightElement) { glowStrength = CORE_GLOW_BLUR; ctx.shadowBlur = glowStrength; } else { ctx.shadowBlur = 0; }
    
    const drawDashedPath = (styleFn) => {
        for (let i = 0; i < points.length - 1; i++) {
            const p1 = points[i]; const p2 = points[i+1]; const cp = cps[i] || null;
            ctx.beginPath(); ctx.moveTo(p1.x, p1.y);
            const isDotted = it.isPillarMode && layerName === 'garland' && (i % 2 !== 0); 
            if (isDotted) ctx.setLineDash([5 * settings.lineScale * scale, 5 * settings.lineScale * scale]); else ctx.setLineDash([]); 
            if (cp) ctx.quadraticCurveTo(cp.x, cp.y, p2.x, p2.y); else ctx.lineTo(p2.x, p2.y);
            styleFn(isDotted); ctx.stroke(); ctx.setLineDash([]); 
        }
    };

    if (layerName === 'cords') {
        ctx.strokeStyle = 'rgba(255,255,255,0.4)'; ctx.lineWidth = baseWidth + 2 * settings.lineScale * scale; ctx.lineCap = 'round'; ctx.lineJoin = 'round';
        drawDashedPath(() => {});
    } else {
        ctx.strokeStyle = 'black'; ctx.lineWidth = strokeWidth; ctx.lineCap = 'round'; ctx.lineJoin = 'round';
        drawDashedPath(() => {});
    }

    if (finalColors.length <= 1) {
        const color = finalColors[0];
        if (isNightMode && isLightElement) { ctx.shadowBlur = glowStrength; ctx.shadowColor = color; } else { ctx.shadowBlur = 0; }
        ctx.strokeStyle = color; ctx.lineWidth = baseWidth; 
        drawDashedPath(() => {});
    } else {
        const colorBlockLength = Math.max(10, 10 * settings.lineScale * scale); let colorIndex = 0;
        for (let i = 0; i < points.length - 1; i++) {
            const p1 = points[i]; const p2 = points[i+1]; const segDist = segmentLength(it.points[i], it.points[i+1], it.cps?.[i]) * scale;
            const isDottedSegment = it.isPillarMode && layerName === 'garland' && (i % 2 !== 0);
            let currentDistInSegment = 0; let lastDrawnPoint = p1;
            while (currentDistInSegment < segDist) {
                const color = finalColors[colorIndex % finalColors.length]; const remainingDistInSegment = segDist - currentDistInSegment; const blockDist = Math.min(colorBlockLength, remainingDistInSegment);
                const ptObj = getPointOnSegmentAtDist(it.points[i], it.points[i+1], segmentLength(it.points[i], it.points[i+1], it.cps?.[i]) * scale, (currentDistInSegment + blockDist) / scale, it.cps?.[i]);
                const endPoint = toScr({x: ptObj.x, y: ptObj.y});
                if (blockDist > 0.1) {
                    if (isNightMode && isLightElement) { ctx.shadowBlur = glowStrength; ctx.shadowColor = color; } else { ctx.shadowBlur = 0; }
                    ctx.beginPath(); ctx.moveTo(lastDrawnPoint.x, lastDrawnPoint.y); ctx.lineTo(endPoint.x, endPoint.y);
                    if (isDottedSegment) ctx.setLineDash([5 * settings.lineScale * scale, 5 * settings.lineScale * scale]); else ctx.setLineDash([]); 
                    ctx.strokeStyle = color; ctx.lineWidth = baseWidth; ctx.stroke(); ctx.setLineDash([]); ctx.shadowBlur = 0; 
                }
                currentDistInSegment += blockDist; lastDrawnPoint = endPoint; colorIndex++; 
            }
        }
    }
    ctx.shadowBlur = 0; ctx.setLineDash([]); 
}

function drawCord(it, col, layerName) { if (it.points.length < 2) return; drawContinuousLine(it, col, layerName); }

function roundRect(ctx, x, y, w, h, r) {
    if (w < 2 * r) r = w / 2; if (h < 2 * r) r = h / 2;
    ctx.beginPath(); ctx.moveTo(x + r, y); ctx.arcTo(x + w, y, x + w, y + h, r); ctx.arcTo(x + w, y + h, x, y + h, r); ctx.arcTo(x, y + h, x, y, r); ctx.arcTo(x, y, x + w, y, r); ctx.closePath();
}

function drawLabels(ctx, isExport=false) {
    const nominalFontSize = 14; 
    const fontScaleFactor = scale * settings.labelScale * 0.35; 
    const currentFontSize = nominalFontSize * fontScaleFactor; 
    if (currentFontSize > 0.1) { 
        ctx.font=`bold ${currentFontSize}px "Inter", system-ui`; ctx.fillStyle='white'; ctx.textAlign='center'; ctx.textBaseline='middle';
        Object.keys(data).forEach(k=>{
            if (k === 'powersource') return;
            data[k].forEach(it=>{
                if(!it.label && k !== 'label') return; 
                let p, offY;
                if (it.customLabelPos) {
                    p = it.customLabelPos; offY = 0;
                } else if(it.points) { 
                    p = getPolylineMidpoint(it.points); offY = -14 * fontScaleFactor; 
                } else if (it.kind === 'ToL') { 
                    const treeScale = (k === 'tree') ? settings.iconScale : 1.0; 
                    const h = (it.size || 9) * 3 * scale * treeScale; 
                    p = {x: it.pt.x, y: it.pt.y - (h/2)/scale}; offY = 0; 
                } else if (k === 'custom_icon') { 
                    const scaledW = it.w * it.scale; const scaledH = it.h * it.scale; 
                    p = { x: it.pt.x + scaledW / 2, y: it.pt.y + scaledH / 2 }; offY = 0; 
                } else { 
                    p = it.pt; offY = 0; 
                }
                const s = toScr(p);
                
                let labelText = (k === 'label') ? (it.text || it.label) : it.label;
                if(isC9(k) && it.clip) labelText += ` ${it.clip}`; 
                if(k === 'wreath') labelText += ` ${it.size}`; 
                if(it.fra) labelText += ' (FRA)'; 
                if(it.gguard) labelText += ' (GG)';
                
                const metrics = ctx.measureText(labelText); const textWidth = metrics.width;
                const padX = 6 * fontScaleFactor; const padY = 4 * fontScaleFactor; 
                const boxWidth = textWidth + (2 * padX); const boxHeight = currentFontSize + (2 * padY); 
                const radius = 6 * fontScaleFactor;
                
                ctx.fillStyle = 'rgba(15, 23, 42, 0.85)'; roundRect(ctx, s.x - boxWidth/2, s.y + offY - boxHeight/2, boxWidth, boxHeight, radius); ctx.fill();
                ctx.fillStyle='white'; ctx.fillText(labelText, s.x, s.y + offY);
            });
        });
    }
}

function draw(){
    if (!ctx) return;
    const cw = cv.width / DPR; const ch = cv.height / DPR;
    let isBlankMap = imgReady && !imgDataUrl;
    if(isBlankMap){ ctx.fillStyle='#ffffff'; ctx.fillRect(0,0,cw,ch); } else { ctx.fillStyle='#0f172a'; ctx.fillRect(0,0,cw,ch); }
    
    let filterString = 'none'; 
    if(imgReady && imgDataUrl){ 
        if(isNightMode) filterString = 'brightness(0.25) grayscale(0.2)';
        if(settings.bgBlur > 0) filterString = (filterString==='none'?'':filterString+' ') + `blur(${settings.bgBlur/5}px)`;
        ctx.filter = filterString; ctx.drawImage(bg, panX, panY, bg.width*scale, bg.height*scale); ctx.filter = 'none'; 
    } 
    
    ctx.shadowBlur = 0; const pg = analyzePower();
    data.cords.forEach(it => { drawCord(it, getColorCode(it.col) || colorOf('cords'), 'cords'); }); 
    ['shrub','windows','ridges','fascia','peaks','groundstakes','garland'].forEach(L=>{ data[L].forEach(it=>{ drawContinuousLine(it, getColorCode(it.col) || colorOf(L), L); }); });
    
    if(pg){
        pg.edges.forEach(e => {
            if(['groundstakes'].includes(e.type)) return;
            const uNode = pg.nodes[e.u]; const vNode = pg.nodes[e.v];
            if(uNode.dist !== Infinity && vNode.dist !== Infinity){
                const uPos = toScr({x:uNode.x, y:uNode.y}); const vPos = toScr({x:vNode.x, y:vNode.y});
                let isReversed = uNode.dist > vNode.dist;
                
                const worldDist = segmentLength({x:uNode.x, y:uNode.y}, {x:vNode.x, y:vNode.y}, e.cps);
                let count = Math.floor((worldDist + 0.5) / 100 * settings.arrowFreqFactor);
                
                if (e.cps) {
                    const cp = toScr(e.cps);
                    for (let k = 1; k <= count; k++) {
                        let t = k / (count + 1);
                        const invT = 1 - t;
                        const px = invT * invT * uPos.x + 2 * invT * t * cp.x + t * t * vPos.x;
                        const py = invT * invT * uPos.y + 2 * invT * t * cp.y + t * t * vPos.y;
                        const tx = 2 * invT * (cp.x - uPos.x) + 2 * t * (vPos.x - cp.x);
                        const ty = 2 * invT * (cp.y - uPos.y) + 2 * t * (vPos.y - cp.y);
                        let dir = { x: tx, y: ty };
                        if (isReversed) { dir.x = -dir.x; dir.y = -dir.y; }
                        drawArrow({ x: px, y: py }, dir, '#ef4444');
                    }
                } else {
                    const dx = vPos.x - uPos.x, dy = vPos.y - uPos.y;
                    for(let k=1; k<=count; k++){
                        const t = k / (count+1);
                        let dir = {x: dx, y: dy};
                        if(isReversed) { dir.x = -dir.x; dir.y = -dir.y; }
                        drawArrow({x: uPos.x + dx*t, y: uPos.y + dy*t}, dir, '#ef4444');
                    }
                }
            }
        });
        pg.singleArrowEdges.forEach(a => {
            const edge = a.edge; const uPos = toScr(edge.line.points[edge.index]); const vPos = toScr(edge.line.points[edge.index+1]);
            const segDist = segmentLength(uPos, vPos, edge.cps ? toScr(edge.cps) : null);
            const ptObj = getPointOnSegmentAtDist(uPos, vPos, segDist, a.distInSegment * scale, edge.cps ? toScr(edge.cps) : null);
            let dir = {x: ptObj.dx, y: ptObj.dy}; if (a.isReversed) { dir.x = -dir.x; dir.y = -dir.y; }
            drawArrow({x: ptObj.x, y: ptObj.y}, dir, '#ef4444');
        });
        pg.deadTips.forEach(nodeIdx => { const n = pg.nodes[nodeIdx]; const neighborIdx = n.adj[0]; if(neighborIdx !== undefined){ drawDeadEnd(n, pg.nodes[neighborIdx], '#fffdf0'); } });
    }

    const itemScale = settings.iconScale; const junctionScale = settings.junctionScale; 

    data.wreath.forEach(w=>{
        const s=toScr(w.pt); const r=(w.size==='42"'?12.5:8.75) * scale * itemScale; const wreathColor = colorOf('wreath'); 
        if (isNightMode) { ctx.shadowBlur = 15 * scale; ctx.shadowColor = wreathColor; }
        ctx.beginPath(); ctx.arc(s.x,s.y,r,0,Math.PI*2); ctx.fillStyle = colorOf('wreath'); ctx.fill();
        ctx.shadowBlur = 0; ctx.strokeStyle='black'; ctx.lineWidth=6 * itemScale * scale; ctx.stroke(); ctx.strokeStyle=colorOf('wreath'); ctx.lineWidth=3 * itemScale * scale; ctx.stroke(); 
        if(w.bow === 'top' || w.bow === 'bottom'){ const by = w.bow==='top' ? s.y - r : s.y + r; drawBow(s.x, by, scale, itemScale); }
    });

    data.bow.forEach(b=>{ const s=toScr(b.pt); drawBow(s.x, s.y, scale, itemScale); }); 

    data.tree.forEach(tr => {
        const p = toScr(tr.pt);
        drawTreeIcon(ctx, p, tr.kind, tr.size, scale, itemScale);
    });
    
    data.powersource.forEach(ps=>{
        const s=toScr(ps.pt); const sz = 8 * junctionScale * scale; const strokeWidth = 3 * junctionScale * scale; 
        ctx.fillStyle='#ef4444'; ctx.fillRect(s.x-sz/2, s.y-sz/2, sz, sz);
        ctx.strokeStyle='black'; ctx.lineWidth=strokeWidth; ctx.strokeRect(s.x-sz/2, s.y-sz/2, sz, sz); ctx.strokeStyle='white'; ctx.lineWidth=strokeWidth/2; ctx.strokeRect(s.x-sz/2, s.y-sz/2, sz, sz);
    });

    if(data.threeway){
        data.threeway.forEach(tw=>{
            const s = toScr(tw.pt); const sz = 6 * scale * junctionScale; const strokeWidth = 3 * junctionScale * scale;
            ctx.beginPath(); ctx.moveTo(s.x, s.y - sz); ctx.lineTo(s.x + sz, s.y + sz); ctx.lineTo(s.x - sz, s.y + sz); ctx.closePath(); ctx.fillStyle = '#eab308'; ctx.fill();
            ctx.strokeStyle = 'black'; ctx.lineWidth = strokeWidth; ctx.stroke(); ctx.strokeStyle = 'white'; ctx.lineWidth = strokeWidth/2; ctx.stroke();
        });
    }
    
    data.custom_icon.forEach(ci => {
        if (!ci.url) return;
        const sTL = toScr(ci.pt); const scaledW = ci.w * ci.scale * scale; const scaledH = ci.h * ci.scale * scale;
        if (!ci.imageObj || ci.imageObj.src !== ci.url) { ci.imageObj = new Image(); ci.imageObj.src = ci.url; }
        if (ci.imageObj.complete) { ctx.drawImage(ci.imageObj, sTL.x, sTL.y, scaledW, scaledH); }
    });

    if(sketch && sketch.points.length>0){
        const cursor = cv._mx!=null ? toWorld(cv._mx, cv._my) : null; const pts = [...sketch.points]; if(cursor) pts.push(cursor);
        const skObj = {points: pts, cps: sketch.cps || [], layer: sketch.layer, col: sketch.col, isPillarMode: sketch.isPillarMode}; 
        const sketchColor = getColorCode(sketch.col) || colorOf(sketch.layer);
        drawContinuousLine(skObj, sketchColor, sketch.layer); 
    }
    
    if(chkSnap.checked && cv._mx!=null){
         const sn = getSnap(cv._mx, cv._my, 25, (draggingPoint ? draggingPoint.obj : null));
         if(sn){ 
             const s = toScr({x:sn.x, y:sn.y}); 
             ctx.beginPath(); ctx.arc(s.x, s.y, 6, 0, Math.PI*2); 
             ctx.fillStyle = 'rgba(234, 179, 8, 0.6)'; ctx.fill(); 
             ctx.strokeStyle = '#000'; ctx.lineWidth=1; ctx.stroke(); 
         }
    }

    drawLabels(ctx);

    if(selectedItem){
        const obj = selectedItem.obj; const selectionBaseScale = 1.0; 
        if(obj.points){
             obj.points.forEach(p=>{ const s = toScr(p); ctx.beginPath(); ctx.arc(s.x, s.y, 6 * selectionBaseScale, 0, Math.PI*2); ctx.fillStyle = 'white'; ctx.fill(); ctx.strokeStyle = '#3b82f6'; ctx.lineWidth=2 * selectionBaseScale; ctx.stroke(); });
        } else if (obj.pt && obj.kind !== 'custom_icon'){
            const s = toScr(obj.pt); ctx.beginPath(); ctx.arc(s.x, s.y, 15 * selectionBaseScale, 0, Math.PI*2); ctx.strokeStyle = '#3b82f6'; ctx.lineWidth=2 * selectionBaseScale; ctx.stroke();
        }
    }
}

window.addEventListener('popstate', () => { document.getElementById('modalBack').style.display = 'flex'; });
document.getElementById('btnStay').onclick = () => { document.getElementById('modalBack').style.display = 'none'; history.pushState(null, null, location.href); };
document.getElementById('btnLeave').onclick = () => { document.getElementById('modalBack').style.display = 'none'; history.back(); };
const handleImg = (f)=>{
    if(!f) return; const r=new FileReader();
    r.onload=()=>{ imgDataUrl=r.result; bg.src=imgDataUrl; bg.onload=()=>{ imgReady=true; document.body.classList.remove('white-bg'); resetView(); unlock(); }; bg.onerror=()=>{ showAlert("Failed to load image"); }; };
    r.readAsDataURL(f);
};

function startBlankMap() { 
    for(const key in data) data[key] = [];
    bg.width = 1000; bg.height = 1000; imgDataUrl = null; imgReady = true; 
    document.body.classList.add('white-bg'); 
    resetView(); refreshTable(); unlock(); 
}

function getCleanData() { const cleanData = JSON.parse(JSON.stringify(data)); if (cleanData.custom_icon) { cleanData.custom_icon.forEach(icon => { delete icon.imageObj; }); } return cleanData; }

function applyUIState(o) {
    lineScaleInput.value = settings.lineScale; iconScaleInput.value = settings.iconScale; junctionScaleInput.value = settings.junctionScale; labelScaleInput.value = settings.labelScale; arrowFreqInput.value = settings.arrowFreqFactor; bgBlurInput.value = settings.bgBlur; arrowScaleInput.value = settings.arrowScale;
    updateLineScaleUI(); updateIconScaleUI(); updateJunctionScaleUI(); updateLabelScaleUI(); updateArrowFreqUI(); updateBgBlurUI(); updateArrowScaleUI();
    const uiState = o.uiState || {};
    isNightMode = uiState.isNightMode !== undefined ? uiState.isNightMode : false;
    const nightModeToolButton = toolBtn['night_mode'];
    if (nightModeToolButton) {
        nightModeToolButton.classList.toggle('toggled', isNightMode);
        nightModeToolButton.classList.toggle('night-glow', isNightMode);
    }
    chkSnap.checked = uiState.isSnapOn !== undefined ? uiState.isSnapOn : true; btnSnap.classList.toggle('toggled', chkSnap.checked);
    chkSwag.checked = uiState.isSwagOn !== undefined ? uiState.isSnapOn : false; btnSwag.classList.toggle('toggled', chkSwag.checked);
    chkPillar.checked = uiState.isPillarOn !== undefined ? uiState.isPillarOn : false; btnPillar.classList.toggle('toggled', chkPillar.checked);
    const chkAuto = document.getElementById('chkAutoCalc'); chkAuto.checked = uiState.isAutoCalcOn !== undefined ? uiState.isAutoCalcOn : true;
    requestRender();
}

const handleMap = (f)=>{
    if(!f) return; const r=new FileReader(); r.onload=()=>{ 
        try{ 
            const o=JSON.parse(r.result); imgDataUrl=o.image||null; 
            if(o.data) {
                 let maxIndex = 0;
                 for (const L in data) {
                     data[L] = o.data[L] || [];
                     data[L].forEach(item => { if(item.index > maxIndex) maxIndex = item.index; });
                 }
                 actionCounter = maxIndex;
            }
            if (o.settings) { settings = {...settings, ...o.settings}; }
            applyState(o); applyUIState(o); 
            if(imgDataUrl){ bg.src=imgDataUrl; bg.onload=()=>{ imgReady=true; document.body.classList.remove('white-bg'); resetView(); unlock(); }; } 
            else { bg.width = o.bg_width || 1000; bg.height = o.bg_height || 1000; imgReady = true; document.body.classList.add('white-bg'); resetView(); unlock(); } 
        }catch(e){showAlert('Error loading map');} 
    };
    r.readAsText(f);
};

function applyState(o){
    document.getElementById('customer').value=o.job?.name||''; document.getElementById('address').value=o.job?.address||''; document.getElementById('jobNotes').value=o.job?.notes||''; 
    const timerInputs = document.getElementById('timerInputs'); const btnCC = document.getElementById('btnCustomerControlled');
    if(o.job?.timer?.isCustomerControlled) { timerInputs.style.display = 'none'; btnCC.classList.add('toggled'); document.getElementById('on1').value = 'CC'; } 
    else { 
        timerInputs.style.display = 'block'; 
        btnCC.classList.remove('toggled'); 
        document.getElementById('on1').value = o.job?.timer?.on1 || ''; 
        document.getElementById('off1').value = o.job?.timer?.off1 || ''; 
        document.getElementById('on2').value = o.job?.timer?.on2 || ''; 
        document.getElementById('off2').value = o.job?.timer?.off2 || ''; 
    }
    markPowerDirty(); refreshTable();
}

document.getElementById('btnStd').onclick=()=>{ 
    document.getElementById('on1').value='06:00'; document.getElementById('off1').value='08:00'; document.getElementById('on2').value='17:00'; document.getElementById('off2').value='00:00'; 
    document.getElementById('btnCustomerControlled').classList.remove('toggled'); document.getElementById('timerInputs').style.display = 'block';
};
document.getElementById('btnCustomerControlled').onclick = () => {
    const timerInputs = document.getElementById('timerInputs'); const btnCC = document.getElementById('btnCustomerControlled'); const isActive = btnCC.classList.toggle('toggled');
    if (isActive) { timerInputs.style.display = 'none'; document.getElementById('on1').value = 'CC'; document.getElementById('off1').value = 'CC'; document.getElementById('on2').value = 'CC'; document.getElementById('off2').value = 'CC'; } 
    else { document.getElementById('on1').value = ''; document.getElementById('off1').value = ''; document.getElementById('on2').value = ''; document.getElementById('off2').value = ''; timerInputs.style.display = 'block'; }
};

document.getElementById('gPickImg').onclick=()=>document.getElementById('gImg').click();
document.getElementById('gPickMap').onclick=()=>document.getElementById('gMap').click();
document.getElementById('gImg').onchange=e=>{ handleImg(e.target.files[0]); e.target.value=''; };
document.getElementById('gMap').onchange=e=>{ handleMap(e.target.files[0]); e.target.value=''; };

const delay = ms => new Promise(res => setTimeout(res, ms));
document.getElementById('btnSaveAll').onclick = (e) => { e.preventDefault(); performDualSave(); };
document.getElementById('btnSaveImageOnly').onclick = () => { performSavePdf(); };
document.getElementById('btnSaveMapOnly').onclick = () => { performSaveMapOnly(); };

async function performDualSave() {
    const mapSuccess = await performSaveMapOnly(); 
    await delay(3000); 
    const pdfSuccess = await performSavePdf();
    return mapSuccess || pdfSuccess;
}

function buildPayload() {
    const isCC = document.getElementById('btnCustomerControlled').classList.contains('toggled');
    return {
        version:20, image:imgDataUrl, data: getCleanData(), 
        job:{ 
            name:document.getElementById('customer').value, 
            address:document.getElementById('address').value, 
            notes:document.getElementById('jobNotes').value,
            timer: {
                on1: document.getElementById('on1').value,
                off1: document.getElementById('off1').value,
                on2: document.getElementById('on2').value,
                off2: document.getElementById('off2').value,
                isCustomerControlled: isCC
            }
        },
        settings: settings, uiState: { isNightMode: isNightMode, isSnapOn: chkSnap.checked, isSwagOn: chkSwag.checked, isPillarOn: chkPillar.checked, isAutoCalcOn: document.getElementById('chkAutoCalc').checked }
    };
}

function getFilenameBase() { const year = new Date().getFullYear(); const nm = (document.getElementById('customer').value || 'Untitled').trim(); return `${nm} - ${year} Map`; }

async function performSaveMapOnly() {
    const filenameMap = `${getFilenameBase()}.skmap`; const payload = buildPayload(); 
    const blob = new Blob([JSON.stringify(payload)], {type:'application/octet-stream'});
    const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = filenameMap; a.click();
    
    // Cloud Backup
    saveToGitHub(filenameMap, JSON.stringify(payload));
}

async function performSavePdf() {
    const capture = captureCanvasData(); if(!capture) { showAlert("Error generating image data."); return false; }
    const { url: pngData, width, height } = capture; const { jsPDF } = window.jspdf;
    const pdf = new jsPDF({ orientation: width > height ? 'l' : 'p', unit: 'px', format: [width, height] });
    pdf.addImage(pngData, 'PNG', 0, 0, width, height); 
    const pdfName = `${getFilenameBase()}.pdf`;
    pdf.save(pdfName);

    // Cloud Backup (as base64)
    saveToGitHub(pdfName, pngData.split(',')[1], true);
}

function wrapText(context, text, x, y, maxWidth, lineHeight) {
    if(!text) return y;
    let words = text.split(' ');
    let line = '';
    let currentY = y;
    for (let n = 0; n < words.length; n++) {
        let testLine = line + words[n] + ' ';
        let metrics = context.measureText(testLine);
        let testWidth = metrics.width;
        if (testWidth > maxWidth && n > 0) {
            context.fillText(line, x, currentY);
            line = words[n] + ' ';
            currentY += lineHeight;
        } else {
            line = testLine;
        }
    }
    context.fillText(line, x, currentY);
    return currentY + lineHeight;
}

function captureCanvasData() {
    if(!imgReady) return null;
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    const checkPt = (p) => { if(p.x < minX) minX = p.x; if(p.y < minY) minY = p.y; if(p.x > maxX) maxX = p.x; if(p.y > maxY) maxY = p.y; };
    let hasItems = false;
    Object.keys(data).forEach(L => {
        data[L].forEach(item => {
             hasItems = true; if(item.points) item.points.forEach(checkPt);
             if(item.pt) { checkPt(item.pt); }
        });
    });
    if(!hasItems) { minX = 0; minY = 0; maxX = bg.width; maxY = bg.height; } 
    else { const pad = 50; minX = Math.max(0, minX - pad); minY = Math.max(0, minY - pad); maxX = Math.min(bg.width, maxX + pad); maxY = Math.min(bg.height, maxY + pad); }
    
    const cropW = maxX - minX; const cropH = maxY - minY; const DPI = 2; const MAP_WIDTH_PX = 1000; const MAP_H_PX = Math.round((MAP_WIDTH_PX / cropW) * cropH);
    
    const testCanvas = document.createElement('canvas');
    const tCtx = testCanvas.getContext('2d');
    tCtx.font = 'italic 11px "Inter", system-ui';
    const notesWidth = 970;
    const jNotes = document.getElementById('jobNotes').value;
    let estimatedNotesHeight = 0;
    if(jNotes) {
        let words = jNotes.split(' ');
        let line = '';
        estimatedNotesHeight = 15;
        for (let n = 0; n < words.length; n++) {
            let testLine = line + words[n] + ' ';
            if (tCtx.measureText(testLine).width > notesWidth && n > 0) { line = words[n] + ' '; estimatedNotesHeight += 15; } else { line = testLine; }
        }
    }

    const HEADER_BASE = 110; 
    const HEADER_H = HEADER_BASE + estimatedNotesHeight;
    const FOOTER_ROW_H = 24; const FOOTER_TITLE_H = 40; 
    const items = collectRows();
    const ITEM_COUNT = items.length; 
    const FOOTER_H = ITEM_COUNT > 0 ? (FOOTER_TITLE_H + ITEM_COUNT * FOOTER_ROW_H + 40) : 0;
    const OUT_W = MAP_WIDTH_PX; const OUT_H = HEADER_H + MAP_H_PX + FOOTER_H;

    const out = document.createElement('canvas'); out.width = OUT_W * DPI; out.height = OUT_H * DPI; const o = out.getContext('2d'); o.scale(DPI, DPI); 
    const oldScale = scale; const oldPanX = panX; const oldPanY = panY; const originalCtx = ctx; 
    
    try {
        const renderScale = MAP_WIDTH_PX / cropW; const renderPanX = -minX * renderScale; const renderPanY = HEADER_H - (minY * renderScale); 
        scale = renderScale; panX = renderPanX; panY = renderPanY; ctx = o;

        o.fillStyle = '#0f172a'; o.fillRect(0, 0, OUT_W, OUT_H);

        o.fillStyle = 'white'; o.font = 'bold 18px "Inter", system-ui'; o.textAlign = 'left'; o.textBaseline = 'top';
        o.fillText(document.getElementById('customer').value || 'UNTITLED PROJECT', 12, 20);
        
        o.fillStyle = '#94a3b8'; o.font = '500 13px "Inter", system-ui';
        o.fillText(document.getElementById('address').value || 'No address provided', 12, 45);
        
        o.fillStyle = '#3b82f6'; o.font = 'bold 12px "Inter", system-ui';
        o.fillText(`DATE: ${new Date().toLocaleDateString()}`, 12, 65);

        const timerOn1 = document.getElementById('on1').value;
        const timerOff1 = document.getElementById('off1').value;
        const timerOn2 = document.getElementById('on2').value;
        const timerOff2 = document.getElementById('off2').value;
        const isCC = document.getElementById('btnCustomerControlled').classList.contains('toggled') || timerOn1 === 'CC';
        
        o.textAlign = 'right';
        o.fillStyle = '#1e293b'; 
        const timerBoxW = 160; 
        roundRect(o, OUT_W - timerBoxW - 12, 15, timerBoxW, 65, 8); o.fill(); 
        o.strokeStyle = '#334155'; o.stroke();
        
        o.fillStyle = '#fbbf24'; o.font = 'bold 12px "Inter", system-ui'; o.textAlign = 'center';
        o.fillText('TIMER SETTINGS', OUT_W - (timerBoxW/2) - 12, 25);
        
        o.fillStyle = '#f1f5f9'; o.font = 'bold 13px "Inter", system-ui';
        o.textBaseline = 'middle';
        if (isCC) { o.fillText('CUSTOMER CONTROLLED', OUT_W - (timerBoxW/2) - 12, 52); } 
        else { o.fillText(`T1: ${timerOn1 || '--'} to ${timerOff1 || '--'}`, OUT_W - (timerBoxW/2) - 12, 45); o.fillText(`T2: ${timerOn2 || '--'} to ${timerOff2 || '--'}`, OUT_W - (timerBoxW/2) - 12, 62); }
        o.textBaseline = 'top';

        if(jNotes) {
            o.textAlign = 'left';
            o.fillStyle = '#fbbf24'; o.font = 'bold 11px "Inter", system-ui';
            o.fillText('INSTALLATION NOTES:', 12, 85);
            o.fillStyle = '#cbd5e1'; o.font = 'italic 11px "Inter", system-ui';
            wrapText(o, jNotes, 12, 100, notesWidth, 15);
        }
        
        const logoSize = 90; o.drawImage(logo, (OUT_W / 2) - (logoSize / 2), 10, logoSize, logoSize);

        let imageFilter = 'none'; 
        if(isNightMode) imageFilter = 'brightness(0.25) grayscale(0.2)';
        if(settings.bgBlur > 0) imageFilter = (imageFilter==='none'?'':imageFilter+' ') + `blur(${settings.bgBlur/5}px)`;
        o.filter = imageFilter;
        if (imgReady && !imgDataUrl) { o.fillStyle = 'white'; o.fillRect(0, HEADER_H, OUT_W, MAP_H_PX); } 
        else { o.drawImage(bg, minX, minY, cropW, cropH, 0, HEADER_H, OUT_W, MAP_H_PX); }
        o.filter = 'none';

        data.cords.forEach(it => { drawCord(it, getColorCode(it.col) || colorOf('cords'), 'cords'); });
        ['shrub','windows','ridges','fascia','peaks','groundstakes','garland'].forEach(L=>{ data[L].forEach(it=>{ drawContinuousLine(it, getColorCode(it.col) || colorOf(L), L); }); });
        
        const pg = analyzePower();
        if(pg){
             pg.edges.forEach(e => {
                 if(['groundstakes'].includes(e.type)) return;
                 const uNode = pg.nodes[e.u]; const vNode = pg.nodes[e.v];
                 if(uNode.dist !== Infinity && vNode.dist !== Infinity){
                     const uPos = toScr({x:uNode.x, y:uNode.y}); const vPos = toScr({x:vNode.x, y:vNode.y});
                     let isReversed = uNode.dist > vNode.dist;
                     
                     const worldDist = segmentLength({x:uNode.x, y:uNode.y}, {x:vNode.x, y:vNode.y}, e.cps);
                     let count = Math.floor((worldDist + 0.5) / 100 * settings.arrowFreqFactor);
                     
                     if (e.cps) {
                         const cp = toScr(e.cps);
                         for (let k = 1; k <= count; k++) {
                             let t = k / (count + 1);
                             const invT = 1 - t;
                             const px = invT * invT * uPos.x + 2 * invT * t * cp.x + t * t * vPos.x;
                             const py = invT * invT * uPos.y + 2 * invT * t * cp.y + t * t * vPos.y;
                             const tx = 2 * invT * (cp.x - uPos.x) + 2 * t * (vPos.x - cp.x);
                             const ty = 2 * invT * (cp.y - uPos.y) + 2 * t * (vPos.y - cp.y);
                             let dir = { x: tx, y: ty };
                             if (isReversed) { dir.x = -dir.x; dir.y = -dir.y; }
                             drawArrow({ x: px, y: py }, dir, '#ef4444');
                         }
                     } else {
                         const dx = vPos.x - uPos.x, dy = vPos.y - uPos.y;
                         for(let k=1; k<=count; k++){
                             const t = k / (count+1);
                             let dir = {x: dx, y: dy};
                             if(isReversed) { dir.x = -dir.x; dir.y = -dir.y; }
                             drawArrow({x: uPos.x + dx*t, y: uPos.y + dy*t}, dir, '#ef4444');
                         }
                     }
                 }
             });
             pg.deadTips.forEach(nodeIdx => { const n = pg.nodes[nodeIdx]; const neighbor = pg.nodes[n.adj[0]]; if(neighbor) drawDeadEnd(n, neighbor, '#fffdf0'); });
        }
        
        data.wreath.forEach(w=>{
            const s=toScr(w.pt); 
            const r=(w.size==='42"'?12.5:8.75)*scale*settings.iconScale; 
            const wreathColor = colorOf('wreath');
            o.beginPath(); o.arc(s.x,s.y,r,0,Math.PI*2); 
            o.fillStyle = wreathColor; o.fill(); 
            o.strokeStyle='black'; o.lineWidth=6 * settings.iconScale * scale; o.stroke(); 
            o.strokeStyle=wreathColor; o.lineWidth=3 * settings.iconScale * scale; o.stroke();
            if(w.bow === 'top' || w.bow === 'bottom'){ 
                const by = w.bow==='top' ? s.y - r : s.y + r; 
                drawBow(s.x, by, scale, settings.iconScale); 
            }
        });

        data.bow.forEach(b=>{ const s=toScr(b.pt); drawBow(s.x, s.y, scale, settings.iconScale); }); 
        data.tree.forEach(tr => { drawTreeIcon(o, toScr(tr.pt), tr.kind, tr.size, scale, settings.iconScale); });
        data.powersource.forEach(ps=>{ const s=toScr(ps.pt); const sz = 8*scale*settings.junctionScale; o.fillStyle='#ef4444'; o.fillRect(s.x-sz/2, s.y-sz/2, sz, sz); o.strokeStyle='black'; o.lineWidth=3*scale*settings.junctionScale; o.strokeRect(s.x-sz/2, s.y-sz/2, sz, sz); });
        data.threeway.forEach(tw=>{ const s=toScr(tw.pt); const sz = 6*scale*settings.junctionScale; o.beginPath(); o.moveTo(s.x, s.y-sz); o.lineTo(s.x+sz, s.y+sz); o.lineTo(s.x-sz, s.y+sz); o.closePath(); o.fillStyle='#eab308'; o.fill(); o.strokeStyle='black'; o.lineWidth=3*scale*settings.junctionScale; o.stroke(); });
        
        data.custom_icon.forEach(ci => {
            if (!ci.url) return;
            const sTL = toScr(ci.pt); 
            const scaledW = ci.w * ci.scale * scale; 
            const scaledH = ci.h * ci.scale * scale;
            if (!ci.imageObj || ci.imageObj.src !== ci.url) { ci.imageObj = new Image(); ci.imageObj.src = ci.url; }
            if (ci.imageObj.complete) { o.drawImage(ci.imageObj, sTL.x, sTL.y, scaledW, scaledH); }
        });

        drawLabels(o);

        if (ITEM_COUNT > 0) {
            const footY = HEADER_H + MAP_H_PX;
            o.fillStyle = '#1e293b'; o.fillRect(0, footY, OUT_W, FOOTER_H);
            o.fillStyle = '#3b82f6'; o.font = 'bold 15px "Inter", system-ui'; o.textAlign = 'left'; o.textBaseline = 'top';
            o.fillText('LINE INFORMATION SUMMARY', 12, footY + 12);
            let y = footY + FOOTER_TITLE_H;
            const cols = [ { label: 'TYPE', w: 0.15 }, { label: 'ID', w: 0.08 }, { label: 'FT', w: 0.08 }, { label: 'BULBS', w: 0.08 }, { label: 'CLIP', w: 0.12 }, { label: 'COLOUR', w: 0.15 }, { label: 'NOTES', w: 0.3 } ];
            o.fillStyle = '#0f172a'; roundRect(o, 8, y-2, OUT_W-16, 22, 6); o.fill();
            o.fillStyle = '#3b82f6'; o.font = 'bold 10px "Inter", system-ui'; o.textBaseline = 'middle';
            let headerX = 15; cols.forEach(c => { o.fillText(c.label, headerX, y + 9); headerX += OUT_W * c.w; });
            o.fillStyle = '#f1f5f9'; o.font = '11px "Inter", system-ui';
            y += 24;
            items.sort((a,b)=>(a.label||'').localeCompare(b.label||'', undefined, {numeric:true})).forEach(r => {
                let x = 15;
                let typeDisplay = pretty[r.L] || r.L;
                if (r.kind === 'ToL') typeDisplay = 'Tree of Lights';

                o.fillText(typeDisplay, x, y + FOOTER_ROW_H/2); x += OUT_W * cols[0].w;
                o.fillText(r.label || '-', x, y + FOOTER_ROW_H/2); x += OUT_W * cols[1].w;
                o.fillText(r.ft || '-', x, y + FOOTER_ROW_H/2); x += OUT_W * cols[2].w;
                o.fillText(r.bulbs || '-', x, y + FOOTER_ROW_H/2); x += OUT_W * cols[3].w;
                o.fillText(r.clip || '-', x, y + FOOTER_ROW_H/2); x += OUT_W * cols[4].w;
                let displayCol = r.col || '-';
                const nrCol = r.col ? r.col.toLowerCase().replace(/\s/g, '/').replace(/,/g, '/').replace(/ /g, '') : '';
                if (r.L === 'garland' || r.L === 'wreath' || (r.L === 'shrub' && !r.col)) { displayCol = 'Green'; } 
                else if (r.L === 'cords') { displayCol = 'Black'; } 
                else { if (nrCol.includes('multi') || nrCol.includes('red/blue') || nrCol === 'm') { displayCol = 'Multi'; } else if (r.col === '') { displayCol = 'Warm White'; } else { displayCol = r.col; } }
                o.fillText(displayCol, x, y + FOOTER_ROW_H/2); x += OUT_W * cols[5].w;
                o.fillText(r.notes || '-', x, y + FOOTER_ROW_H/2); y += FOOTER_ROW_H;
                o.strokeStyle = '#334155'; o.lineWidth = 0.5; o.beginPath(); o.moveTo(12, y); o.lineTo(OUT_W - 12, y); o.stroke();
            });
        }
    } finally { scale = oldScale; panX = oldPanX; panY = oldPanY; ctx = originalCtx; }
    return { url: out.toDataURL('image/png'), width: OUT_W * DPI, height: OUT_H * DPI };
}

function collectRows() {
    const rows = [];
    const EXCLUDED_LAYERS = ['label', 'custom_icon', 'bow', 'cords', 'powersource', 'threeway'];
    Object.keys(data).forEach(L => {
        if (EXCLUDED_LAYERS.includes(L)) return;
        data[L].forEach(it => {
            if (it.label && it.label.trim() !== '') {
                rows.push({ 
                    L: L, label: it.label, ft: it.ft || '', bulbs: it.bulbs || '', col: it.col || '', clip: it.clip || '', notes: it.notes || '', fra: it.fra || false, gguard: it.gguard || false,
                    kind: it.kind 
                });
            }
        });
    });
    return rows;
}

function initializeUI() {
    document.getElementById('inputAllCol').oninput = (e) => {
        const v = e.target.value;
        Object.keys(data).forEach(k => { data[k].forEach(it => { if(it.label) it.col = v; }); });
        requestRender(); 
    };
    buildTools(); 
}

document.addEventListener('DOMContentLoaded', () => {
    initializeUI(); initializeAndSizeContext();
    document.getElementById('btnRelabelIDs').onclick = relabelIds;
    document.getElementById('gPickImg').onclick = () => document.getElementById('gImg').click();
    document.getElementById('gPickBlank').onclick = startBlankMap;
    document.getElementById('gPickMap').onclick = () => document.getElementById('gMap').click();
    document.getElementById('gOpenGallery').onclick = openGallery;
    document.getElementById('closeGateBtn').onclick = unlock;
});
})();
</script>
</body>
</html>
