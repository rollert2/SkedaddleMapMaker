<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Skedaddle Mobile Map Maker</title>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, interactive-widget=resizes-content"/>
<meta name="theme-color" content="#0f172a">

<!-- Fonts -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

<!-- Libraries -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="https://unpkg.com/lucide@latest"></script>
<script src="https://accounts.google.com/gsi/client" async defer></script>
<script src="https://apis.google.com/js/api.js"></script>
<script src="https://www.google.com/jsapi?autoload={'modules':[{'name':'picker','version':'1.0','callback':'pickerLoaded'}]}"></script>

<style>
:root {
    --bg: #0f172a;
    --panel: #1e293b;
    --panel-hover: #334155;
    --text: #f1f5f9;
    --text-muted: #94a3b8;
    --accent: #3b82f6;
    --accent-hover: #2563eb;
    --border: #334155;
    --border-highlight: #475569;
    --danger: #ef4444;
    --success: #22c55e;
    --warning: #eab308;
    --font-main: 'Inter', system-ui, -apple-system, sans-serif;
    --festive-gold: #fbbf24;
    --festive-red: #ef4444;
}

* { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
html, body { height: 100%; height: 100dvh; overflow: hidden; background: var(--bg); color: var(--text); font-family: var(--font-main); margin: 0; }

body.blurred #app { filter: blur(12px); pointer-events: none; transition: filter 0.3s ease; }

#gate {
    position: fixed; inset: 0; display: flex; align-items: center; justify-content: center; z-index: 999;
    background: radial-gradient(circle at center, rgba(15, 23, 42, 0.9), #0f172a);
    backdrop-filter: blur(10px);
    transition: opacity 0.3s, visibility 0.3s;
    padding: 16px;
}
#gate.hide { opacity: 0; visibility: hidden; pointer-events: none; }

.gcard {
    background: rgba(30, 41, 59, 0.8);
    border: 1px solid var(--border-highlight);
    border-radius: 24px;
    padding: 40px;
    width: min(480px, 100%);
    text-align: center;
    box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5);
    position: relative;
    overflow: hidden;
}
.gcard::before {
    content: ''; position: absolute; top: 0; left: 0; right: 0; height: 4px;
    background: linear-gradient(90deg, var(--festive-red), var(--festive-gold), var(--success));
}

.gcard h2 {
    margin: 16px 0 8px; font-size: 28px; font-weight: 700; letter-spacing: -0.5px;
    background: linear-gradient(135deg, #fff 0%, #cbd5e1 100%);
    -webkit-background-clip: text; -webkit-text-fill-color: transparent;
}
.gcard p { margin: 0 0 32px; color: var(--text-muted); font-size: 15px; line-height: 1.5; }

.close-btn {
    position: absolute; top: 16px; right: 16px; background: transparent; border: none;
    color: var(--text-muted); cursor: pointer; padding: 8px; border-radius: 50%;
    transition: all 0.2s; display: none;
}
.close-btn:hover { background: var(--panel-hover); color: var(--text); }

.grow { display: flex; flex-direction: column; gap: 12px; }

.gbtn {
    background: var(--panel); border: 1px solid var(--border); color: var(--text);
    padding: 16px; border-radius: 12px; cursor: pointer; font-size: 15px; font-weight: 600;
    display: flex; align-items: center; justify-content: center; gap: 12px;
    transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
}
.gbtn:hover { background: var(--panel-hover); border-color: var(--border-highlight); transform: translateY(-1px); }
.gbtn:active { transform: translateY(0); }
.gbtn:disabled { opacity: 0.5; cursor: not-allowed; pointer-events: none; }

.grow input[type=file] { position: absolute; width: 0; height: 0; opacity: 0; }

#app { display: flex; flex-direction: column; height: 100%; background: var(--bg); }

header {
    flex: 0 0 64px; display: flex; align-items: center; gap: 8px; padding: 0 16px;
    background: var(--panel); border-bottom: 1px solid var(--border);
    overflow-x: auto; white-space: nowrap; -webkit-overflow-scrolling: touch; scrollbar-width: none;
    z-index: 30; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
}
header::-webkit-scrollbar { display: none; }

#logoBtn { background: none; border: none; padding: 0; cursor: pointer; margin-right: 12px; }
#logo { width: 40px; height: 40px; border-radius: 10px; border: 1px solid var(--border); }
h1 { margin: 0 16px 0 0; font-size: 18px; font-weight: 600; color: var(--text); display: inline-block; vertical-align: middle; }

.btn {
    background: transparent; border: 1px solid transparent; color: var(--text-muted);
    border-radius: 8px; height: 40px; padding: 0 12px; cursor: pointer;
    display: inline-flex; align-items: center; justify-content: center; gap: 8px;
    font-size: 13px; font-weight: 500; transition: all 0.2s; white-space: nowrap;
}
.btn:hover:not(:disabled) { background: var(--panel-hover); color: var(--text); }
.btn:disabled { opacity: 0.4; cursor: not-allowed; }
.btn.toggled { background: rgba(59, 130, 246, 0.15); border-color: rgba(59, 130, 246, 0.3); color: var(--accent); }

/* Night Mode Glow Style */
.tool.night-glow {
    box-shadow: 0 0 15px rgba(168, 85, 247, 0.5), inset 0 0 5px rgba(168, 85, 247, 0.5);
    border-color: #a855f7 !important;
    color: #a855f7 !important;
}

#btnComplete.selectable { 
    color: var(--success); 
    background: rgba(34, 197, 94, 0.1); 
    border-color: rgba(34, 197, 94, 0.3); 
    opacity: 1;
}

#selectionQuickEdit {
    display: none;
    align-items: center;
    gap: 8px;
    background: var(--bg);
    padding: 4px 12px;
    border-radius: 12px;
    border: 1px solid var(--border-highlight);
    margin: 0 8px;
}

.pill {
    background: rgba(59, 130, 246, 0.1); border: 1px solid rgba(59, 130, 246, 0.2);
    color: var(--accent); border-radius: 20px; padding: 6px 16px; font-size: 12px; font-weight: 600;
    cursor: pointer; transition: all 0.2s; display: inline-flex; align-items: center; justify-content: center;
    margin-right: 8px;
}
.pill:hover { background: rgba(59, 130, 246, 0.2); }

.wrap { flex: 1; display: flex; position: relative; overflow: hidden; }
main { flex: 1; display: flex; flex-direction: column; position: relative; background: #050505; }

.canvasWrap {
    flex: 1; display: flex; align-items: center; justify-content: center; overflow: hidden; position: relative;
    background: #0f172a;
    background-image: radial-gradient(#1e293b 1px, transparent 1px);
    background-size: 20px 20px;
}
canvas {
    position: absolute; top: 0; left: 0; width: 100%; height: 100%;
    background: transparent; touch-action: none; display: block;
    box-shadow: 0 0 0 1px var(--border);
}
body.white-bg .canvasWrap { background: #ffffff; background-image: none; }

/* Scissor cursor for Splice Mode */
body.splice-cursor .canvasWrap {
    cursor: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='24' height='24' viewBox='0 0 24 24' fill='none' stroke='white' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Ccircle cx='6' cy='6' r='3'/%3E%3Ccircle cx='6' cy='18' r='3'/%3E%3Cline x1='20' y1='4' x2='8.12' y2='15.88'/%3E%3Cline x1='14.47' y1='14.48' x2='20' y2='20'/%3E%3C/svg%3E") 6 6, auto;
}

aside {
    width: 320px; flex-shrink: 0; background: var(--panel); border-right: 1px solid var(--border);
    display: flex; flex-direction: column; overflow-y: auto; padding: 16px;
    transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1), margin-left 0.3s cubic-bezier(0.4, 0, 0.2, 1); 
    z-index: 20;
}
aside.closed { margin-left: -320px; }

.overlay {
    position: fixed; inset: 0; background: rgba(0, 0, 0, 0.5); backdrop-filter: blur(2px);
    z-index: 19; opacity: 0; pointer-events: none; transition: opacity 0.3s;
}
.overlay.show { opacity: 1; pointer-events: auto; }

.group { background: var(--bg); border: 1px solid var(--border); border-radius: 12px; padding: 16px; margin-bottom: 16px; }
.group h3 {
    margin: 0 0 12px; font-size: 11px; font-weight: 700; color: var(--text-muted);
    text-transform: uppercase; letter-spacing: 0.05em;
}

.input {
    width: 100%; background: var(--panel); border: 1px solid var(--border); color: var(--text);
    border-radius: 8px; padding: 10px 12px; font-size: 14px; font-family: inherit;
    transition: border-color 0.2s;
}
.input:focus { outline: none; border-color: var(--accent); }
textarea.input { resize: vertical; min-height: 80px; }
.row2 { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
.lbl-row { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 4px; font-size: 11px; color: var(--text-muted); padding-left: 2px; }

.acc { border: 1px solid var(--border); border-radius: 8px; background: var(--panel); margin-bottom: 8px; overflow: hidden; }
.accHead {
    display: flex; align-items: center; justify-content: space-between; cursor: pointer;
    padding: 12px 14px; font-size: 14px; font-weight: 500; color: var(--text);
    transition: background 0.2s;
}
.accHead:hover { background: var(--panel-hover); }
.accHead svg { transition: transform 0.2s; width: 16px; height: 16px; color: var(--text-muted); }
.acc.open .accHead svg { transform: rotate(90deg); color: var(--accent); }
.accBody { display: none; padding: 10px; border-top: 1px solid var(--border); background: var(--bg); }
.acc.open .accBody { display: block; }

.grid4 { display: grid; grid-template-columns: repeat(auto-fill, minmax(75px, 1fr)); gap: 8px; }
.tool {
    background: var(--panel); border: 1px solid var(--border); color: var(--text-muted);
    border-radius: 8px; padding: 10px 4px; text-align: center; font-size: 11px;
    cursor: pointer; min-height: 60px; display: flex; flex-direction: column;
    align-items: center; justify-content: center; gap: 6px;
    transition: all 0.2s;
}
.tool svg { width: 20px; height: 20px; margin-bottom: 2px; }
.tool:hover { background: var(--panel-hover); color: var(--text); border-color: var(--border-highlight); }
.tool.active {
    background: rgba(59, 130, 246, 0.1); border-color: var(--accent); color: var(--accent);
    box-shadow: 0 0 0 1px var(--accent);
}

/* Visibility UI Styles - Matched to Toolbox Accordion */
.vis-acc { border: 1px solid var(--border); border-radius: 8px; background: var(--panel); margin-bottom: 8px; overflow: hidden; }
.vis-accHead {
    display: flex; align-items: center; gap: 10px; cursor: pointer;
    padding: 12px 14px; font-size: 13px; font-weight: 600; color: var(--text);
    transition: background 0.2s;
}
.vis-accHead:hover { background: var(--panel-hover); }
.vis-accHead input[type="checkbox"] { 
    width: 16px; height: 16px; accent-color: var(--accent); 
    cursor: pointer; position: relative; z-index: 5;
}
.vis-accHead span { flex: 1; }
.vis-accHead i { transition: transform 0.2s; width: 14px; height: 14px; color: var(--text-muted); }
.vis-acc.open .vis-accHead i { transform: rotate(90deg); color: var(--accent); }
.vis-accBody { display: none; padding: 4px 0; border-top: 1px solid var(--border); background: var(--bg); }
.vis-acc.open .vis-accBody { display: block; }
.vis-row { 
    display: flex; align-items: center; gap: 10px; padding: 8px 12px 8px 40px; 
    font-size: 12px; transition: background 0.1s;
}
.vis-row:hover { background: var(--panel-hover); }
.vis-row input { accent-color: var(--accent); cursor: pointer; }

.slider-container { padding: 4px 0 12px; position: relative; }
input[type=range].input {
    -webkit-appearance: none; appearance: none; height: 6px; background: var(--border);
    border-radius: 3px; border: none; padding: 0;
}
input[type=range].input::-webkit-slider-thumb {
    -webkit-appearance: none; appearance: none; width: 18px; height: 18px;
    background: var(--accent); border: 4px solid var(--bg); border-radius: 50%;
    cursor: pointer; box-shadow: 0 0 0 1px var(--border-highlight); transition: transform 0.1s;
}
input[type=range].input::-webkit-slider-thumb:hover { transform: scale(1.1); }

/* Eye icon in table */
.vis-toggle { cursor: pointer; color: var(--accent); transition: all 0.2s; padding: 4px; border-radius: 4px; }
.vis-toggle:hover { background: var(--panel-hover); }
.vis-toggle.faded { color: var(--text-muted); opacity: 0.4; }

.pop {
    position: fixed; background: var(--panel); border: 1px solid var(--accent);
    padding: 8px; border-radius: 12px; display: none; gap: 4px; z-index: 9999;
    box-shadow: 0 10px 25px rgba(0,0,0,0.5);
}
.pop button {
    background: var(--bg); border: 1px solid var(--border); color: white;
    padding: 10px 14px; border-radius: 8px; cursor: pointer; font-weight: 600;
    transition: all 0.2s; min-width: 50px;
}
.pop button:hover { background: var(--accent); border-color: white; }

#modalBack, #modalAlert, #modalGallery {
    position: fixed; inset: 0; background: rgba(0,0,0,0.7); z-index: 10000;
    display: none; align-items: center; justify-content: center; backdrop-filter: blur(4px);
}
.card {
    background: var(--panel); border: 1px solid var(--border); border-radius: 16px;
    padding: 24px; width: 90%; max-width: 450px; text-align: center;
    box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.3);
    max-height: 80vh; display: flex; flex-direction: column;
}

/* Enhanced Gallery Styling */
.gallery-card { max-width: 900px; width: 95%; height: 85vh; }
.gallery-list {
    overflow-y: auto; flex: 1; text-align: left; margin: 16px 0;
    border: 1px solid var(--border); border-radius: 16px; background: rgba(0,0,0,0.1);
    display: grid; grid-template-columns: repeat(auto-fill, minmax(260px, 1fr)); gap: 16px; padding: 16px;
}
.gallery-item {
    background: var(--panel); border: 1px solid var(--border); border-radius: 16px;
    padding: 10px; cursor: pointer; transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
    display: flex; flex-direction: column; gap: 10px;
    box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1);
}
.gallery-item:hover { transform: translateY(-4px); border-color: var(--accent); box-shadow: 0 10px 15px -3px rgba(59, 130, 246, 0.3); }
.gallery-item .thumb {
    width: 100%; aspect-ratio: 16/9; background: #050a15; border-radius: 10px; overflow: hidden;
    display: flex; align-items: center; justify-content: center;
    border: 1px solid rgba(255,255,255,0.05);
}
.gallery-item .thumb img { width: 100%; height: 100%; object-fit: cover; }
.gallery-item .info { display: flex; align-items: center; justify-content: space-between; padding: 0 4px; }
.gallery-item span { font-size: 14px; font-weight: 600; color: var(--text); overflow: hidden; text-overflow: ellipsis; white-space: nowrap; flex: 1; }
.gallery-item i { color: var(--accent); width: 18px; }

#lblEditor { position: fixed; z-index: 5000; transform: translate(-50%, -120%); }
#lblInput {
    background: var(--panel); color: white; border: 1px solid var(--accent);
    padding: 6px 12px; border-radius: 8px; font-size: 13px; min-width: 100px; text-align: center;
    box-shadow: 0 4px 15px rgba(0,0,0,0.3);
}

@media (max-width: 900px) {
    aside {
        position: absolute; top: 0; bottom: 0; left: 0; 
        margin-left: 0 !important; 
        transform: translateX(-105%); 
        box-shadow: 10px 0 30px rgba(0,0,0,0.5);
    }
    aside.open { transform: translateX(0); }
    h1 { display: none; }
    header { justify-content: space-between; }
    header .btn { padding: 0 8px; }
    .btn span { display: none; }
    .btn i { margin: 0; }
    #selectionQuickEdit span { display: none; }
    .gallery-list { grid-template-columns: 1fr; }
    .gallery-card { height: 95vh; }
}

#lenWrap {
    background: var(--panel); border-top: 1px solid var(--border);
    position: absolute; bottom: 0; left: 0; right: 0; max-height: 60%;
    display: flex; flex-direction: column; z-index: 25;
    transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1); transform: translateY(calc(100% - 48px));
    box-shadow: 0 -4px 20px rgba(0,0,0,0.3);
}
#lenWrap.open { transform: translateY(0); }
#lenHead {
    display: flex; justify-content: space-between; align-items: center; padding: 0 16px;
    background: var(--panel); cursor: pointer; height: 48px; flex: 0 0 48px;
    border-bottom: 1px solid var(--border); font-size: 14px; font-weight: 600;
}
#lenBody { overflow-y: auto; flex: 1; background: var(--bg); padding-bottom: 30px; }
table { width: 100%; border-collapse: collapse; }
th, td { border-bottom: 1px solid var(--border); padding: 12px 8px; font-size: 13px; text-align: left; vertical-align: middle; }
th { color: var(--text-muted); font-weight: 600; background: var(--panel); position: sticky; top: 0; z-index: 2; font-size: 12px; text-transform: uppercase; }
td .edit { background: var(--panel); border: 1px solid var(--border); color: var(--text); border-radius: 6px; padding: 6px 8px; width: 100%; }
</style>
</head>
<body class="blurred">
<div id="gate">
  <div class="gcard">
    <button class="close-btn" id="closeGateBtn" title="Continue Editing"><i data-lucide="x"></i></button>
    <div style="margin-bottom: 20px;">
        <img src="https://i.imgur.com/zdJfkpg.png" alt="logo" style="width:80px; height:80px; border-radius:16px; box-shadow: 0 10px 30px rgba(0,0,0,0.3); border: 2px solid var(--border);">
    </div>
    <h2>Christmas Map Maker</h2>
    <p>Design stunning holiday light displays.<br>Upload a photo or start from scratch.</p>
    <div class="grow">
      <div style="display:flex; gap:8px;">
          <button id="gPickImg" class="gbtn" style="flex:1"><i data-lucide="image-plus"></i> Upload Property Photo</button>
          <a href="https://earth.google.com/web/" target="_blank" class="gbtn" style="width:60px; padding:16px 0;" title="Google Earth"><i data-lucide="globe"></i></a>
      </div>
      <button id="gPickBlank" class="gbtn"><i data-lucide="file-plus"></i> Start Blank Map</button>
      <button id="gPickMap" class="gbtn"><i data-lucide="folder-open"></i> Load Existing Map</button>
      <button id="gOpenGallery" class="gbtn"><i data-lucide="layout-grid"></i> Map Gallery (Cloud)</button>
      <button id="gLoadDrive" class="gbtn" disabled><i data-lucide="cloud"></i> Load from Drive</button>
      
      <input id="gImg" type="file" accept="image/*"/>
      <input id="gMap" type="file" accept=".skmap,.json,application/json"/>
    </div>
  </div>
</div>

<div id="modalBack">
    <div class="card">
        <h3>Unsaved Changes</h3>
        <p>You have unsaved work. Are you sure you want to leave?</p>
        <div class="row"><button id="btnStay" class="btn-stay">Stay</button><button id="btnLeave" class="btn-leave">Leave</button></div>
    </div>
</div>
<div id="modalAlert">
    <div class="card">
        <h3>Notice</h3>
        <p id="alertMsg">Message</p>
        <div class="row"><button onclick="document.getElementById('modalAlert').style.display='none'" class="btn-ok">OK</button></div>
    </div>
</div>

<div id="modalGallery">
    <div class="card gallery-card">
        <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:16px;">
            <h3 style="margin:0">Cloud Storage</h3>
            <span id="galleryCount" style="font-size:12px; color:var(--text-muted); font-weight:600">0 Maps</span>
        </div>
        <div style="margin-bottom:12px;">
            <input type="text" id="gallerySearch" class="input" placeholder="Search by project name..." style="background:var(--bg); border-color:var(--border-highlight)"/>
        </div>
        <div id="galleryList" class="gallery-list">
            <div style="padding:40px; text-align:center; color:var(--text-muted); grid-column: 1 / -1;">
                <i data-lucide="loader-2" style="width:32px; height:32px; animation: spin 1.5s linear infinite;"></i>
                <div style="margin-top:12px">Syncing cloud library...</div>
            </div>
        </div>
        <div class="row"><button onclick="document.getElementById('modalGallery').style.display='none'" class="btn-stay" style="background:var(--panel-hover)">Return to Main</button></div>
    </div>
</div>

<div id="lblEditor"><input id="lblInput" placeholder="Note/Ft"></div>

<div id="app">
<header>
  <button id="logoBtn" title="Menu"><img id="logo" src="https://i.imgur.com/zdJfkpg.png" alt=""></button>
  <h1>Skedaddle</h1>
  <span id="modeTag" class="pill" onclick="toggleMenu()">Draw</span>
  
  <div style="flex:1"></div>

  <!-- Dynamic Selection Area -->
  <div id="selectionQuickEdit">
      <span id="editLabelPrefix" style="font-size:12px; color:var(--text-muted); font-weight:600">ID:</span>
      <input id="quickEditPrefix" class="input" style="width:70px; height:32px; padding:4px 8px; font-size:13px" placeholder="F1"/>
      
      <!-- Individual Item Scale Slider -->
      <div id="itemScaleWrap" style="display:none; align-items:center; gap:8px; margin-left:8px; border-left:1px solid var(--border); padding-left:8px;">
          <span style="font-size:11px; color:var(--text-muted); font-weight:600">SCALE:</span>
          <input id="itemScaleSlider" type="range" class="input" min="0.2" max="5" step="0.1" value="1.0" style="width:80px; height:24px; padding:0"/>
      </div>

      <button id="moveLabelToggleBtn" class="btn" title="Move Label"><i data-lucide="move-diagonal"></i></button>
      <button id="quickDeleteBtn" class="btn" style="color:var(--danger); height:32px" title="Delete Selected"><i data-lucide="trash-2"></i></button>
  </div>

  <button id="btnDraw" class="btn" title="Draw Mode"><i data-lucide="pencil"></i><span>Draw</span></button>
  <button id="btnSelect" class="btn" title="Select Mode"><i data-lucide="mouse-pointer-2"></i><span>Select</span></button>
  <button id="btnMoveCanvas" class="btn" title="Pan Canvas"><i data-lucide="move"></i><span>Pan</span></button>
  <div style="width:1px; height:24px; background:var(--border); margin:0 4px"></div>
  <button id="btnUndo" class="btn" title="Undo"><i data-lucide="undo-2"></i></button>
  
  <button id="btnComplete" class="btn" disabled title="Finish Line"><i data-lucide="check-circle"></i></button>
  
  <button id="btnRedo" class="btn" disabled title="Redo"><i data-lucide="redo-2"></i></button>
  <div style="width:1px; height:24px; background:var(--border); margin:0 4px"></div>
  
  <button id="btnSwag" class="btn" style="display:none" title="Garland Swag"><i data-lucide="waves"></i><span>Swag</span></button>
  <button id="btnPillar" class="btn" style="display:none" title="Pillar Mode"><i data-lucide="columns-2"></i><span>Pillar</span></button>
  
  <button id="btnSnap" class="btn toggled" title="Snap to Points"><i data-lucide="magnet"></i></button>
  <button id="btnFit" class="btn" title="Reset View"><i data-lucide="maximize"></i></button>
  
  <div style="width:1px; height:24px; background:var(--border); margin:0 4px"></div>
  
  <button id="btnSaveAll" class="btn" title="Save All"><i data-lucide="save"></i><span>Save</span></button>
  <button id="btnSaveImageOnly" class="btn" title="Export PDF"><i data-lucide="file-down"></i></button>
  <button id="btnSaveMapOnly" class="btn" title="Save File"><i data-lucide="download"></i></button>
</header>

<div class="wrap">
  <div id="overlay" class="overlay"></div>
  <aside id="side">
    <div class="group">
      <h3>Toolbox</h3>
      <div id="accWrap"></div>
    </div>
    
    <div class="group">
        <h3>Visibility Settings</h3>
        <div id="visibilityMenu">
            <!-- Populated by JS -->
        </div>
    </div>

    <div class="group">
        <h3>Display Preferences</h3>
        <div class="acc" id="dispAcc">
            <div class="accHead" onclick="this.parentElement.classList.toggle('open')">
                <b>Rendering & Scale</b><i data-lucide="chevron-right"></i>
            </div>
            <div class="accBody" style="padding:16px;">
                <div style="font-size:11px; margin-bottom:4px; color:var(--text-muted); font-weight:700; text-transform:uppercase;">General Style</div>
                <div style="font-size:11px; margin-bottom:4px; color:var(--text-muted);">Line Thickness</div>
                <div class="slider-container">
                    <input id="lineScaleInput" type="range" class="input" min="0.5" max="3" step="0.1" value="1.0"/>
                    <div style="font-size:10px; color:var(--text-muted); display:flex; justify-content:space-between; margin-top:4px;">
                        <span>Thin</span><span id="lineScaleValue" style="color:var(--text)">1.0x</span><span>Thick</span>
                    </div>
                </div>
                <div style="font-size:11px; margin-bottom:4px; color:var(--text-muted);">Label Size</div>
                <div class="slider-container">
                    <input id="labelScaleInput" type="range" class="input" min="0.5" max="5" step="0.1" value="3.0"/>
                    <div style="font-size:10px; color:var(--text-muted); display:flex; justify-content:space-between; margin-top:4px;">
                        <span>Small</span><span id="labelScaleValue" style="color:var(--text)">3.0x</span><span>Large</span>
                    </div>
                </div>
                <div style="font-size:11px; margin-bottom:4px; color:var(--text-muted);">Background Blur</div>
                <div class="slider-container">
                    <input id="bgBlurInput" type="range" class="input" min="0" max="100" step="1" value="0"/>
                    <div style="font-size:10px; color:var(--text-muted); display:flex; justify-content:space-between; margin-top:4px;">
                        <span>Clear</span><span id="bgBlurValue" style="color:var(--text)">0%</span><span>Blurry</span>
                    </div>
                </div>
                <div style="height:1px; background:var(--border); margin:12px 0;"></div>
                <div style="font-size:11px; margin-bottom:4px; color:var(--text-muted); font-weight:700; text-transform:uppercase;">Flow Arrows</div>
                <div style="font-size:11px; margin-bottom:4px; color:var(--text-muted);">Frequency</div>
                <div class="slider-container">
                    <input id="arrowFreqInput" type="range" class="input" min="0.2" max="1.5" step="0.1" value="1.0"/>
                    <div style="font-size:10px; color:var(--text-muted); display:flex; justify-content:space-between; margin-top:4px;">
                        <span>Few</span><span id="arrowFreqValue" style="color:var(--text)">1.0x</span><span>Many</span>
                    </div>
                </div>
                <div style="font-size:11px; margin-bottom:4px; color:var(--text-muted);">Arrow Size</div>
                <div class="slider-container">
                    <input id="arrowScaleInput" type="range" class="input" min="0.5" max="3" step="0.1" value="1.0"/>
                    <div style="font-size:10px; color:var(--text-muted); display:flex; justify-content:space-between; margin-top:4px;">
                        <span>Small</span><span id="arrowScaleValue" style="color:var(--text)">1.0x</span><span>Large</span>
                    </div>
                </div>
                <div style="height:1px; background:var(--border); margin:12px 0;"></div>
                <div style="font-size:11px; margin-bottom:4px; color:var(--text-muted); font-weight:700; text-transform:uppercase;">Advanced Scaling</div>
                <div style="font-size:11px; margin-bottom:4px; color:var(--text-muted);">Global Decor Scale</div>
                <div class="slider-container">
                    <input id="iconScaleInput" type="range" class="input" min="0.5" max="5" step="0.1" value="1.5"/>
                    <div style="font-size:10px; color:var(--text-muted); display:flex; justify-content:space-between; margin-top:4px;">
                        <span>Small</span><span id="iconScaleValue" style="color:var(--text)">1.5x</span><span>Huge</span>
                    </div>
                </div>
                <div style="font-size:11px; margin-bottom:4px; color:var(--text-muted);">C9 Tree Scale</div>
                <div class="slider-container"><input id="c9TreeScaleInput" type="range" class="input" min="0.5" max="5" step="0.1" value="1.0"/></div>
                <div style="font-size:11px; margin-bottom:4px; color:var(--text-muted);">Mini Tree Scale</div>
                <div class="slider-container"><input id="miniTreeScaleInput" type="range" class="input" min="0.5" max="5" step="0.1" value="1.0"/></div>
                <div style="font-size:11px; margin-bottom:4px; color:var(--text-muted);">ToL Scale</div>
                <div class="slider-container"><input id="tolScaleInput" type="range" class="input" min="0.5" max="5" step="0.1" value="1.0"/></div>
                <div style="font-size:11px; margin-bottom:4px; color:var(--text-muted);">Wreath Scale</div>
                <div class="slider-container"><input id="wreathScaleInput" type="range" class="input" min="0.5" max="5" step="0.1" value="1.0"/></div>
                <div style="font-size:11px; margin-bottom:4px; color:var(--text-muted);">Bow Scale</div>
                <div class="slider-container"><input id="bowScaleInput" type="range" class="input" min="0.5" max="5" step="0.1" value="1.0"/></div>
                <div style="font-size:11px; margin-bottom:4px; color:var(--text-muted);">Power/Junction Scale</div>
                <div class="slider-container">
                    <input id="junctionScaleInput" type="range" class="input" min="0.5" max="3" step="0.1" value="1.0"/>
                    <div style="font-size:10px; color:var(--text-muted); display:flex; justify-content:space-between; margin-top:4px;">
                        <span>Small</span><span id="junctionScaleValue" style="color:var(--text)">1.0x</span><span>Large</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="group">
      <h3>Project Details</h3>
      <div class="grow" style="gap:8px">
          <input id="customer" class="input" placeholder="Customer Name"/>
          <input id="address" class="input" placeholder="Property Address"/>
          <textarea id="jobNotes" class="input" placeholder="Installation notes..."></textarea>
      </div>
      <div style="font-size:11px; color:var(--text-muted); margin-top:12px; font-weight:600; text-transform:uppercase">Bulk Colour</div>
      <input id="inputAllCol" class="input" placeholder="Set color for all items..." style="margin-top:6px">
    </div>
    
    <div class="group">
        <h3>Timers</h3>
        <button id="btnCustomerControlled" class="btn" style="width:100%; margin-bottom:12px; justify-content:center;">Customer Controlled</button>
        <div id="timerInputs">
            <div class="lbl-row"><span>On</span><span>Off</span></div>
            <div class="row2"><input id="on1" type="time" class="input"/><input id="off1" type="time" class="input"/></div>
            <div class="lbl-row" style="margin-top:8px"><span>On</span><span>Off</span></div>
            <div class="row2"><input id="on2" type="time" class="input"/><input id="off2" type="time" class="input"/></div>
            <button id="btnStd" class="btn" style="width:100%; margin-top:12px; justify-content:center; font-size:12px;">Set Standard Times</button>
        </div>
    </div>
    
    <div class="group">
        <h3>Legend</h3>
        <dl class="clip-legend">
            <dt><div class="leg-sq"></div> PS</dt><dd>Power Source</dd>
            <dt><div class="leg-tri"></div> 3W</dt><dd>3-Way Adapter</dd>
            <dt>ST</dt><dd>Shingle Tab (Eaves/Ridges)</dd>
            <dt>T</dt><dd>Tuff Clip (Fascia)</dd>
            <dt>Mag</dt><dd>Magnetic Clip</dd>
            <dt>FRA</dt><dd>Flat Roof Adapter</dd>
            <dt>GG</dt><dd>Gutter Guard</dd>
        </dl>
    </div>
  </aside>

  <main>
    <div class="canvasWrap"><canvas id="cv"></canvas></div>
    <div id="lenWrap">
      <div id="lenHead">
          <div style="display:flex; align-items:center; gap:8px"><i data-lucide="ruler"></i> Line Information <span style="font-weight:400; color:var(--text-muted); font-size:12px">(Tap to view)</span></div>
          <i data-lucide="chevron-up" id="lenChevron"></i>
      </div>
      <div id="lenBody">
        <div style="padding:12px 16px; border-bottom:1px solid var(--border); display:flex; align-items:center; gap:16px; flex-wrap:wrap">
             <label style="display:flex; align-items:center; gap:6px; font-size:13px; color:var(--text); cursor:pointer;">
                <input id="chkAutoCalc" type="checkbox" checked style="accent-color:var(--accent)"/> Auto-calculate bulbs/feet
             </label>
             <button id="btnLineSplice" class="btn" style="height:32px; font-size:12px; margin-left:auto"><i data-lucide="scissors"></i> Line Splice</button>
             <button id="btnMergeLines" class="btn" style="height:32px; font-size:12px;"><i data-lucide="merge"></i> Merge Lines</button>
             <button id="btnRelabelIDs" class="btn" style="height:32px; font-size:12px;"><i data-lucide="list-ordered"></i> Relabel IDs</button>
        </div>

        <div style="overflow-x:auto">
          <table id="matTable">
            <thead><tr><th style="width:30px"></th><th>Type</th><th style="width:60px">ID</th><th>Ft</th><th>Bulbs</th><th>Clip</th><th>Colour</th><th>Notes</th><th style="width:70px"></th></tr></thead>
            <tbody id="lenRows"></tbody>
          </table>
        </div>
      </div>
    </div>
  </main>
</div>
</div>

<div id="wreathPop" class="pop">
  <button data-bow="none">No Bow</button><button data-bow="bottom">Bot Bow</button><button data-bow="top">Top Bow</button>
</div>
<div id="tolPop" class="pop">
  <button data-size="3">3'</button><button data-size="6">6'</button><button data-size="9">9'</button><button data-size="12">12'</button><button data-size="15">15'</button>
</div>

<div id="imgUploadPop" class="pop" style="flex-direction: column; padding: 12px; min-width: 200px;">
  <label for="iconFile" class="btn" style="margin-bottom: 8px; justify-content:center"><i data-lucide="upload"></i> Upload Image</label>
  <input type="file" id="iconFile" accept="image/*" style="display:none;"/>
  <button id="cancelIconUpload" class="btn" style="justify-content:center">Cancel</button>
</div>

<script>
(()=>{
    
const iconMap = {
    'ridges': 'home',
    'fascia': 'minus',
    'peaks': 'triangle',
    'groundstakes': 'map-pin',
    'shrub': 'cloud',
    'windows': 'layout-grid',
    'garland': 'waves',
    'wreath': 'circle-dashed',
    'wreath32': 'circle',
    'wreath42': 'circle-dot',
    'bow': 'gift',
    'tree': 'tree-pine',
    'tree:Trunk + Branch (Minis)': 'tree-deciduous',
    'tree:Trunk + Canopy (Minis)': 'tree-pine',
    'tree:C9 Tree': 'triangle', 
    'tree:ToL': 'sprout',
    'cords': 'plug',
    'powersource': 'zap',
    'threeway': 'git-fork',
    'label': 'type',
    'custom_icon': 'image',
    'night_mode': 'moon',
    'ai_detect': 'bot',
    'ghost_door': 'ghost'
};

const tp1 = "ghp_xSeuggnKkttH6z";
const tp2 = "TSfiTENK2bjTv7ya1TsWF7";

const githubConfig = {
    token: (tp1 + tp2).trim(),
    owner: "rollert2",
    repo: "SkedaddleMapMaker",
    path: "maps/",
};

async function saveToGitHub(filename, content, isBase64 = false) {
    if (!githubConfig.token || !githubConfig.owner || !githubConfig.repo) return;
    const url = `https://api.github.com/repos/${githubConfig.owner}/${githubConfig.repo}/contents/${githubConfig.path}${filename}`;
    try {
        let sha = null;
        const checkRes = await fetch(url, { headers: { "Authorization": `Bearer ${githubConfig.token}` } });
        if (checkRes.ok) {
            const data = await checkRes.json();
            sha = data.sha;
        }
        const body = {
            message: `Save map: ${filename}`,
            content: isBase64 ? content : btoa(unescape(encodeURIComponent(content))),
            sha: sha
        };
        const saveRes = await fetch(url, {
            method: "PUT",
            headers: {
                "Authorization": `Bearer ${githubConfig.token}`,
                "Content-Type": "application/json"
            },
            body: JSON.stringify(body)
        });
        if (!saveRes.ok) console.error("GitHub Save Error:", await saveRes.text());
    } catch (err) { console.error("GitHub Connection Failed:", err); }
}

let allGalleryMaps = [];

async function openGallery() {
    if (!githubConfig.token) { showAlert("GitHub token not configured."); return; }
    const modal = document.getElementById('modalGallery');
    const list = document.getElementById('galleryList');
    const search = document.getElementById('gallerySearch');
    const countLabel = document.getElementById('galleryCount');
    modal.style.display = 'flex';
    list.innerHTML = '<div style="padding:40px; text-align:center; color:var(--text-muted); grid-column: 1 / -1;"><i data-lucide="loader-2" style="width:32px; height:32px; animation: spin 1.5s linear infinite;"></i><div style="margin-top:12px">Syncing cloud library...</div></div>';
    if(window.lucide) lucide.createIcons();
    search.value = "";
    try {
        const url = `https://api.github.com/repos/${githubConfig.owner}/${githubConfig.repo}/contents/${githubConfig.path}`;
        const res = await fetch(url, { headers: { "Authorization": `Bearer ${githubConfig.token}` } });
        if (res.status === 404) {
            list.innerHTML = '<div style="padding:40px; text-align:center; color:var(--text-muted); grid-column: 1 / -1;">No maps found in cloud folder.</div>';
            countLabel.textContent = "0 Maps";
            return;
        }
        if (res.ok) {
            const files = await res.json();
            const mapFiles = Array.isArray(files) ? files.filter(f => f.name.endsWith('.skmap')) : [];
            mapFiles.sort((a, b) => a.name.toLowerCase().localeCompare(b.name.toLowerCase()));
            allGalleryMaps = mapFiles;
            countLabel.textContent = `${mapFiles.length} Maps`;
            renderGalleryItems(mapFiles);
        } else { 
            list.innerHTML = `<div style="padding:20px; text-align:center; color:var(--danger); grid-column: 1 / -1;">Error ${res.status}. Token likely revoked.</div>`; 
        }
    } catch (err) { list.innerHTML = '<div style="padding:20px; text-align:center; color:var(--danger); grid-column: 1 / -1;">Connection failed.</div>'; }
}

async function renderGalleryItems(maps) {
    const list = document.getElementById('galleryList');
    list.innerHTML = '';
    if (maps.length === 0) {
        list.innerHTML = '<div style="padding:40px; text-align:center; color:var(--text-muted); grid-column: 1 / -1;">No projects match your search.</div>';
        return;
    }
    maps.forEach(f => {
        const item = document.createElement('div');
        item.className = 'gallery-item';
        item.innerHTML = `
            <div class="thumb" id="thumb-${f.sha}">
                <div style="color:var(--text-muted); font-size:10px; display:flex; flex-direction:column; align-items:center; gap:8px">
                    <i data-lucide="image" style="width:20px; height:20px"></i>
                    <span>Rendering...</span>
                </div>
            </div>
            <div class="info">
                <span>${f.name.replace('.skmap', '')}</span>
                <i data-lucide="chevron-right" style="width:16px; height:16px"></i>
            </div>
        `;
        item.onclick = () => loadFromGitHub(f.download_url);
        list.appendChild(item);
        fetchThumbnail(f);
    });
    if(window.lucide) lucide.createIcons();
}

async function fetchThumbnail(fileMetadata) {
    try {
        const res = await fetch(fileMetadata.download_url);
        const data = await res.json();
        const thumbContainer = document.getElementById(`thumb-${fileMetadata.sha}`);
        if (thumbContainer && data.thumbnail) {
            thumbContainer.innerHTML = `<img src="${data.thumbnail}" alt="Preview">`;
        } else if (thumbContainer) {
            thumbContainer.innerHTML = `<div style="display:flex; flex-direction:column; align-items:center; gap:4px"><i data-lucide="image-off" style="width:24px; color:var(--text-muted)"></i><span style="font-size:9px; color:var(--text-muted)">No Preview</span></div>`;
            lucide.createIcons();
        }
    } catch (e) { }
}

document.getElementById('gallerySearch').oninput = (e) => {
    const term = e.target.value.toLowerCase();
    const filtered = allGalleryMaps.filter(m => m.name.toLowerCase().includes(term));
    renderGalleryItems(filtered);
};

async function loadFromGitHub(downloadUrl) {
    try {
        const res = await fetch(downloadUrl);
        const json = await res.json();
        const blob = new Blob([JSON.stringify(json)], { type: "application/json" });
        const file = new File([blob], "cloud_map.skmap");
        handleMap(file);
        document.getElementById('modalGallery').style.display = 'none';
    } catch (err) { showAlert("Error loading map content."); }
}

const CLIENT_ID = '746571343552-88ogvei1lvtq9ojq3te7fn06d1rlgut4.apps.googleusercontent.com';
const API_KEY = 'AIzaSyCBB6UWp5-FCB7VMpRKsjQh7sR42qd4SN0';
const APP_ID = '746571343552';
const GDRIVE_SCOPES = 'https://www.googleapis.com/auth/drive.file https://www.googleapis.com/auth/drive.appdata'; 
const MAP_MIME_TYPE = 'application/json';
const MAP_FILE_EXTENSION = '.skmap';

let accessToken = null;
let tokenClient = null;
let gapiReady = false;
let gisReady = false;

const gLoadDriveBtn = document.getElementById('gLoadDrive');

gapi.load('client:picker', async () => {
    try {
        await gapi.client.setApiKey(API_KEY);
        await gapi.client.load('drive', 'v3'); 
        gapiReady = true;
        const checkGis = setInterval(() => {
            if (window.google && window.google.accounts) {
                clearInterval(checkGis);
                initGis();
            }
        }, 100);
    } catch (err) { console.error("Error loading GAPI:", err); }
});

function initGis() {
    try {
        tokenClient = google.accounts.oauth2.initTokenClient({
            client_id: CLIENT_ID, scope: GDRIVE_SCOPES,
            callback: (response) => {
                if (response.error !== undefined) showAlert('Authorization Failed: ' + response.error);
                else { accessToken = response.access_token; updateDriveUI(true); }
            },
        });
        gisReady = true; checkApiReadiness();
    } catch (err) { console.error("Error initializing GIS:", err); }
}

function checkApiReadiness() {
    if (gapiReady && gisReady) {
        gLoadDriveBtn.disabled = false;
        const authClickHandler = () => tokenClient.requestAccessToken({ prompt: '' });
        gLoadDriveBtn.onclick = authClickHandler;
    }
}

function updateDriveUI(isAuthenticated) {
    if (isAuthenticated) {
        gLoadDriveBtn.innerHTML = '<i data-lucide="cloud"></i> Load from Drive';
        gLoadDriveBtn.onclick = () => createPicker('load');
        lucide.createIcons();
    }
}

async function createPicker(pickerType) {
    if (!accessToken || !gapiReady || !gisReady) { showAlert('Please sign in to Google Drive first.'); return; }
    let view = new google.picker.View(google.picker.ViewId.DOCS);
    view.setMimeTypes(MAP_MIME_TYPE + ',text/plain,application/octet-stream'); 
    view.setQuery(MAP_FILE_EXTENSION);
    const picker = new google.picker.PickerBuilder()
        .setAppId(APP_ID).setOAuthToken(accessToken).setDeveloperKey(API_KEY)
        .addView(view).setCallback(pickerCallback).build();
    picker.setVisible(true);
}

function pickerCallback(data) {
    if (data.action === google.picker.Action.PICKED) {
        const file = data.docs[0];
        loadFromDrive(file[google.picker.Document.ID]);
    }
}

async function loadFromDrive(fileId) {
    showAlert('Loading map from Google Drive...');
    try {
        const response = await gapi.client.drive.files.get({ fileId: fileId, alt: 'media' });
        const mapDataString = response.body;
        const file = new File([mapDataString], 'downloaded_map.skmap', { type: MAP_MIME_TYPE });
        handleMap(file); 
        document.getElementById('modalAlert').style.display = 'none';
    } catch (error) { showAlert('Error loading map content from Drive.'); }
}

const cats=[
    {name:"C9's",key:'c9',list:['fascia','peaks','ridges','groundstakes']},
    {name:'Minis',key:'min',list:['shrub','windows']},
    {name:'Greenery',key:'grn',list:['wreath32','wreath42','garland','bow']},
    {name:'Trees',key:'tre',list:['tree:Trunk + Branch (Minis)','tree:Trunk + Canopy (Minis)','tree:C9 Tree','tree:ToL']},
    {name:'Power',key:'pwr',list:['powersource','cords','threeway']},
    {name:'Specials', key:'spec', list:['label', 'custom_icon', 'ghost_door', 'night_mode', 'ai_detect']}
]; 
const pretty={ridges:'Ridges',fascia:'Fascia',peaks:'Peaks',groundstakes:'Stakes',shrub:'Shrub',windows:'Windows',garland:'Garland',wreath:'Wreath',bow:'Bow',cords:'Cord',powersource:'Source',threeway:'3-Way',tree:'Tree', label: 'Label', custom_icon: 'Image', ghost_door: 'Ghost Door', night_mode: 'Night', ai_detect: 'Ai Detect'};
const pfx={ridges:'R',fascia:'F',peaks:'P',groundstakes:'GS',shrub:'S',windows:'W',garland:'GA',wreath:'WR',bow:'B',cords:'C',powersource:'PS',tree:'T', label:'LBL', custom_icon: 'CI'};
const data={ridges:[],fascia:[],peaks:[],groundstakes:[],shrub:[],windows:[],garland:[],wreath:[],bow:[],cords:[],powersource:[],threeway:[],tree:[], label:[], custom_icon:[], ghostDoor: null}; 

const visibilityGroups = [
    { label: 'House Lights', sub: ['fascia', 'peaks', 'ridges'] },
    { label: 'Windows', sub: ['windows'] },
    { label: 'Greenery', sub: ['garland', 'wreath', 'wreath32', 'wreath42', 'bow'] },
    { label: 'Shrubs', sub: ['shrub'] },
    { label: 'Trees', sub: ['tree:Trunk + Branch (Minis)', 'tree:Trunk + Canopy (Minis)', 'tree:C9 Tree', 'tree:ToL'] },
    { label: 'Ground Stakes', sub: ['groundstakes'] }
];

const openVisGroups = new Set();
let selectedForMerge = new Set(); 

function getColorCode(colorName) {
    if (!colorName) return '#ddd';
    const lowerName = colorName.toLowerCase();
    if (lowerName.includes('multi') || lowerName === 'm' || lowerName.includes('multiple')) return 'Red/Blue/Green/Orange/Yellow';
    if (colorName.includes(' ') || colorName.includes('/') || colorName.includes(',')) return colorName;
    const cleanName = lowerName.replace(/[^a-z0-9#]/g, '');
    switch (cleanName) {
        case 'warmwhite': case 'softwhite': case 'white': case 'ww': case 'sw': case '#fffdf0': return '#fffdf0';
        case 'red': return '#ef4444';
        case 'blue': return '#3b82f6';
        case 'green': return '#22c55e';
        case 'yellow': return '#eab308';
        case 'orange': return '#f97316';
        case 'purple': case 'violet': return '#a855f7';
        case 'pink': return '#ec4899';
        case 'black': return '#000000';
        default: if(colorName.startsWith('#') && colorName.length >= 4) return colorName; return '#ddd'; 
    }
}
const colorOf=L=>({ridges:'#fffdf0',fascia:'#fffdf0',peaks:'#fffdf0',groundstakes:'#fffdf0',shrub:'#22c55e',windows:'#7dd3fc',garland:'#22c55e',wreath:'#22c55e',bow:'#ef4444',cords:'#000000',powersource:'#ef4444',threeway:'#eab308',tree:'#22c55e'}[L]||'#ddd');

let settings = { 
    iconScale: 1.5, junctionScale: 1.0, lineScale: 1.0, labelScale: 3.0, lineThickness: 3, arrowScale: 1.0, arrowFreqFactor: 1.0, bgBlur: 0,
    c9TreeScale: 1.0, miniTreeScale: 1.0, tolScale: 1.0, wreathScale: 1.0, bowScale: 1.0,
    pixelsPerFoot: 0, perspectiveFactor: 1.0
};
let isNightMode = false;

const aside=document.getElementById('side'), overlay=document.getElementById('overlay');

function toggleMenu(){
    const isMobile = matchMedia('(max-width:900px)').matches;
    if (isMobile) {
        const isOpen = aside.classList.toggle('open');
        overlay.classList.toggle('show', isOpen);
    } else {
        aside.classList.toggle('closed');
        overlay.classList.remove('show');
        setTimeout(initializeAndSizeContext, 350);
    }
}
document.getElementById('logoBtn').onclick=toggleMenu;
overlay.onclick=toggleMenu;
document.getElementById('modeTag').onclick=toggleMenu;

const closeGateBtn = document.getElementById('closeGateBtn');
function openGate(fromCanvas = false) {
    document.body.classList.add('blurred');
    document.getElementById('gate').classList.remove('hide');
    closeGateBtn.style.display = fromCanvas ? 'block' : 'none';
}
function unlock(){
    document.body.classList.remove('blurred');
    document.getElementById('gate').classList.add('hide');
    history.pushState(null, null, location.href);
}

const lenWrap = document.getElementById('lenWrap');
const lenChevron = document.getElementById('lenChevron');
document.getElementById('lenHead').onclick=()=>{
    lenWrap.classList.toggle('open');
    if (lenWrap.classList.contains('open')) {
        lenChevron.setAttribute('data-lucide', 'chevron-down');
    } else {
        lenChevron.setAttribute('data-lucide', 'chevron-up');
    }
    lucide.createIcons();
};

function showAlert(msg) {
    document.getElementById('alertMsg').textContent = msg;
    document.getElementById('modalAlert').style.display = 'flex';
}

const lineScaleInput = document.getElementById('lineScaleInput');
const lineScaleValue = document.getElementById('lineScaleValue');
const iconScaleInput = document.getElementById('iconScaleInput');
const iconScaleValue = document.getElementById('iconScaleValue');
const bgBlurInput = document.getElementById('bgBlurInput');
const bgBlurValue = document.getElementById('bgBlurValue');
const junctionScaleInput = document.getElementById('junctionScaleInput'); 
const junctionScaleValue = document.getElementById('junctionScaleValue'); 
const labelScaleInput = document.getElementById('labelScaleInput');
const labelScaleValue = document.getElementById('labelScaleValue');
const arrowFreqInput = document.getElementById('arrowFreqInput'); 
const arrowFreqValue = document.getElementById('arrowFreqValue'); 
const arrowScaleInput = document.getElementById('arrowScaleInput'); 
const arrowScaleValue = document.getElementById('arrowScaleValue'); 

const c9TreeScaleInput = document.getElementById('c9TreeScaleInput');
const miniTreeScaleInput = document.getElementById('miniTreeScaleInput');
const tolScaleInput = document.getElementById('tolScaleInput');
const wreathScaleInput = document.getElementById('wreathScaleInput');
const bowScaleInput = document.getElementById('bowScaleInput');

const itemScaleSlider = document.getElementById('itemScaleSlider');
const itemScaleWrap = document.getElementById('itemScaleWrap');

function updateLineScaleUI() { settings.lineScale = parseFloat(lineScaleInput.value); lineScaleValue.textContent = `${settings.lineScale.toFixed(1)}x`; }
function updateIconScaleUI() { settings.iconScale = parseFloat(iconScaleInput.value); iconScaleValue.textContent = `${settings.iconScale.toFixed(1)}x`; }
function updateBgBlurUI() { settings.bgBlur = parseInt(bgBlurInput.value); bgBlurValue.textContent = `${settings.bgBlur}%`; }
function updateJunctionScaleUI() { settings.junctionScale = parseFloat(junctionScaleInput.value); junctionScaleValue.textContent = `${settings.junctionScale.toFixed(1)}x`; }
function updateLabelScaleUI() { settings.labelScale = parseFloat(labelScaleInput.value); labelScaleValue.textContent = `${settings.labelScale.toFixed(1)}x`; }
function updateArrowFreqUI() { settings.arrowFreqFactor = parseFloat(arrowFreqInput.value); arrowFreqValue.textContent = `${settings.arrowFreqFactor.toFixed(1)}x`; }
function updateArrowScaleUI() { settings.arrowScale = parseFloat(arrowScaleInput.value); arrowScaleValue.textContent = `${settings.arrowScale.toFixed(1)}x`; }

lineScaleInput.oninput = (e) => { settings.lineScale = parseFloat(e.target.value); updateLineScaleUI(); markPowerDirty(); requestRender(); };
iconScaleInput.oninput = (e) => { settings.iconScale = parseFloat(e.target.value); updateIconScaleUI(); requestRender(); };
bgBlurInput.oninput = (e) => { settings.bgBlur = parseInt(e.target.value); updateBgBlurUI(); requestRender(); };
junctionScaleInput.oninput = (e) => { settings.junctionScale = parseFloat(junctionScaleInput.value); updateJunctionScaleUI(); markPowerDirty(); requestRender(); };
labelScaleInput.oninput = (e) => { settings.labelScale = parseFloat(labelScaleInput.value); updateLabelScaleUI(); requestRender(); };
arrowFreqInput.oninput = (e) => { settings.arrowFreqFactor = parseFloat(arrowFreqInput.value); updateArrowFreqUI(); markPowerDirty(); requestRender(); };
arrowScaleInput.oninput = (e) => { settings.arrowScale = parseFloat(arrowScaleInput.value); arrowScaleValue.textContent = `${settings.arrowScale.toFixed(1)}x`; markPowerDirty(); requestRender(); };

c9TreeScaleInput.oninput = (e) => { settings.c9TreeScale = parseFloat(e.target.value); requestRender(); };
miniTreeScaleInput.oninput = (e) => { settings.miniTreeScale = parseFloat(e.target.value); requestRender(); };
tolScaleInput.oninput = (e) => { settings.tolScale = parseFloat(e.target.value); requestRender(); };
wreathScaleInput.oninput = (e) => { settings.wreathScale = parseFloat(e.target.value); requestRender(); };
bowScaleInput.oninput = (e) => { settings.bowScale = parseFloat(e.target.value); requestRender(); };

itemScaleSlider.oninput = (e) => {
    if (selectedItem && (selectedItem.type === 'tree' || selectedItem.type === 'wreath' || selectedItem.type === 'bow')) {
        selectedItem.obj.itemScale = parseFloat(e.target.value);
        requestRender();
    }
};

function toggleNightMode(isManualToggle=true) {
    isNightMode = !isNightMode;
    const nightModeToolButton = toolBtn['night_mode'];
    if (nightModeToolButton) {
        nightModeToolButton.classList.toggle('toggled', isNightMode);
        nightModeToolButton.classList.toggle('night-glow', isNightMode);
    }
    if (mode === 'night_mode') { mode = 'draw'; updateModeTag(); }
    requestRender();
}

function updatePerspectiveFromDoor() {
    if (!data.ghostDoor) return;
    const d = data.ghostDoor;
    // Standard residential door height is ~80 inches (6.6 ft)
    const leftHeight = Math.hypot(d.tl.x - d.bl.x, d.tl.y - d.bl.y);
    const rightHeight = Math.hypot(d.tr.x - d.br.x, d.tr.y - d.br.y);
    
    // Set global pixels-per-foot based on average vertical height
    const avgHeightPx = (leftHeight + rightHeight) / 2;
    settings.pixelsPerFoot = avgHeightPx / 6.6; 
    
    // Calculate horizontal perspective skew
    // If right side is smaller (closer to 0), factor > 1 (compensation for depth)
    settings.perspectiveFactor = leftHeight / rightHeight; 
}

const chkSnap = { checked: true };
const btnSnap = document.getElementById('btnSnap');
btnSnap.onclick = () => { chkSnap.checked = !chkSnap.checked; btnSnap.classList.toggle('toggled', chkSnap.checked); };

const chkSwag = { checked: false };
const btnSwag = document.getElementById('btnSwag');
btnSwag.onclick = () => { 
    chkSwag.checked = !chkSwag.checked; 
    btnSwag.classList.toggle('toggled', chkSwag.checked); 
    if (sketch && sketch.layer === 'garland') sketch.isSwagMode = chkSwag.checked;
    if (selectedItem && selectedItem.type === 'garland') { selectedItem.obj.isSwagMode = chkSwag.checked; markPowerDirty(); }
    requestRender();
};

const chkPillar = { checked: false };
const btnPillar = document.getElementById('btnPillar');
btnPillar.onclick = () => { 
    chkPillar.checked = !chkPillar.checked; 
    btnPillar.classList.toggle('toggled', chkPillar.checked); 
    if (sketch && sketch.layer === 'garland') sketch.isPillarMode = chkPillar.checked;
    if (selectedItem && selectedItem.type === 'garland') { selectedItem.obj.isPillarMode = chkPillar.checked; markPowerDirty(); }
    requestRender();
};

function isMinis(L, item) {
    if(L === 'tree') return item && item.kind !== 'C9 Tree'; 
    const c = cats.find(x => x.key === 'min');
    return c && c.list.includes(L);
}
function isC9(L) { const c = cats.find(x => x.key === 'c9'); return c && c.list.includes(L); }

function relabelIds() {
    let itemsToRelabel = [];
    Object.keys(data).forEach(L => {
        if (L === 'cords' || L === 'threeway' || L === 'powersource' || L === 'bow' || L === 'custom_icon' || L === 'label' || L === 'ghostDoor') return; 
        data[L].forEach(item => {
            const prefix = pfx[L] || 'L';
            const isStandardLabel = !item.label || new RegExp('^' + prefix + '\\d+$', 'i').test(item.label);
            if (isStandardLabel) { 
                let centerX = 0;
                if (item.points && item.points.length > 0) {
                    item.points.forEach(p => centerX += p.x); centerX /= item.points.length;
                } else if (item.pt) centerX = item.pt.x;
                itemsToRelabel.push({ item, L, centerX });
            }
        });
    });
    itemsToRelabel.sort((a, b) => a.centerX - b.centerX);
    const nextIndices = {}; 
    itemsToRelabel.forEach(record => {
        const L = record.L; const prefix = pfx[L] || 'L';
        if (!nextIndices[L]) nextIndices[L] = 1;
        const newIndex = nextIndices[L]++;
        record.item.label = prefix + newIndex;
    });
    refreshTable(); markPowerDirty(); requestRender();
}

function mergeLines() {
    if (selectedForMerge.size < 2) { showAlert("Select at least 2 lines to merge."); return; }
    let mergedItems = [];
    Object.keys(data).forEach(L => {
        data[L].forEach(item => { if (selectedForMerge.has(item.index)) mergedItems.push({ layer: L, item }); });
    });
    if (mergedItems.some(m => !m.item.points)) { showAlert("Only lines can be merged."); return; }
    let newPoints = []; let totalBulbs = 0; let totalFeet = 0;
    let clipCounts = {}; let dominantClip = 'T'; let maxBulbsForClip = -1;
    let firstLayer = mergedItems[0].layer;
    mergedItems.forEach(m => {
        newPoints.push(...m.item.points);
        totalBulbs += parseFloat(m.item.bulbs) || 0;
        totalFeet += parseFloat(m.item.ft) || 0;
        const clip = m.item.clip || 'T';
        clipCounts[clip] = (clipCounts[clip] || 0) + (parseFloat(m.item.bulbs) || 0);
        if (clipCounts[clip] > maxBulbsForClip) { maxBulbsForClip = clipCounts[clip]; dominantClip = clip; }
    });
    mergedItems.forEach(m => { const idx = data[m.layer].indexOf(m.item); if (idx > -1) data[m.layer].splice(idx, 1); });
    const nextMergeIdx = nextIndex("Line #");
    const newItem = {
        points: newPoints, label: `Line #${nextMergeIdx}`, bulbs: totalBulbs, ft: totalFeet,
        clip: dominantClip, index: ++actionCounter, isVisible: true
    };
    data[firstLayer].push(newItem);
    selectedForMerge.clear(); refreshTable(); updateVisibilityMenu(); markPowerDirty(); requestRender();
}

function shouldShowGutterGuard(layer, clipType) { return layer === 'fascia' && (clipType === 'T' || clipType === 'ST'); }

function refreshTable(){
    const tbody = document.getElementById('lenRows'); tbody.innerHTML='';
    let rows = collectRows(false); // isForExport = false, includes invisible items
    rows.sort((a,b)=> (a.item.label||'').localeCompare(b.item.label||'', undefined, {numeric:true}));
    const chkAuto = document.getElementById('chkAutoCalc');

    rows.forEach(r=>{
        const tr=document.createElement('tr');
        let clipHtml = '', showFRA = false, showGutterGuard = false, fraHtml = '', gguardHtml = '';
        let clipFraContainerStart = '<div class="clip-fra-container">', clipFraContainerEnd = '</div>';

        if(isC9(r.L)) {
            if(r.L === 'groundstakes') { clipHtml = '<span style="color:#555">-</span>'; clipFraContainerStart = ''; clipFraContainerEnd = ''; } 
            else {
                if(!r.item.clip) r.item.clip = (r.L === 'ridges' || r.L === 'peaks') ? 'ST' : 'T';
                let opts = [];
                if(r.L === 'ridges') opts = [{v:'ST', l:'Shingle'}]; 
                else if (r.L === 'peaks') opts = [{v:'ST', l:'Shingle'}, {v:'Mag', l:'Mag'}];
                else if (r.L === 'fascia') opts = [{v:'T', l:'Tuff'}, {v : 'ST', l : 'Shingle'}, {v : 'Mag', l : 'Mag'}];
                let optStr = opts.map(o => `<option value="${o.v}" ${r.item.clip===o.v?'selected':''}>${o.l}</option>`).join('');
                clipHtml = `<select class="edit clip-select" style="width:auto; padding:4px;">${optStr}</select>`;
                if (r.item.clip === 'ST') {
                    showFRA = true; if (r.item.fra === undefined) r.item.fra = false;
                    fraHtml = `<label class="fra-checkbox-label" title="Flat Roof Adapter"><input type="checkbox" class="fra-checkbox" ${r.item.fra ? 'checked' : ''}/> FRA</label>`;
                }
                if (shouldShowGutterGuard(r.L, r.item.clip)) {
                     showGutterGuard = true; if (r.item.gguard === undefined) r.item.gguard = false; 
                     gguardHtml = `<label class="gg-checkbox-label" title="Gutter Guard"><input type="checkbox" class="gg-checkbox" ${r.item.gguard ? 'checked' : ''}/> GG</label>`;
                }
            }
        } else { clipHtml = '<span style="color:#555">-</span>'; clipFraContainerStart = ''; clipFraContainerEnd = ''; }
        const clipCellContent = clipFraContainerStart + clipHtml + fraHtml + gguardHtml + clipFraContainerEnd;

        let colorInputHtml = '';
        const rawColorValue = r.item.col || '';
        const processedColorCode = getColorCode(rawColorValue);
        if (r.L === 'garland' || r.L === 'wreath') { 
             const color = getColorCode('green');
             colorInputHtml = `<span style="color:#0f172a; font-weight:bold; background:${color}; padding: 2px 6px; border-radius: 4px; font-size:11px;">Green</span>`; 
        } else if (r.L === 'cords') {
             const color = getColorCode('black');
             colorInputHtml = `<span style="color:#fff; font-weight:bold; background:${color}; padding: 2px 6px; border-radius: 4px; font-size:11px;">Black</span>`; 
        } else {
             const displayValue = (processedColorCode.toLowerCase().includes('red/blue') || rawColorValue.toLowerCase().includes('multi') || rawColorValue.toLowerCase() === 'm') ? 'Multi' : rawColorValue;
             colorInputHtml = `<input class="edit" placeholder="Col" value="${displayValue}">`;
        }

        const bulbsVal = r.item.kind === 'ToL' ? '' : (r.item.bulbs || '');
        let typeDisplay = pretty[r.L];
        if (r.item.kind === 'ToL') typeDisplay = 'Tree of Lights';

        tr.innerHTML=`
            <td><input type="checkbox" class="merge-chk" ${selectedForMerge.has(r.item.index)?'checked':''}></td>
            <td>${typeDisplay}</td>
            <td><input class="edit" style="width:50px" value="${r.item.label||''}"></td>
            <td><input class="edit" placeholder="ft" style="width:40px" value="${r.item.ft||''}"></td>
            <td><input class="edit" placeholder="#" style="width:40px" value="${bulbsVal}" ${r.item.kind === 'ToL' ? 'disabled' : ''}></td>
            <td>${clipCellContent}</td>
            <td>${colorInputHtml}</td>
            <td><input class="edit" placeholder="Notes" style="min-width:80px" value="${r.item.notes||''}"></td>
            <td>
                <div style="display:flex; align-items:center; gap:8px;">
                    <i data-lucide="${r.item.isVisible !== false ? 'eye' : 'eye-off'}" class="vis-toggle ${r.item.isVisible !== false ? '' : 'faded'}"></i>
                    <button class="xbtn"></button>
                </div>
            </td>`;
        
        tr.querySelector('.merge-chk').onchange = e => {
            if (e.target.checked) selectedForMerge.add(r.item.index); else selectedForMerge.delete(r.item.index);
        };

        tr.querySelector('.vis-toggle').onclick = (e) => {
            e.stopPropagation();
            r.item.isVisible = r.item.isVisible === false ? true : false;
            refreshTable();
            updateVisibilityMenu();
            requestRender();
        };

        const select = tr.querySelector('.clip-select');
        const fraCheck = tr.querySelector('.fra-checkbox');
        const gguardCheck = tr.querySelector('.gg-checkbox'); 
        const inputId = tr.querySelector('input[style*=\"width:50px\"]');
        const inputCol = tr.querySelector('input[placeholder=\"Col\"]');
        const inputFt = tr.querySelector('input[placeholder=\"ft\"]');
        const inputBulbs = tr.querySelector('input[placeholder=\"#\"]');
        const inputNotes = tr.querySelector('input[placeholder=\"Notes\"]');
        
        if (inputId) inputId.onchange = e => { r.item.label = e.target.value; markPowerDirty(); requestRender(); refreshTable(); };
        if (inputCol) {
            inputCol.oninput=e=>{
                 const val = e.target.value; const lowerVal = val.toLowerCase();
                 const cleanedV = val.replace(/\s/g, '/').replace(/,/g, '/');
                 if (lowerVal.includes('multi') || lowerVal === 'm' || lowerVal.includes('multiple')) {
                     r.item.col = getColorCode('multi'); e.target.value = 'Multi'; 
                 } else {
                     r.item.col = cleanedV; 
                     if (cleanedV.includes('/')) e.target.value = cleanedV; else e.target.value = val;
                 }
            };
            inputCol.onchange=()=>requestRender(); 
        }
        if (inputFt) {
            inputFt.oninput=e=>{ r.item.ft = e.target.value; };
            inputFt.onchange=e=>{
                if(chkAuto.checked && e.target.value) {
                    if(r.L === 'garland' || r.L === 'wreath' || r.item.kind === 'ToL') return; 
                    const val = parseFloat(e.target.value);
                    if(!isNaN(val)) {
                        // Updated Ratio Logic: 19.5ft = 17 bulbs
                        let b = Math.round(val * (17 / 19.5));
                        if(isMinis(r.L, r.item)) {
                            b = val * 2; b = Math.ceil(b / 50) * 50; const balls = b / 50;
                            if(inputNotes) inputNotes.value = `${balls} Ball${balls > 1 ? 's' : ''}`;
                            r.item.notes = inputNotes ? inputNotes.value : r.item.notes;
                            r.item.ft = b / 2; inputFt.value = b / 2;
                        }
                        if(inputBulbs) b = Math.ceil(b); inputBulbs.value = b; r.item.bulbs = b;
                    }
                }
            };
        }
        if (inputBulbs) {
            inputBulbs.oninput=e=>{ r.item.bulbs = e.target.value; };
            inputBulbs.onchange=e=>{
                if(chkAuto.checked && e.target.value) {
                    if(r.L === 'garland' || r.L === 'wreath' || r.item.kind === 'ToL') return; 
                    const val = parseFloat(e.target.value);
                    if(!isNaN(val)) {
                        // Updated Ratio Logic: 17 bulbs = 19.5ft
                        let f = Math.round(val * (19.5 / 17) * 10) / 10; 
                        if(isMinis(r.L, r.item)) {
                            const balls = Math.ceil(val / 50); const exactBulbs = balls * 50;
                            f = exactBulbs / 2; 
                            if(inputNotes) inputNotes.value = `${balls} Ball${balls > 1 ? 's' : ''}`;
                            r.item.notes = inputNotes ? inputNotes.value : r.item.notes;
                            r.item.bulbs = exactBulbs; inputBulbs.value = exactBulbs;
                        }
                        if(inputFt) inputFt.value = f; r.item.ft = f;
                    }
                }
            };
        }
        if (inputNotes) inputNotes.oninput=e=>r.item.notes=e.target.value;
        if(select) select.onchange = e => { 
            r.item.clip = e.target.value; r.item.fra = false; r.item.gguard = false; 
            refreshTable(); requestRender(); 
        };
        if(fraCheck) fraCheck.onchange = e => { r.item.fra = e.target.checked; requestRender(); };
        if(gguardCheck) gguardCheck.onchange = e => { r.item.gguard = e.target.checked; requestRender(); };
        tr.querySelector('.xbtn').onclick=()=>{ 
            const idx=data[r.L].indexOf(r.item); 
            if(idx>-1){ data[r.L].splice(idx,1); refreshTable(); updateVisibilityMenu(); markPowerDirty(); requestRender(); } 
        };
        tbody.appendChild(tr);
    });
    lucide.createIcons();
}

function updateVisibilityMenu() {
    const container = document.getElementById('visibilityMenu');
    container.innerHTML = '';

    visibilityGroups.forEach(group => {
        const activeSubKeys = group.sub.filter(subKey => {
            if (subKey.startsWith('tree:')) {
                const kind = subKey.split(':')[1];
                return data.tree && data.tree.some(t => t.kind === kind);
            }
            if (subKey === 'wreath') return data.wreath && data.wreath.length > 0;
            return data[subKey] && data[subKey].length > 0;
        });

        if (activeSubKeys.length === 0) return;

        const groupEl = document.createElement('div');
        groupEl.className = 'vis-acc';
        if (openVisGroups.has(group.label)) groupEl.classList.add('open');
        
        const head = document.createElement('div');
        head.className = 'vis-accHead';
        
        const groupCheck = document.createElement('input');
        groupCheck.type = 'checkbox';
        
        const states = activeSubKeys.map(subKey => {
            if (subKey.startsWith('tree:')) {
                const kind = subKey.split(':')[1];
                return !data.tree.some(t => t.kind === kind && t.isVisible === false);
            }
            return !data[subKey].some(it => it.isVisible === false);
        });
        
        groupCheck.checked = states.every(s => s === true);
        groupCheck.indeterminate = !groupCheck.checked && states.some(s => s === true);

        const groupLabel = document.createElement('span');
        groupLabel.textContent = group.label;
        
        const arrow = document.createElement('i');
        arrow.setAttribute('data-lucide', 'chevron-right');

        head.append(groupCheck, groupLabel, arrow);
        groupEl.appendChild(head);

        const body = document.createElement('div');
        body.className = 'vis-accBody';

        activeSubKeys.forEach(subKey => {
            const row = document.createElement('div');
            row.className = 'vis-row';
            const subCheck = document.createElement('input');
            subCheck.type = 'checkbox';
            
            if (subKey.startsWith('tree:')) {
                const kind = subKey.split(':')[1];
                subCheck.checked = !data.tree.some(t => t.kind === kind && t.isVisible === false);
            } else {
                subCheck.checked = !data[subKey].some(it => it.isVisible === false);
            }

            const subLabelStr = subKey.startsWith('tree:') ? subKey.split(':')[1].split('(')[0] : pretty[subKey] || subKey;
            const subLabel = document.createElement('span');
            subLabel.textContent = subLabelStr;

            row.append(subCheck, subLabel);
            body.appendChild(row);

            subCheck.onchange = (e) => {
                e.stopPropagation();
                toggleLayerVisibility(subKey, subCheck.checked);
            };
        });

        groupCheck.onchange = (e) => {
            e.stopPropagation();
            activeSubKeys.forEach(sk => toggleLayerVisibility(sk, groupCheck.checked));
        };

        head.onclick = (e) => {
            if (e.target === groupCheck) return;
            const isNowOpen = groupEl.classList.toggle('open');
            if (isNowOpen) openVisGroups.add(group.label); else openVisGroups.delete(group.label);
        };

        groupEl.appendChild(body);
        container.appendChild(groupEl);
    });
    lucide.createIcons();
}

function toggleLayerVisibility(key, visible) {
    if (key.startsWith('tree:')) {
        const kind = key.split(':')[1];
        data.tree.forEach(t => { if(t.kind === kind) t.isVisible = visible; });
    } else {
        if(data[key]) data[key].forEach(it => it.isVisible = visible);
    }
    refreshTable();
    updateVisibilityMenu();
    requestRender();
}

let cv = document.getElementById('cv');
let ctx = cv.getContext('2d', {alpha: true}); 
const canvasWrap = cv.parentElement;
let DPR=1; let scale=1, panX=0, panY=0; 
let imgReady=false; let imgDataUrl=null;
const bg=new Image(); const logo=new Image(); logo.crossOrigin='anonymous'; logo.src='https://i.imgur.com/zdJfkpg.png'; logo.onload=()=>requestRender();
let lastWidth = 0, lastHeight = 0; let actionCounter = 0; let isTapCandidate = false; let tapDownX = 0, tapDownY = 0;
const TAP_THRESHOLD = 25; let activeLabelTarget = null; let dragStartPt = null; let isMovingLabel = false;

function initializeAndSizeContext() {
    const r = canvasWrap.getBoundingClientRect();
    const width = r.width; const height = r.height;
    if (width === 0 || height === 0) { requestRender(); return; }
    if (width !== lastWidth || height !== lastHeight) {
        DPR = Math.min(devicePixelRatio || 1, 2);
        cv.width = Math.floor(width * DPR); cv.height = Math.floor(height * DPR);
        lastWidth = width; lastHeight = height;
        if (!ctx) ctx = cv.getContext('2d', {alpha: true});
        if (ctx) ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
        cv.style.width = width + 'px'; cv.style.height = height + 'px';
        requestRender();
    }
    requestRender();
}
function resetView(){
  if(!imgReady) return;
  const r = canvasWrap.getBoundingClientRect();
  const imgW = bg.naturalWidth || bg.width || 1000;
  const imgH = bg.naturalHeight || bg.height || 1000;
  const targetWidth = r.width * 0.9; 
  scale = targetWidth / imgW;
  if(!isFinite(scale) || scale <= 0) scale = 0.1;
  panX = (r.width - imgW * scale) / 2;
  panY = (r.height - imgH * scale) / 2;
  requestRender();
}
document.getElementById('btnFit').onclick=resetView;

const accWrap=document.getElementById('accWrap'); const toolBtn={};
function buildTools(){
  accWrap.innerHTML='';
  cats.forEach(cat=>{
    const acc=document.createElement('div');acc.className='acc';
    const head=document.createElement('div');head.className='accHead';
    head.innerHTML=`<b>${cat.name}</b><i data-lucide=\"chevron-right\"></i>`;
    head.onclick=()=>{
        document.querySelectorAll('.acc.open').forEach(el=>{if(el!==acc)el.classList.remove('open')});
        acc.classList.toggle('open');
    };
    const body=document.createElement('div');body.className='accBody';
    const grid=document.createElement('div');grid.className='grid4';
    cat.list.forEach(k=>{
      const btn=document.createElement('button');btn.className='tool';
      const iconName = iconMap[k] || 'circle';
      const iconHtml = `<i data-lucide="${iconName}"></i>`;
      let displayText = pretty[k]||k;
      if(k.startsWith('tree:')){
          const t=k.slice(5); btn.onclick=()=>selectTool('tree',t); toolBtn[k]=btn;
      } else if(k.startsWith('wreath')){
          btn.onclick=()=>selectTool('wreath', k==='wreath32'?'32"':'42"'); toolBtn[k]=btn;
      } else if (k === 'custom_icon') {
          btn.onclick=()=>selectTool(k); toolBtn[k]=btn;
      } else if (k === 'ghost_door') {
          btn.onclick=()=>selectTool(k); toolBtn[k]=btn;
      } else if (k === 'night_mode') {
          btn.onclick=()=>toggleNightMode(); toolBtn[k]=btn;
          btn.classList.toggle('toggled', isNightMode); btn.classList.toggle('night-glow', isNightMode);
      } else if (k === 'ai_detect') {
          btn.onclick=()=>showAlert("Ai Detect feature in development."); toolBtn[k]=btn;
      } else {
          btn.onclick=()=>selectTool(k); toolBtn[k]=btn;
      }
      btn.innerHTML = `${iconHtml}<span>${displayText}</span>`;
      grid.appendChild(btn);
    });
    body.appendChild(grid);acc.append(head,body);accWrap.appendChild(acc);
  });
  if(window.lucide) lucide.createIcons();
}

let mode='draw',currLayer='ridges',currTreeKind='Trunk + Branch (Minis)',currWreathSize='32"', currLabelTarget='point'; 
function selectTool(L, variant=null){
    currLayer=L;
    if(L==='tree') currTreeKind=variant;
    else if(L==='wreath') currWreathSize=variant;
    for(const k in toolBtn) toolBtn[k].classList.remove('active');
    if(L==='tree') toolBtn['tree:'+currTreeKind]?.classList.add('active');
    else if(L==='wreath') toolBtn[currWreathSize==='32"'?'wreath32':'wreath42']?.classList.add('active');
    else toolBtn[L]?.classList.add('active');
    
    if(L === 'ghost_door' && data.ghostDoor) {
        data.ghostDoor.isVisible = true; 
    }

    if(matchMedia('(max-width:900px)').matches) toggleMenu();
    document.getElementById('imgUploadPop').style.display = 'none';
    mode='draw'; if (L === 'label') mode = 'label'; 
    updateModeTag(); startNewSketch();
    if(currLayer === 'garland') {
        document.getElementById('btnSwag').style.display = 'inline-flex';
        document.getElementById('btnPillar').style.display = 'inline-flex'; 
        btnPillar.classList.toggle('toggled', chkPillar.checked);
        btnSwag.classList.toggle('toggled', chkSwag.checked);
    } else {
        document.getElementById('btnSwag').style.display = 'none';
        document.getElementById('btnPillar').style.display = 'none'; 
    }
    redoStack = []; document.getElementById('btnRedo').disabled = true;
}
document.getElementById('btnDraw').onclick=()=>{mode='draw';updateModeTag()};
document.getElementById('btnSelect').onclick=()=>{mode='select';updateModeTag()};
document.getElementById('btnMoveCanvas').onclick=()=>{mode='move-canvas';updateModeTag()};
document.getElementById('btnLineSplice').onclick=()=>{mode='splice';updateModeTag()};
document.getElementById('btnMergeLines').onclick=mergeLines;

const quickEditPrefix = document.getElementById('quickEditPrefix');
quickEditPrefix.oninput = (e) => {
    if (selectedItem && selectedItem.obj) {
        selectedItem.obj.label = e.target.value;
        if (selectedItem.type === 'label') selectedItem.obj.text = e.target.value;
        markPowerDirty(); requestRender();
    }
};
quickEditPrefix.onchange = () => refreshTable();

const moveLabelToggleBtn = document.getElementById('moveLabelToggleBtn');
moveLabelToggleBtn.onclick = () => {
    mode = (mode === 'move-label') ? 'select' : 'move-label';
    updateModeTag();
};

document.getElementById('quickDeleteBtn').onclick = () => {
    if (selectedItem) { deleteItem(selectedItem); selectedItem = null; updateModeTag(); }
};

function updateModeTag(){
    const t = document.getElementById('modeTag');
    document.getElementById('btnDraw').classList.remove('toggled');
    document.getElementById('btnSelect').classList.remove('toggled');
    document.getElementById('btnMoveCanvas').classList.remove('toggled'); 
    document.getElementById('btnLineSplice').classList.remove('toggled');
    document.body.classList.remove('splice-cursor');
    document.getElementById('selectionQuickEdit').style.display = 'none';
    itemScaleWrap.style.display = 'none';
    moveLabelToggleBtn.classList.remove('toggled');
    if (mode === 'draw') {
         t.textContent = pretty[currLayer] || 'Draw'; t.style.borderColor = '#64b5ff'; t.style.color = '#64b5ff';
         document.getElementById('btnDraw').classList.add('toggled');
    } else if (mode === 'select' || mode === 'move-label') {
         t.textContent = mode === 'select' ? 'Select' : 'Label Move'; 
         t.style.borderColor = mode === 'select' ? '#fbbf24' : '#3b82f6'; 
         t.style.color = mode === 'select' ? '#fbbf24' : '#3b82f6';
         document.getElementById('btnSelect').classList.add('toggled');
         if (selectedItem) {
             const sqe = document.getElementById('selectionQuickEdit');
             sqe.style.display = 'flex';
             const isLabelable = !['powersource','threeway', 'ghostDoor'].includes(selectedItem.type);
             document.getElementById('editLabelPrefix').style.display = isLabelable ? 'inline' : 'none';
             quickEditPrefix.style.display = isLabelable ? 'inline' : 'none';
             moveLabelToggleBtn.style.display = isLabelable ? 'inline-flex' : 'none';
             if (isLabelable) quickEditPrefix.value = selectedItem.obj.label || '';
             if (mode === 'move-label') moveLabelToggleBtn.classList.add('toggled');
             if (['tree', 'wreath', 'bow'].includes(selectedItem.type)) {
                 itemScaleWrap.style.display = 'flex';
                 itemScaleSlider.value = selectedItem.obj.itemScale || 1.0;
             }
             if (selectedItem.type === 'garland') {
                 document.getElementById('btnSwag').style.display = 'inline-flex';
                 document.getElementById('btnPillar').style.display = 'inline-flex';
                 btnPillar.classList.toggle('toggled', !!selectedItem.obj.isPillarMode);
                 btnSwag.classList.toggle('toggled', !!selectedItem.obj.isSwagMode);
             }
         }
    } else if (mode === 'splice') {
        t.textContent = 'Splice'; t.style.borderColor = '#ef4444'; t.style.color = '#ef4444';
        document.getElementById('btnLineSplice').classList.add('toggled');
        document.body.classList.add('splice-cursor');
    } else if (mode === 'label') {
         t.textContent = 'Label'; t.style.borderColor = '#22c55e'; t.style.color = '#22c55e';
    } else if (mode === 'move-canvas') { 
         t.textContent = 'Pan'; t.style.borderColor = '#f87171'; t.style.color = '#f87171';
         document.getElementById('btnMoveCanvas').classList.add('toggled');
    } else if (mode === 'move') {
         t.textContent = 'Move'; t.style.borderColor = '#ff3b3b'; t.style.color = '#ff3b3b';
    }
    updateLineScaleUI(); updateIconScaleUI(); updateJunctionScaleUI(); updateLabelScaleUI(); updateArrowScaleUI();
    requestRender();
}

let powerGraph = null, powerDirty = true;
function markPowerDirty(){ powerDirty = true; }
function analyzePower(){
  if(!powerDirty && powerGraph) return powerGraph;
  const nodes = []; const edges = []; const TOL_SQR = 0.5 * 0.5;
  function getId(p){
    for(let i=0; i<nodes.length; i++){
      const dx = nodes[i].x - p.x; const dy = nodes[i].y - p.y;
      if(dx*dx + dy*dy < TOL_SQR) return i;
    }
    return nodes.push({x:p.x, y:p.y, dist:Infinity, adj:[], type: null}) - 1;
  }
  const singlePathLayers = ['groundstakes']; const singlePathEdges = new Map(); 
  const lineLayers = ['ridges','fascia','peaks','groundstakes','garland','cords','shrub','windows'];
  const decorationLayers = ['powersource', 'threeway', 'wreath', 'tree', 'bow', 'custom_icon'];
  decorationLayers.forEach(L => { if(data[L]) data[L].forEach(it => { if(it.pt && it.isVisible !== false) getId(it.pt); }); });
  lineLayers.forEach(L => { if(data[L]) data[L].forEach(it => { if(it.points && it.isVisible !== false) it.points.forEach(p => getId(p)); }); });
  lineLayers.forEach(L => {
    if(!data[L]) return;
    data[L].forEach(it => {
       if(!it.points || it.points.length < 2 || it.isVisible === false) return;
       for(let i=0; i<it.points.length-1; i++){
          const p1 = it.points[i]; const p2 = it.points[i+1];
          const u = getId(p1); const v = getId(p2);
          let midNodes = [];
          for(let k=0; k<nodes.length; k++){
              if(k === u || k === v) continue;
              const node = nodes[k]; const proj = projOnSeg(node, p1, p2);
              if(proj.t > 0.01 && proj.t < 0.99) {
                  const d = Math.hypot(node.x - proj.q.x, node.y - proj.q.y);
                  if(d < 0.8) midNodes.push({ id: k, t: proj.t });
              }
          }
          midNodes.sort((a,b) => a.t - b.t);
          let lastNode = u;
          [...midNodes, {id: v}].forEach(step => {
              const edge = {u: lastNode, v: step.id, type:L, cps:(it.cps?.[i] || null), index: i, line: it};
              edges.push(edge);
              nodes[lastNode].adj.push(step.id);
              nodes[step.id].adj.push(lastNode);
              lastNode = step.id;
          });
          if (singlePathLayers.includes(L)) {
              const cp = it.cps ? it.cps[i] : null; const len = segmentLength(p1, p2, cp);
              if(!singlePathEdges.has(it)) singlePathEdges.set(it, { totalLength: 0, segments: [] });
              const info = singlePathEdges.get(it);
              info.segments.push({ u, v, length: len, startDist: info.totalLength, edgeRef: {u,v,type:L,line:it,index:i,cps:cp} });
              info.totalLength += len;
          }
       }
    });
  });
  const queue = [];
  data.powersource.forEach(ps => { if(ps.isVisible !== false) { const id = getId(ps.pt); if(nodes[id]){ nodes[id].dist = 0; queue.push(id); } } });
  let head = 0;
  while(head < queue.length){
    const u = queue[head++]; const d = nodes[u].dist + 1;
    nodes[u].adj.forEach(v => { if(nodes[v].dist === Infinity){ nodes[v].dist = d; queue.push(v); } });
  }
  const deadTips = [];
  nodes.forEach((n, i)=>{ 
    if(n.dist !== Infinity && n.dist > 0 && n.adj.length === 1){ 
      const worldPos = {x:n.x, y:n.y}; let isDecoration = false;
      ['wreath', 'tree', 'bow', 'custom_icon'].forEach(L => {
        data[L].forEach(item => { if (item.isVisible !== false && item.pt && Math.hypot(item.pt.x - worldPos.x, item.pt.y - worldPos.y) < TOL_SQR) isDecoration = true; });
      });
      deadTips.push(i); 
    } 
  });
  const singleArrowEdges = [];
  singlePathEdges.forEach((pathInfo, line) => {
      const totalLength = pathInfo.totalLength; if (totalLength < 0.1) return;
      const uFirst = getId(line.points[0]); const vLast = getId(line.points[line.points.length-1]);
      if (nodes[uFirst].dist === Infinity && nodes[vLast].dist === Infinity) return;
      const targetDist = totalLength * 0.5; let bestSegment = null;
      for (const seg of pathInfo.segments) { if (targetDist >= seg.startDist && targetDist <= (seg.startDist + seg.length)) { bestSegment = seg; break; } }
      if (bestSegment) {
          const edge = bestSegment.edgeRef; const distInSegment = targetDist - bestSegment.startDist;
          const uNode = nodes[bestSegment.u]; const vNode = nodes[bestSegment.v];
          let isReversed = uNode.dist > vNode.dist;
          singleArrowEdges.push({ edge: edge, distInSegment: distInSegment, isReversed: isReversed });
      }
  });
  powerGraph = {nodes, edges, deadTips, singleArrowEdges}; powerDirty = false; return powerGraph;
}
function projOnSeg(p,a,b){ const ABx=b.x-a.x, ABy=b.y-a.y; const d=ABx*ABx+ABy*ABy||1; const t=((p.x-a.x)*ABx+(p.y-a.y)*ABy)/d; return{t,q:{x:a.x+ABx*t,y:a.y+ABy*t}}; }
function nextIndex(prefix){const re=new RegExp('^'+prefix+'(\\d+)$','i');const used=new Set();for(const L in data){for(const it of (Array.isArray(data[L]) ? data[L] : [])){const m=(it.label||'').match(re);if(m)used.add(+m[1])}}let i=1;while(used.has(i))i++;return i}

function getSnapLineOnly(wx, wy, thresholdW){
    let best = null; let minD = thresholdW; const p = {x:wx, y:wy};
    ['ridges','fascia','peaks','groundstakes','garland','shrub','windows'].forEach(L=>{
        data[L].forEach(line=>{
            if (line.isVisible === false) return;
            for(let i=0; i<line.points.length-1; i++){
                const a=line.points[i]; const b=line.points[i+1]; const proj=projOnSeg(p,a,b); const d=Math.hypot(p.x-proj.q.x, p.y-proj.q.y);
                if(d<minD){ minD=d; best={x:proj.q.x, y:proj.q.y, type:'mid', host:line, seg:i}; }
            }
        });
    });
    return best;
}

function getSnap(sx, sy, thresholdS, excludeObj = null){
    const w=toWorld(sx, sy); const thresholdW=thresholdS/scale; let best=null; let minD=thresholdW; const p = w;
    ['ridges','fascia','peaks','groundstakes','garland','cords','shrub','windows'].forEach(L=>{
        data[L].forEach(line=>{ 
            if(line === excludeObj || line.isVisible === false) return;
            if(line.points.length>0){ [line.points[0], line.points[line.points.length-1]].forEach(pt=>{ const d=Math.hypot(p.x-pt.x, p.y-pt.y); if(d<minD){ minD=d; best={x:pt.x, y:pt.y, type:'end', host:line}; } }); } 
        });
    });
    ['powersource','threeway','wreath','bow','tree', 'custom_icon'].forEach(L=>{
        data[L].forEach(it=>{ 
            if(it === excludeObj || it.isVisible === false) return;
            if(it.pt){ const d=Math.hypot(p.x-it.pt.x, p.y-it.pt.y); if(d<minD){ minD=d; best={x:it.pt.x, y:it.pt.y, type:'junction', host:it}; } } 
        });
    });
    if(!best){
        minD = thresholdW;
        ['ridges','fascia','peaks','groundstakes','garland','shrub','windows'].forEach(L=>{
            data[L].forEach(line=>{
                if(line === excludeObj || line.isVisible === false) return;
                for(let i=0; i<line.points.length-1; i++){
                    const a=line.points[i]; const b=line.points[i+1]; const proj=projOnSeg(p,a,b);
                    if(proj.t>=0 && proj.t<=1 && Math.hypot(p.x-proj.q.x, p.y-proj.q.y)<minD){ minD=Math.hypot(p.x-proj.q.x, p.y-proj.q.y); best={x:proj.q.x, y:proj.q.y, type:'proj', host:line, seg:i}; }
                }
            });
        });
    }
    return best;
}

function countConnections(junction) {
    let count = 0; const junctionWorld = junction.pt; const TOL_SQR = 0.5 * 0.5;
    ['ridges', 'fascia', 'peaks', 'groundstakes', 'garland', 'cords', 'shrub', 'windows'].forEach(L => {
        data[L].forEach(line => {
            if (line.points.length > 0) {
                if (Math.hypot(line.points[0].x - junctionWorld.x, line.points[0].y - junctionWorld.y) < TOL_SQR) count++;
                const end = line.points[line.points.length - 1];
                if (line.points.length > 1 && Math.hypot(end.x - junctionWorld.x, end.y - junctionWorld.y) < TOL_SQR) count++;
            }
        });
    });
    return count;
}
function find3WayAt(pt) { const TOL_SQR = 0.5 * 0.5; for(const tw of data.threeway){ if(Math.hypot(tw.pt.x - pt.x, pt.y - pt.y) < TOL_SQR) return tw; } return null; }

let pendingCustomIcon = null;
function placeCustomIcon(w, sx, sy, label, index) {
    pendingCustomIcon = { pt: w, label: label, index: index, kind: 'custom_icon', tempX: sx, tempY: sy };
    const popEl = document.getElementById('imgUploadPop');
    popEl.style.left = sx + 'px'; popEl.style.top = sy + 'px'; popEl.style.transform = 'translate(-50%, -100%)'; popEl.style.display = 'flex';
}

function placeGhostDoor(w, sx, sy) {
    const wDoor = 60; 
    const hDoor = 132; 
    data.ghostDoor = {
        tl: {x: w.x - wDoor/2, y: w.y - hDoor},
        tr: {x: w.x + wDoor/2, y: w.y - hDoor},
        bl: {x: w.x - wDoor/2, y: w.y},
        br: {x: w.x + wDoor/2, y: w.y},
        index: ++actionCounter,
        isVisible: true,
        type: 'ghostDoor'
    };
    updatePerspectiveFromDoor();
    selectedItem = { type: 'ghostDoor', obj: data.ghostDoor };
    mode = 'select'; 
    updateModeTag();
    requestRender();
}

function placeItem(L, w, sx, sy){
    let item; const {label, index} = getNewItemData(L);
    if(L==='tree') { placeTree(L, w, sx, sy, label, index); return; } 
    else if(L==='wreath') { placeWreath(L, w, sx, sy, label, index); return; } 
    else if(L==='custom_icon') { placeCustomIcon(w, sx, sy, label, index); return; }
    else if(L==='ghost_door') { placeGhostDoor(w, sx, sy); return; }
    item = {pt:w, label:label, index:index, kind: L, itemScale: 1.0, isVisible: true};
    data[L].push(item); markPowerDirty(); requestRender(); refreshTable(); updateVisibilityMenu();
}

function placeTree(L, w, sx, sy, label, index) {
    if (currTreeKind === 'ToL') {
        openPop(document.getElementById('tolPop'), sx, sy, (size) => {
            const item = {pt:w, label:label, index:index, kind: currTreeKind, size: parseInt(size), ft: size, itemScale: 1.0, isVisible: true};
            data[L].push(item); markPowerDirty(); requestRender(); refreshTable(); updateVisibilityMenu();
        });
    } else {
        const item = {pt:w, label:label, index:index, kind: currTreeKind, itemScale: 1.0, isVisible: true};
        data[L].push(item); markPowerDirty(); requestRender(); refreshTable(); updateVisibilityMenu();
    }
}
function placeWreath(L, w, sx, sy, label, index) {
    openPop(document.getElementById('wreathPop'), sx, sy, (bow) => {
        const item = {pt:w, label:label, index:index, size: currWreathSize, bow: bow, itemScale: 1.0, isVisible: true};
        data[L].push(item); markPowerDirty(); requestRender(); refreshTable(); updateVisibilityMenu();
    });
}

function completeSketch() {
    if (!sketch || sketch.points.length < 2) return;
    sketch.isVisible = true;
    
    // Auto-calculate footage on completion based on door scale
    if (settings.pixelsPerFoot > 0) {
        let totalFt = 0;
        for (let i = 0; i < sketch.points.length - 1; i++) {
            const segPx = segmentLength(sketch.points[i], sketch.points[i+1], sketch.cps?.[i]);
            const dx = Math.abs(sketch.points[i+1].x - sketch.points[i].x);
            const dy = Math.abs(sketch.points[i+1].y - sketch.points[i].y);
            const horizRatio = dx / (dx + dy + 0.1);
            const compensation = 1 + (settings.perspectiveFactor - 1) * horizRatio;
            totalFt += (segPx / settings.pixelsPerFoot) * compensation;
        }
        sketch.ft = Math.round(totalFt * 10) / 10;
        // Updated Conversion Rate: 19.5ft = 17 bulbs (~0.8717 bulbs per foot)
        const bulbRatio = 17 / 19.5;
        if (isC9(sketch.layer)) sketch.bulbs = Math.round(sketch.ft * bulbRatio);
        else if (isMinis(sketch.layer)) sketch.bulbs = Math.ceil((sketch.ft * 2) / 50) * 50;
    }

    data[sketch.layer].push(sketch); 
    sketch = null; document.getElementById('btnComplete').disabled = true; startNewSketch(); 
    markPowerDirty(); refreshTable(); updateVisibilityMenu(); requestRender(); 
}

let pointers=new Map(),gesture=false,gMid=null,gScale=1,gPanX=0,gPanY=0,gDist=0;
function mp(a,b){return{x:(a.x+b.x)/2,y:(a.y+b.y)/2}}
function ds(a,b){return Math.hypot(a.x-b.x,a.y-b.y)}
const toWorld=(sx,sy)=>({x:(sx-panX)/scale,y:(sy-panY)/scale});
const toScr=p=>({x:p.x*scale+panX,y:p.y*scale+panY});

let selectedItem = null, draggingPoint = null;
let currentSnapLine = null; let draggedLabelTarget = null;
let dragStartX=0, dragStartY=0, dragPanStartX=0, dragPanStartY=0;

cv.addEventListener('pointerdown',e=>{
    cv.setPointerCapture(e.pointerId); const r=canvasWrap.getBoundingClientRect(); const x = e.clientX-r.left, y = e.clientY-r.top;
    pointers.set(e.pointerId,{x,y,id:e.pointerId});
    cv._mx = x; cv._my = y;
    if (!e.target.closest('#lblEditor')) { document.getElementById('lblEditor').style.display = 'none'; }
    document.getElementById('imgUploadPop').style.display = 'none';
    if(pointers.size === 1) {
        isTapCandidate = true; tapDownX = x; tapDownY = y; dragStartX = x; dragStartY = y; dragPanStartX = panX; dragPanStartY = panY;
        if (mode === 'select' && selectedItem) { handleSelectDown(x, y); if (draggingPoint) { isTapCandidate = false; return; } }
        if (mode === 'move' && selectedItem) {
             dragStartPt = { x: selectedItem.obj.pt ? selectedItem.obj.pt.x : (selectedItem.obj.points ? getItemCenter(selectedItem.obj).x : (selectedItem.obj.tl ? selectedItem.obj.bl.x : 0)),
                             y: selectedItem.obj.pt ? selectedItem.obj.pt.y : (selectedItem.obj.points ? getItemCenter(selectedItem.obj).y : (selectedItem.obj.tl ? selectedItem.obj.bl.y : 0)) };
             return;
        } else if (mode === 'move-label' && selectedItem) { 
             const w = toWorld(x, y); draggedLabelTarget = { item: selectedItem.obj, type: 'primary' }; isTapCandidate = false; return;
        }
    }
    if(pointers.size >= 2){ isTapCandidate = false; gesture=true; const v=[...pointers.values()]; gDist=ds(v[0],v[1]); gMid=mp(v[0],v[1]); gScale=scale; gPanX=panX; gPanY=panY; return; }
});

function spliceLine(sx, sy) {
    const w = toWorld(sx, sy); let best = null; let minD = 25 / scale;
    const lineLayers = ['ridges','fascia','peaks','groundstakes','garland','shrub','windows','cords'];
    lineLayers.forEach(L => {
        data[L].forEach(line => {
            if (line.isVisible === false) return;
            for (let i = 0; i < line.points.length - 1; i++) {
                const a = line.points[i]; const b = line.points[i+1]; const proj = projOnSeg(w, a, b); const d = Math.hypot(w.x - proj.q.x, w.y - proj.q.y);
                if (proj.t >= 0 && proj.t <= 1 && d < minD) { minD = d; best = { line, layer: L, index: i, point: proj.q, t: proj.t }; }
            }
        });
    });
    if (best) {
        const line = best.line; const totalPoints = line.points.length;
        let totalLen = 0; for(let i=0; i < totalPoints-1; i++) totalLen += Math.hypot(line.points[i+1].x - line.points[i].x, line.points[i+1].y - line.points[i].y);
        let splitAtLen = 0; for(let i=0; i < best.index; i++) splitAtLen += Math.hypot(line.points[i+1].x - line.points[i].x, line.points[i+1].y - line.points[i].y);
        splitAtLen += Math.hypot(best.point.x - line.points[best.index].x, best.point.y - line.points[best.index].y);
        const ratio = splitAtLen / totalLen; const origBulbs = parseFloat(line.bulbs) || 0; const origFeet = parseFloat(line.ft) || 0;
        const p1 = line.points.slice(0, best.index + 1); p1.push(best.point);
        const p2 = [best.point]; p2.push(...line.points.slice(best.index + 1));
        let rootLabel = line.label || ""; const suffixMatch = rootLabel.match(/^(.*?)\s*\([a-z]\)$/i);
        if (suffixMatch) rootLabel = suffixMatch[1];
        const l2 = {
            points: p2, label: rootLabel, ft: Math.round(origFeet * (1 - ratio) * 10) / 10, bulbs: Math.round(origBulbs * (1 - ratio)),
            clip: line.clip, col: line.col, notes: line.notes, isVisible: true, index: ++actionCounter
        };
        line.points = p1; line.ft = Math.round(origFeet * ratio * 10) / 10; line.bulbs = Math.round(origBulbs * ratio); line.label = rootLabel;
        data[best.layer].push(l2);
        const relatives = data[best.layer].filter(item => {
            let itemRoot = item.label || ""; const sm = itemRoot.match(/^(.*?)\s*\([a-z]\)$/i);
            if (sm) itemRoot = sm[1]; return itemRoot === rootLabel;
        });
        relatives.sort((a, b) => getItemCenter(a).x - getItemCenter(b).x);
        relatives.forEach((item, idx) => { const char = String.fromCharCode(97 + idx); item.label = `${rootLabel} (${char})`; });
        markPowerDirty(); refreshTable(); updateVisibilityMenu(); requestRender();
    }
}

cv.addEventListener('pointermove',e=>{
    const r=canvasWrap.getBoundingClientRect(); const x=e.clientX-r.left, y=e.clientY-r.top;
    if(pointers.has(e.pointerId)) pointers.set(e.pointerId,{x,y,id:e.pointerId});
    cv._mx=x; cv._my=y;
    if(gesture && pointers.size>=2){
        const v=[...pointers.values()]; const currDist=ds(v[0],v[1]); const currMid=mp(v[0],v[1]);
        if(gDist>0){
            const nz = Math.max(0.1, Math.min(10, gScale * (currDist/gDist)));
            const worldMid = {x:(gMid.x-gPanX)/gScale, y:(gMid.y-gPanY)/gScale};
            scale = nz; panX = currMid.x - worldMid.x*scale; panY = currMid.y - worldMid.y*scale; requestRender();
        }
        cv._mx = currMid.x; cv._my = currMid.y; return;
    }
    if(mode === 'select' && draggingPoint){
        const w = toWorld(x, y); currentSnapLine = null; 
        if (draggingPoint.index === -1 && (draggingPoint.type === 'powersource' || draggingPoint.type === 'threeway' || draggingPoint.type === 'wreath' || draggingPoint.type === 'bow' || draggingPoint.type === 'tree' || draggingPoint.type === 'label')) {
             if (draggingPoint.type === 'label') draggingPoint.obj.pt = w;
             else {
                 const snap = getSnapLineOnly(w.x, w.y, 25 / scale); 
                 if (snap) { draggingPoint.obj.pt = {x: snap.x, y: snap.y}; if(snap.type === 'mid') currentSnapLine = snap; } 
                 else draggingPoint.obj.pt = w;
             }
        } else if (draggingPoint.type === 'ghostDoor') {
            const d = draggingPoint.obj;
            if (draggingPoint.key) d[draggingPoint.key] = w;
            updatePerspectiveFromDoor();
        } else if (draggingPoint.type === 'custom_icon') {
            const ci = draggingPoint.obj;
            if (draggingPoint.handle === 'move' || draggingPoint.index === -1) { ci.pt.x = w.x; ci.pt.y = w.y; } 
            else if (draggingPoint.handle === 'scale' || draggingPoint.index === -2) {
                 const tlW = ci.pt; const newWorldW = w.x - tlW.x;
                 if (newWorldW > 0.05) { const newScale = newWorldW / ci.w; ci.scale = newScale; }
            }
        } else {
            let snap = getSnap(x, y, 25, draggingPoint.obj); 
            const ptVal = snap ? {x:snap.x, y:snap.y} : w;
            if (draggingPoint.index === -1 && draggingPoint.obj.pt) draggingPoint.obj.pt = ptVal;
            else if (draggingPoint.obj.points) draggingPoint.obj.points[draggingPoint.index] = ptVal;
        }
        markPowerDirty(); requestRender(); return;
    } else if (mode === 'move' && selectedItem && dragStartPt) {
        const w = toWorld(x, y); const wStart = toWorld(dragStartX, dragStartY); const dx = w.x - wStart.x; const dy = w.y - wStart.y;
        const obj = selectedItem.obj;
        if (obj.pt) { obj.pt.x = dragStartPt.x + dx; obj.pt.y = dragStartPt.y + dy; } 
        else if (obj.points) {
            obj.points.forEach(p => { p.x += dx; p.y += dy; });
            dragStartX = x; dragStartY = y; dragStartPt.x = obj.points[0].x; dragStartPt.y = obj.points[0].y; 
            if (obj.cps) obj.cps.forEach(cp => { if (cp) { cp.x += dx; cp.y += dy; } });
        } else if (obj.tl) {
            ['tl','tr','bl','br'].forEach(k => { obj[k].x += dx; obj[k].y += dy; });
            dragStartX = x; dragStartY = y; dragStartPt.x = obj.bl.x; dragStartPt.y = obj.bl.y;
        }
        markPowerDirty(); requestRender(); return;
    } else if (mode === 'move-label' && draggedLabelTarget) {
        const w = toWorld(x, y); const obj = draggedLabelTarget.item; 
        if (draggedLabelTarget.type === 'primary') obj.customLabelPos = { x: w.x, y: w.y };
        else if (draggedLabelTarget.type === 'point') { if(!obj.ptLabelPos) obj.ptLabelPos = {}; obj.ptLabelPos[draggedLabelTarget.index] = {x: w.x, y: w.y}; } 
        else if (draggedLabelTarget.type === 'seg') { if(!obj.segLabelPos) obj.segLabelPos = {}; obj.segLabelPos[draggedLabelTarget.index] = {x: w.x, y: w.y}; } 
        else if (draggedLabelTarget.type === 'simple') { obj.pt.x = w.x; obj.pt.y = w.y; }
        requestRender(); return;
    }
    if (pointers.size === 1) {
        const dx = x - dragStartX; const dy = y - dragStartY;
        if (Math.hypot(dx, dy) > TAP_THRESHOLD) {
            isTapCandidate = false; panX = dragPanStartX + dx; panY = dragPanStartY + dy; requestRender();
        }
    }
    requestRender();
});

cv.addEventListener('pointerup',e=>{
    const wasGesture = gesture;
    if (pointers.size === 1 && !wasGesture) { if (draggingPoint) { draggingPoint = null; markPowerDirty(); requestRender(); refreshTable(); } }
    if (mode === 'move' && dragStartPt) dragStartPt = null;
    if (mode === 'move-label' && draggedLabelTarget) draggedLabelTarget = null;
    if (!wasGesture && pointers.size === 1 && isTapCandidate) {
        const r=canvasWrap.getBoundingClientRect(); const ex = e.clientX-r.left, ey = e.clientY-r.top;
        if (mode === 'draw') handleTap(ex, ey);
        else if (mode === 'splice') spliceLine(ex, ey);
        else if (mode === 'label') checkCordLabelClick(ex, ey);
        else if (mode === 'select' || mode === 'move' || mode === 'move-label') handleSelectDown(ex, ey);
    }
    pointers.delete(e.pointerId);
    if (wasGesture) { dragStartX = cv._mx; dragStartY = cv._my; dragPanStartX = panX; dragPanStartY = panY; isTapCandidate = false; }
    if(pointers.size<2) gesture=false;
});

const iconFile = document.getElementById('iconFile'); const imgUploadPop = document.getElementById('imgUploadPop');
const cancelIconUpload = document.getElementById('cancelIconUpload');
cancelIconUpload.onclick = () => { imgUploadPop.style.display = 'none'; pendingCustomIcon = null; iconFile.value = ''; requestRender(); }
iconFile.onchange = (e) => {
    const file = e.target.files[0]; if (!file || !pendingCustomIcon) { imgUploadPop.style.display = 'none'; pendingCustomIcon = null; return; }
    const reader = new FileReader();
    reader.onload = (event) => {
        const img = new Image();
        img.onload = () => {
            const iconData = pendingCustomIcon; iconData.url = event.target.result;
            iconData.w = img.naturalWidth || 100; iconData.h = img.naturalHeight || 100; iconData.scale = 0.15; iconData.imageObj = img; 
            iconData.isVisible = true; data.custom_icon.push(iconData); pendingCustomIcon = null; imgUploadPop.style.display = 'none'; iconFile.value = ''; 
            selectedItem = { type: 'custom_icon', obj: iconData }; markPowerDirty(); requestRender(); refreshTable(); updateVisibilityMenu();
        };
        img.onerror = () => { showAlert("Failed to load image"); pendingCustomIcon = null; imgUploadPop.style.display = 'none'; };
        img.src = event.target.result;
    };
    reader.readAsDataURL(file);
}

function checkCordLabelClick(sx, sy) {
    const w = toWorld(sx, sy);
    for (const item of data.label) { const s = toScr(item.pt); if(Math.hypot(s.x - sx, s.y - sy) < 40) { showLabelEditor({ item: item, type: 'simple', index: -1, x: sx, y: sy }); return; } }
    let best = checkLabelClick(sx, sy); if (best) { showLabelEditor(best); return; }
    const {label, index} = getNewItemData('label'); if (!data.label) data.label = []; 
    const newItem = {pt: w, label: label, index: index, text: '', isVisible: true}; data.label.push(newItem);
    showLabelEditor({ item: newItem, type: 'simple', index: -1, x: sx, y: sy });
}

function checkLabelClick(sx, sy, specificItem=null, specificType=null) {
    const w = toWorld(sx, sy); let best = null;
    const search = (item, L) => {
        if (item.points) {
            if(item.ptLabels) {
                Object.keys(item.ptLabels).forEach(idx => {
                    const i = parseInt(idx); const labelPos = item.ptLabelPos && item.ptLabelPos[i] ? item.ptLabelPos[i] : item.points[i];
                    const sc = toScr(labelPos);
                    if(Math.hypot(sc.x - sx, s.y - sy) < 30) { if (!best || Math.hypot(sc.x - sx, s.y - sy) < best.d) best = { item: item, type: 'point', index: i, x: sc.x, y: sc.y, L, d: Math.hypot(sc.x - sx, s.y - sy) }; }
                });
            }
            if(item.segLabels) {
                Object.keys(item.segLabels).forEach(idx => {
                    const i = parseInt(idx); let labelPos;
                    if (item.segLabelPos && item.segLabelPos[i]) labelPos = item.segLabelPos[i];
                    else labelPos = getPolylineMidpoint([item.points[i], item.points[i+1]]);
                    const sc = toScr(labelPos);
                    if(Math.hypot(sc.x - sx, s.y - sy) < 30) {
                        if (!best || Math.hypot(sc.x - sx, s.y - sy) < best.d) best = { item: item, type: 'point', index: i, x: sc.x, y: sc.y, L, d: Math.hypot(sc.x - sx, s.y - sy) };
                        if (!best || Math.hypot(sc.x - sx, s.y - sy) < best.d) best = { item: item, type: 'seg', index: i, x: sc.x, y: sc.y, L, d: Math.hypot(sc.x - sx, s.y - sy) };
                    }
                });
            }
        }
    }
    if (specificItem) search(specificItem, specificType); else Object.keys(data).forEach(L => { if (L === 'label') return; data[L].forEach(item => search(item, L)); });
    return best;
}

function showLabelEditor(target) {
    activeLabelTarget = target; const el = document.getElementById('lblEditor'); const inp = document.getElementById('lblInput'); 
    let val = ''; let worldPos;
    if (target.type === 'simple') worldPos = target.item.pt;
    else if (target.type === 'point') worldPos = target.item.ptLabelPos && target.item.ptLabelPos[target.index] ? target.item.ptLabelPos[target.index] : target.item.points[target.index];
    else if (target.type === 'seg') worldPos = target.item.segLabelPos && target.item.segLabelPos[target.index] ? target.item.segLabelPos[target.index] : getPolylineMidpoint([target.item.points[target.index], target.item.points[target.index+1]]);
    const s = toScr(worldPos);
    if (target.type === 'point') { if(!target.item.ptLabels) target.item.ptLabels = {}; val = target.item.ptLabels[target.index] || ''; inp.placeholder = 'Point Note'; } 
    else if (target.type === 'seg') { if(!target.item.segLabels) target.item.segLabels = {}; val = target.item.segLabels[target.index] || ''; inp.placeholder = 'Line Note'; } 
    else if (target.type === 'simple') { val = target.item.text || ''; inp.placeholder = 'Label Text'; }
    inp.value = val; el.style.left = s.x + 'px'; el.style.top = s.y + 'px'; el.style.display = 'block'; 
    setTimeout(() => { inp.focus(); inp.select(); }, 50);
}

document.getElementById('lblInput').onchange = (e) => {
    if(!activeLabelTarget) return; 
    const val = e.target.value; const item = activeLabelTarget.item;
    if(activeLabelTarget.type === 'point') item.ptLabels[activeLabelTarget.index] = val;
    else if (activeLabelTarget.type === 'seg') item.segLabels[activeLabelTarget.index] = val;
    else if (activeLabelTarget.type === 'simple') { item.text = val; if (val === '') { const idx = data.label.indexOf(item); if(idx > -1) data.label.splice(idx, 1); } }
    document.getElementById('lblEditor').style.display = 'none'; requestRender();
};

document.getElementById('lblInput').addEventListener('keydown', (e) => { if (e.key === 'Enter') document.getElementById('lblInput').onchange({target: e.target}); });
document.getElementById('lblInput').onblur = (e) => {
    setTimeout(() => {
        if (activeLabelTarget && activeLabelTarget.type === 'simple' && (!activeLabelTarget.item.text || activeLabelTarget.item.text.trim() === '')) {
            const idx = data.label.indexOf(activeLabelTarget.item); if (idx > -1) data.label.splice(idx, 1); requestRender();
        }
    }, 150);
};

cv.addEventListener('wheel',e=>{
    e.preventDefault(); const r=canvasWrap.getBoundingClientRect(); const mx=e.clientX-r.left, my=e.clientY-r.top;
    const w=toWorld(mx,my); const f = e.deltaY<0 ? 1.1 : 0.9; const nz = Math.max(0.1, Math.min(10, scale*f));
    panX = mx - w.x*nz; panY = my - w.y*nz; scale=nz; requestRender();
},{passive:false});

let redoStack = [];
function getNewItemData(L){
    actionCounter++; const p = pfx[L] || 'L'; let label = '';
    if (L === 'wreath' || L === 'wreath32' || L === 'wreath42') { const pWreath = 'WR'; const indexWreath = nextIndex(pWreath); label = pWreath + indexWreath; } 
    else if (L === 'label') label = pfx.label + nextIndex(pfx.label);
    else label = (L==='cords'||L==='threeway'||L==='powersource'||L==='bow' || L==='custom_icon') ? '' : p + nextIndex(p);
    return {label, index: actionCounter};
}

document.getElementById('btnUndo').onclick=()=>{
    if (sketch && sketch.points.length > 0) {
        sketch.points.pop(); if (sketch.cps) sketch.cps.pop(); 
        const canComplete = sketch.points.length >= 2;
        document.getElementById('btnComplete').disabled = !canComplete;
        if (canComplete) document.getElementById('btnComplete').classList.add('selectable');
        else document.getElementById('btnComplete').classList.remove('selectable');
        markPowerDirty(); requestRender(); return;
    }
    let maxIndex = -1; let targetObj = null; let targetLayer = null; let targetIdxInArray = -1;
    for (const L in data) {
        const arr = Array.isArray(data[L]) ? data[L] : (data[L] ? [data[L]] : []);
        arr.forEach((item, idx) => { if (item.index > maxIndex) { maxIndex = item.index; targetObj = item; targetLayer = L; targetIdxInArray = idx; } });
    }
    if (targetObj && targetLayer) {
        redoStack.push({layer: targetLayer, item: targetObj}); document.getElementById('btnRedo').disabled = false;
        if (Array.isArray(data[targetLayer])) data[targetLayer].splice(targetIdxInArray, 1); else data[targetLayer] = null;
        markPowerDirty(); refreshTable(); updateVisibilityMenu(); requestRender();
    }
};
document.getElementById('btnRedo').onclick = () => {
    if(redoStack.length === 0) return; const record = redoStack.pop(); if(redoStack.length === 0) document.getElementById('btnRedo').disabled = true;
    if (record.layer === 'custom_icon' && record.item.url) { const img = new Image(); img.src = record.item.url; record.item.imageObj = img; }
    if (Array.isArray(data[record.layer])) data[record.layer].push(record.item); else data[record.layer] = record.item;
    markPowerDirty(); refreshTable(); updateVisibilityMenu(); requestRender();
};

let sketch=null; 
function startNewSketch(){
    const d = getNewItemData(currLayer);
    sketch={points:[],cps:[],layer:currLayer,label:d.label, index: d.index, firstHost:null, isPillarMode: chkPillar.checked, isVisible: true}; 
    document.getElementById('btnComplete').disabled=true; document.getElementById('btnComplete').classList.remove('selectable');
}
document.getElementById('btnComplete').onclick = completeSketch;

function handleTap(sx,sy){
    if(!imgReady || mode!=='draw' || draggingPoint) return;
    const w=toWorld(sx,sy); redoStack = []; document.getElementById('btnRedo').disabled = true;
    if(['powersource','threeway','tree','wreath','bow', 'custom_icon', 'ghost_door'].includes(currLayer)){ placeItem(currLayer, w, sx, sy); return; }
    if(!sketch) startNewSketch();
    let pt = w; 
    if(chkSnap.checked){
        const sn = getSnap(sx,sy,25); 
        if(sn) {
            pt = {x:sn.x, y:sn.y}; if(sketch.points.length===0) sketch.firstHost = sn.host;
            if(sn.host && data.threeway.includes(sn.host)){ if(countConnections(sn.host) >= 4){ showAlert("3-Way limit reached."); if(sketch.points.length === 0) return; } }
        }
    }
    if(sketch.points.length > 0 && pt) { const dest3Way = find3WayAt(pt); if(dest3Way) { if(countConnections(dest3Way) >= 4){ showAlert("Destination 3-Way limit reached."); return; } } }
    sketch.points.push(pt);
    if(['garland','groundstakes','cords'].includes(currLayer)) {
        if(sketch.points.length > 1) {
            const p1 = sketch.points[sketch.points.length - 2]; const p2 = sketch.points[sketch.points.length - 1];
            if(chkSwag.checked && currLayer === 'garland') {
                const mx = (p1.x + p2.x) / 2; const my = (p1.y + p2.y) / 2; const dist = Math.hypot(p2.x - p1.x, p2.y - p1.y);
                sketch.cps.push({x: mx, y: my + (dist * 0.2)}); 
            } else { if (!sketch.cps) sketch.cps = []; sketch.cps.push(null); }
        }
    }
    const canComplete = sketch.points.length >= 2;
    document.getElementById('btnComplete').disabled = !canComplete;
    if (canComplete) document.getElementById('btnComplete').classList.add('selectable');
    else document.getElementById('btnComplete').classList.remove('selectable');
    markPowerDirty(); requestRender();
}

function handleSelectDown(sx, sy){
    isMovingLabel = false;
    let hitPoint = null; let bestPointDist = 45; 
    const searchPoints = (list, type, overrideHitbox=30) => {
        if (!list) return;
        const arr = Array.isArray(list) ? list : [list];
        arr.forEach((obj, i) => {
            if (!obj || obj.isVisible === false) return;
            const currentHitbox = (type === 'threeway' || type === 'powersource') ? 45 : overrideHitbox; 
            if (obj.points) {
                obj.points.forEach((p, index) => {
                    const d = Math.hypot(sx - toScr(p).x, sy - toScr(p).y);
                    if (d < currentHitbox) { if (!hitPoint || d < hitPoint.d) hitPoint = { obj, index, type, d: d }; }
                });
            } else if (obj.tl) {
                 // Ghost Door handles
                 ['tl','tr','bl','br'].forEach(k => {
                     const d = Math.hypot(sx - toScr(obj[k]).x, sy - toScr(obj[k]).y);
                     if (d < 30) { if (!hitPoint || d < hitPoint.d) hitPoint = { obj, key: k, type, d: d }; }
                 });
                 // Ghost Door Center (the ghost icon) click to hide
                 const center = { x: (obj.tl.x + obj.br.x) / 2, y: (obj.tl.y + obj.br.y) / 2 };
                 const dCenter = Math.hypot(sx - toScr(center).x, sy - toScr(center).y);
                 if (dCenter < 30) { obj.isVisible = false; selectedItem = null; requestRender(); return; }
            } else if (obj.pt) {
                const scaleFactor = (type === 'threeway' || type === 'powersource') ? settings.junctionScale : settings.iconScale;
                const scaledHitbox = (type === 'label') ? 40 : 30 * scaleFactor; 
                const d = Math.hypot(sx - toScr(obj.pt).x, sy - toScr(obj.pt).y);
                if (d < scaledHitbox) { if (!hitPoint || d < hitPoint.d) hitPoint = { obj, index: -1, type, d: d }; }
            }
        });
    };
    if (selectedItem && selectedItem.obj) searchPoints([selectedItem.obj], selectedItem.type, 50); 
    if (!hitPoint) Object.keys(data).forEach(k => searchPoints(data[k], k, bestPointDist)); 
    let isCustomIconHandleDrag = false;
    data.custom_icon.forEach(ci => {
        if (ci.isVisible === false) return;
        const sTL = toScr(ci.pt); const scaledW = ci.w * ci.scale * scale; const scaledH = ci.h * ci.scale * scale;
        const handles = [ { pos: sTL, handle: 'move' }, { pos: {x: sTL.x + scaledW, y: sTL.y + scaledH}, handle: 'scale' } ];
        for (const { pos, handle } of handles) {
            const d = Math.hypot(sx - pos.x, sy - pos.y);
            if (d < 30) { draggingPoint = { obj: ci, index: (handle === 'scale') ? -2 : -1, type: 'custom_icon', d: d, handle: handle }; isCustomIconHandleDrag = true; break; }
        }
    });
    if (isCustomIconHandleDrag) { selectedItem = { type: 'custom_icon', obj: draggingPoint.obj }; updateModeTag(); requestRender(); return; }
    if (hitPoint) { draggingPoint = hitPoint; selectedItem = { type: hitPoint.type, obj: hitPoint.obj }; updateModeTag(); requestRender(); return; }
    let bestObject = null; let bestObjectDist = 30; const w = toWorld(sx, sy);
    const searchObjects = (list, type) => {
        if(!list) return;
        const arr = Array.isArray(list) ? list : [list];
        arr.forEach(obj => {
            if (!obj || obj.isVisible === false) return;
            if (obj.points) {
                for (let i = 0; i < obj.points.length - 1; i++) {
                    const p = projOnSeg(w, obj.points[i], obj.points[i + 1]); const s = toScr(p.q); const d = Math.hypot(sx - s.x, sy - s.y);
                    if (p.t >= 0 && p.t <= 1 && d < bestObjectDist) { bestObjectDist = d; bestObject = { type, obj }; }
                }
            } else if (obj.pt) {
                 const d = Math.hypot(sx - toScr(obj.pt).x, sy - toScr(obj.pt).y);
                 if (d < bestObjectDist) { bestObjectDist = d; bestObject = { type, obj }; }
            } else if (obj.tl) {
                 const d = Math.hypot(sx - toScr(obj.bl).x, sy - toScr(obj.bl).y);
                 if (d < bestObjectDist) { bestObjectDist = d; bestObject = { type, obj }; }
            }
        });
    };
    Object.keys(data).forEach(k => searchObjects(data[k], k));
    if (bestObject) { selectedItem = bestObject; if (mode === 'move-label') mode = 'select'; updateModeTag(); } 
    else { selectedItem = null; mode = 'select'; updateModeTag(); }
    requestRender();
}

function getItemCenter(obj){
    if(obj.pt) { if (obj.kind === 'custom_icon') { const scaledW = obj.w * obj.scale; const scaledH = obj.h * obj.scale; return { x: obj.pt.x + scaledW / 2, y: obj.pt.y + scaledH / 2 }; } return obj.pt; }
    if(obj.points){ let sx=0, sy=0; obj.points.forEach(p=>{sx+=p.x; sy+=p.y}); return {x:sx/obj.points.length, y:sy/obj.points.length}; } 
    if(obj.bl) return obj.bl;
    return {x:0,y:0};
}
function deleteItem(sel){
    const arr = data[sel.type]; 
    if (Array.isArray(arr)) { const idx = arr.indexOf(sel.obj); if(idx > -1) arr.splice(idx, 1); } else data[sel.type] = null;
    markPowerDirty(); refreshTable(); updateVisibilityMenu(); redoStack = []; document.getElementById('btnRedo').disabled = true;
}

function openPop(el, x, y, cb){
    el.style.display='flex'; el.style.left = '50%'; el.style.top = '50%'; el.style.transform = 'translate(-50%, -50%)';
    const h = e=>{ const v = e.target.dataset.bow || e.target.dataset.size; if(v){ cb(v); el.style.display='none'; el.removeEventListener('click',h); } }
    el.addEventListener('click',h);
}

function getPolylineMidpoint(points){
    if(points.length < 2) return points[0];
    let totalDist = 0; const segs = [];
    for(let i=0; i<points.length-1; i++){ const d = Math.hypot(points[i+1].x - points[i].x, points[i+1].y - points[i].y); totalDist += d; segs.push(d); }
    let target = totalDist / 2;
    for(let i=0; i<segs.length; i++){
        if(target <= segs[i]){ const t = target / segs[i]; return { x: points[i].x + (points[i+1].x - points[i].x) * t, y: points[i].y + (points[i+1].y - points[i].y) * t }; }
        target -= segs[i];
    }
    return points[points.length-1];
}

function drawTreeIcon(ctx, p, kind, size, scale, itemScale, overrideScale = 1.0) { 
    const baseScale = 3.0; let catScale = 1.0;
    if(kind === 'C9 Tree') catScale = settings.c9TreeScale || 1.0;
    else if(kind === 'ToL') catScale = settings.tolScale || 1.0;
    else catScale = settings.miniTreeScale || 1.0;
    scale *= (itemScale * 0.25 * baseScale * catScale * (overrideScale || 1.0));
    if(kind.includes('Branch')) { 
        const h = 25 * scale;
        ctx.strokeStyle = 'black'; ctx.lineWidth = 5 * scale; ctx.lineCap = 'round'; ctx.lineJoin = 'round';
        ctx.beginPath(); ctx.moveTo(p.x, p.y); ctx.lineTo(p.x, p.y - h); ctx.moveTo(p.x - 12*scale, p.y - h*0.4); ctx.quadraticCurveTo(p.x, p.y - h*0.1, p.x + 12*scale, p.y - h*0.4); ctx.moveTo(p.x - 10*scale, p.y - h*0.7); ctx.quadraticCurveTo(p.x, p.y - h*0.4, p.x + 10*scale, p.y - h*0.7); ctx.stroke();
        ctx.strokeStyle = '#d4b483'; ctx.lineWidth = 3 * scale; ctx.beginPath(); ctx.moveTo(p.x, p.y); ctx.lineTo(p.x, p.y - h); ctx.stroke(); ctx.beginPath(); ctx.moveTo(p.x - 12*scale, p.y - h*0.4); ctx.quadraticCurveTo(p.x, p.y - h*0.1, p.x + 12*scale, p.y - h*0.4); ctx.stroke(); ctx.beginPath(); ctx.moveTo(p.x - 10*scale, p.y - h*0.7); ctx.quadraticCurveTo(p.x, p.y - h*0.4, p.x + 10*scale, p.y - h*0.7); ctx.stroke();
    } else if(kind.includes('Canopy')) {
        const h = 30 * scale; ctx.strokeStyle = 'black'; ctx.lineWidth = 5 * scale; ctx.beginPath(); ctx.moveTo(p.x, p.y); ctx.lineTo(p.x, p.y - h/2); ctx.stroke(); ctx.beginPath(); ctx.arc(p.x, p.y - h*0.6, 12*scale, 0, Math.PI*2); ctx.stroke();
        ctx.strokeStyle = '#fff'; ctx.lineWidth = 3 * scale; ctx.beginPath(); ctx.moveTo(p.x, p.y); ctx.lineTo(p.x, p.y - h/2); ctx.stroke(); ctx.strokeStyle = '#22c55e'; ctx.beginPath(); ctx.arc(p.x, p.y - h*0.6, 12*scale, 0, Math.PI*2); ctx.stroke();
    } else if(kind === 'C9 Tree') {
        const startY = p.y - 8*scale; const triH = 12 * scale; const triW = 14 * scale;
        ctx.strokeStyle = 'black'; ctx.lineWidth = 5 * scale; ctx.lineJoin = 'round'; ctx.beginPath(); ctx.moveTo(p.x, p.y); ctx.lineTo(p.x, p.y - 8*scale); ctx.stroke();
        for(let i=0; i<3; i++){ const yBase = startY - (i * triH * 0.6); ctx.beginPath(); ctx.moveTo(p.x - triW * (1 - i*0.1), yBase); ctx.lineTo(p.x + triW * (1 - i*0.1), yBase); ctx.lineTo(p.x, yBase - triH); ctx.closePath(); ctx.stroke(); }
        ctx.strokeStyle = '#fff'; ctx.lineWidth = 3 * scale; ctx.beginPath(); ctx.moveTo(p.x, p.y); ctx.lineTo(p.x, p.y - 8*scale); ctx.stroke();
        ctx.strokeStyle = '#22c55e'; for(let i=0; i<3; i++){ const yBase = startY - (i * triH * 0.6); ctx.beginPath(); ctx.moveTo(p.x - triW * (1 - i*0.1), yBase); ctx.lineTo(p.x + triW * (1 - i*0.1), yBase); ctx.lineTo(p.x, yBase - triH); ctx.closePath(); ctx.stroke(); }
    } else if (kind === 'ToL') {
        const h = (size || 9) * 3 * scale; const w = 8 * scale; 
        ctx.beginPath(); ctx.moveTo(p.x, p.y - h); ctx.lineTo(p.x - w, p.y); ctx.lineTo(p.x + w, p.y); ctx.closePath(); 
        ctx.strokeStyle = 'black'; ctx.lineWidth = 2 * scale; ctx.stroke(); ctx.fillStyle = '#22c55e'; ctx.fill(); 
        ctx.lineWidth = 0.6 * scale; ctx.stroke();
    } else { ctx.fillStyle = '#22c55e'; ctx.beginPath(); ctx.arc(p.x, p.y, 10*scale, 0, Math.PI*2); ctx.fill(); ctx.stroke(); }
}

function requestRender(){ window.requestAnimationFrame(draw); }

function drawArrow(p, dir, color){
    const arrowS = settings.arrowScale || 1.0;
    const L = 10 * arrowS * scale; const ang = Math.atan2(dir.y, dir.x); 
    const baseWidth = 4 * arrowS * scale; const colorWidth = 2 * arrowS * scale;
    ctx.beginPath(); ctx.moveTo(p.x, p.y); ctx.lineTo(p.x - L*Math.cos(ang-Math.PI/6), p.y - L*Math.sin(ang-Math.PI/6)); ctx.moveTo(p.x, p.y); ctx.lineTo(p.x - L*Math.cos(ang+Math.PI/6), p.y - L*Math.sin(ang+Math.PI/6)); ctx.strokeStyle = 'black'; ctx.lineWidth = baseWidth; ctx.stroke();
    ctx.beginPath(); ctx.moveTo(p.x, p.y); ctx.lineTo(p.x - L*Math.cos(ang-Math.PI/6), p.y - L*Math.sin(ang-Math.PI/6)); ctx.moveTo(p.x, p.y); ctx.lineTo(p.x - L*Math.cos(ang+Math.PI/6), p.y - L*Math.sin(ang+Math.PI/6)); ctx.strokeStyle = '#ef4444'; ctx.lineWidth = colorWidth; ctx.stroke();
}
function drawDeadEnd(p, neighbor, color){
    const capLen = 7.5 * settings.lineScale * scale; 
    const sP = toScr(p); const sN = toScr(neighbor); 
    const dx = sP.x - sN.x, dy = sP.y - sN.y; const ang = Math.atan2(dy, dx); 
    const px = Math.cos(ang + Math.PI/2) * capLen; const py = Math.sin(ang + Math.PI/2) * capLen;
    ctx.beginPath(); ctx.moveTo(sP.x - px, sP.y - py); ctx.lineTo(sP.x + px, sP.y + py); 
    ctx.strokeStyle = '#000'; ctx.lineWidth = 4 * settings.lineScale * scale; ctx.stroke(); 
    ctx.strokeStyle = color; ctx.lineWidth = 2 * settings.lineScale * scale; ctx.stroke();
}
function drawBow(x, y, scale, itemScale){
    const baseBowSize = 20; const s = baseBowSize * itemScale * scale * 0.4; 
    ctx.fillStyle = '#ef4444'; ctx.strokeStyle='black'; ctx.lineWidth=1 * itemScale * scale;
    ctx.beginPath(); ctx.arc(x, y, s*0.25, 0, Math.PI*2); ctx.fill(); ctx.stroke();
    ctx.beginPath(); ctx.ellipse(x-s*0.5, y-s*0.15, s*0.5, s*0.35, -0.3, 0, Math.PI*2); ctx.fill(); ctx.stroke();
    ctx.beginPath(); ctx.ellipse(x+s*0.5, y-s*0.15, s*0.5, s*0.35, 0.3, 0, Math.PI*2); ctx.fill(); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(x,y); ctx.quadraticCurveTo(x-s*0.5, y+s*0.8, x-s*0.6, y+s*1.2); ctx.lineTo(x-s*0.3, y+s*1.2); ctx.quadraticCurveTo(x-s*0.2, y+s*0.8, x,y); ctx.fill();
    ctx.beginPath(); ctx.moveTo(x,y); ctx.quadraticCurveTo(x+s*0.5, y+s*0.8, x+s*0.6, y+s*1.2); ctx.lineTo(x+s*0.3, y+s*1.2); ctx.quadraticCurveTo(x+s*0.2, y+s*0.8, x,y); ctx.fill(); ctx.stroke();
}

function drawGhostDoor(ctx) {
    if (!data.ghostDoor || (currLayer !== 'ghost_door' && !data.ghostDoor.isVisible)) return;
    const d = data.ghostDoor;
    const pts = [toScr(d.tl), toScr(d.tr), toScr(d.br), toScr(d.bl)];

    ctx.save();
    ctx.beginPath();
    ctx.moveTo(pts[0].x, pts[0].y);
    pts.forEach(p => ctx.lineTo(p.x, p.y));
    ctx.closePath();
    
    ctx.strokeStyle = '#fbbf24'; 
    ctx.lineWidth = 2;
    ctx.setLineDash([5, 5]);
    ctx.stroke();
    ctx.fillStyle = 'rgba(251, 191, 36, 0.1)';
    ctx.fill();

    // Draw handles
    ctx.setLineDash([]);
    pts.forEach(p => {
        ctx.beginPath();
        ctx.arc(p.x, p.y, 8, 0, Math.PI * 2);
        ctx.fillStyle = '#fff';
        ctx.fill();
        ctx.stroke();
    });
    
    // Center ghost icon
    const centerX = (pts[0].x + pts[2].x) / 2;
    const centerY = (pts[0].y + pts[2].y) / 2;
    ctx.font = '24px serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillStyle = 'white';
    ctx.fillText('', centerX, centerY);
    
    ctx.restore();
}

function segmentLength(p1, p2, cp = null) {
    if (!cp) return Math.hypot(p2.x - p1.x, p2.y - p1.y);
    const steps = 15; let len = 0; let last = p1;
    for (let i = 1; i <= steps; i++) {
        const t = i / steps; const mt = 1-t;
        const qx = mt*mt*p1.x + 2*mt*t*cp.x + t*t*p2.x;
        const qy = mt*mt*p1.y + 2*mt*t*cp.y + t*t*p2.y;
        len += Math.hypot(qx-last.x, qy-last.y); last = {x:qx, y:qy};
    }
    return len;
}
function getPointOnSegmentAtDist(p1, p2, dist, targetDist, cp = null) {
    if (!cp) { const t = targetDist / dist; return { x: p1.x + (p2.x - p1.x) * t, y: p1.y + (p2.y - p1.y) * t, t: t, dx: (p2.x - p1.x) / dist, dy: (p2.y - p1.y) / dist }; }
    const steps = 20; let accumulatedDist = 0; let prevP = p1;
    for (let i = 1; i <= steps; i++) {
        const t = i / steps; const mt = 1 - t; const qx = mt * mt * p1.x + 2 * mt * t * cp.x + t * t * p2.x; const qy = mt * mt * p1.y + 2 * mt * t * cp.y + t * t * p2.y; const currentP = { x: qx, y: qy };
        const stepDist = Math.hypot(currentP.x - prevP.x, currentP.y - prevP.y);
        if (accumulatedDist + stepDist >= targetDist) { const remaining = targetDist - accumulatedDist; const subT = remaining / stepDist; const px = prevP.x + (currentP.x - prevP.x) * subT; const py = prevP.y + (currentP.y-prevP.y) * subT; const dx = (currentP.x - prevP.x) / stepDist; const dy = (currentP.y - prevP.y) / stepDist; return { x: px, y: py, t: t, dx, dy }; }
        accumulatedDist += stepDist; prevP = currentP;
    }
    return { x: p2.x, y: p2.y, t: 1, dx: 0, dy: 0 };
}

function drawContinuousLine(it, col, layerName, isForExport = false, arrowDensityScale = 1) {
    if (it.points.length < 2) return;
    const points = it.points.map(p => toScr(p)); const cps = it.cps ? it.cps.map(p => p ? toScr(p) : null) : [];
    const baseWidth = settings.lineThickness * settings.lineScale * scale; const strokeWidth = baseWidth + (4 * settings.lineScale * scale); 
    const rawColorString = it.col || '';
    const normalizedColorString = rawColorString.toLowerCase().replace(/\s/g, '/').replace(/,/g, '/');
    let colors = [];
    normalizedColorString.split('/').forEach(c => { const resolvedColor = getColorCode(c); if (resolvedColor.includes('/')) { resolvedColor.split('/').forEach(subC => { const subHex = getColorCode(subC); if (subHex !== '#ddd') colors.push(subHex); }); } else if (resolvedColor !== '#ddd') { colors.push(resolvedColor); } });
    if (layerName === 'garland' || layerName === 'wreath') colors = [getColorCode('green')];
    else if (layerName === 'cords') colors = ['#000000']; 
    else if (layerName === 'shrub' && colors.length === 0) colors = [getColorCode('green')];
    const finalColors = colors.length > 0 ? colors : [(isC9(layerName) ? colorOf('ridges') : col)]; 
    let glowStrength = 0; let isLightElement = isC9(layerName) || ['windows', 'wreath', 'tree', 'bow', 'shrub'].includes(layerName);
    const CORE_GLOW_BLUR = 2 * scale + (baseWidth * 1.5); 
    if (isNightMode && isLightElement) { glowStrength = CORE_GLOW_BLUR; ctx.shadowBlur = glowStrength; } else { ctx.shadowBlur = 0; }
    const drawDashedPath = (styleFn) => {
        for (let i = 0; i < points.length - 1; i++) {
            const p1 = points[i]; const p2 = points[i+1]; const cp = cps[i] || null;
            ctx.beginPath(); ctx.moveTo(p1.x, p1.y);
            const isDotted = it.isPillarMode && layerName === 'garland' && (i % 2 !== 0); 
            if (isDotted) {
                const dashLen = 8 * settings.lineScale * scale; ctx.setLineDash([dashLen, dashLen]);
            } else ctx.setLineDash([]);
            if (cp) ctx.quadraticCurveTo(cp.x, cp.y, p2.x, p2.y); else ctx.lineTo(p2.x, p2.y);
            styleFn(isDotted); ctx.stroke(); ctx.setLineDash([]); 
        }
    };
    if (layerName === 'cords') {
        ctx.strokeStyle = 'rgba(255,255,255,0.4)'; ctx.lineWidth = baseWidth + 2 * settings.lineScale * scale; ctx.lineCap = 'round'; ctx.lineJoin = 'round';
        drawDashedPath(() => {});
    } else {
        ctx.strokeStyle = 'black'; ctx.lineWidth = strokeWidth; ctx.lineCap = 'round'; ctx.lineJoin = 'round';
        drawDashedPath(() => {});
    }
    if (finalColors.length <= 1) {
        const color = finalColors[0];
        if (isNightMode && isLightElement) { ctx.shadowBlur = glowStrength; ctx.shadowColor = color; } else { ctx.shadowBlur = 0; }
        ctx.shadowBlur = 0; ctx.strokeStyle = color; ctx.lineWidth = baseWidth; 
        drawDashedPath(() => {});
    } else {
        const worldBlockLength = 10 * settings.lineScale; let colorIndex = 0; ctx.lineCap = 'butt'; 
        for (let i = 0; i < points.length - 1; i++) {
            const worldSegDist = segmentLength(it.points[i], it.points[i+1], it.cps?.[i]);
            const isDottedSegment = it.isPillarMode && layerName === 'garland' && (i % 2 !== 0);
            let currentWorldDist = 0; let lastWorldPt = it.points[i];
            while (currentWorldDist < worldSegDist) {
                const color = finalColors[colorIndex % finalColors.length];
                const blockDist = Math.min(worldBlockLength, worldSegDist - currentWorldDist);
                const nextWorldDist = currentWorldDist + blockDist;
                const ptObj = getPointOnSegmentAtDist(it.points[i], it.points[i+1], worldSegDist, nextWorldDist, it.cps?.[i]);
                const sStart = toScr(lastWorldPt); const sEnd = toScr({x: ptObj.x, y: ptObj.y});
                if (blockDist > 0.01) {
                    if (isNightMode && isLightElement) { ctx.shadowBlur = glowStrength; ctx.shadowColor = color; } else { ctx.shadowBlur = 0; }
                    ctx.shadowBlur = 0; ctx.beginPath(); ctx.moveTo(sStart.x, sStart.y); ctx.lineTo(sEnd.x, sEnd.y);
                    if (isDottedSegment) { const dashLen = 8 * settings.lineScale * scale; ctx.setLineDash([dashLen, dashLen]); } else ctx.setLineDash([]);
                    ctx.strokeStyle = color; ctx.lineWidth = baseWidth; ctx.stroke();
                }
                currentWorldDist = nextWorldDist; lastWorldPt = {x: ptObj.x, y: ptObj.y}; colorIndex++;
            }
        }
        ctx.lineCap = 'round'; ctx.setLineDash([]);
    }
    ctx.shadowBlur = 0;
}

function drawCord(it, col, layerName) { if (it.points.length < 2) return; drawContinuousLine(it, col, layerName); }

function roundRect(ctx, x, y, w, h, r) {
    if (w < 2 * r) r = w / 2; if (h < 2 * r) r = h / 2;
    ctx.beginPath(); ctx.moveTo(x + r, y); ctx.arcTo(x + w, y, x + w, y + h, r); ctx.arcTo(x + w, y + h, x, y + h, r); ctx.arcTo(x, y + h, x, y, r); ctx.arcTo(x, y, x + w, y, r); ctx.closePath();
}

function drawLabels(ctx, isExport=false) {
    const nominalFontSize = 14; const fontScaleFactor = scale * settings.labelScale * 0.35; const currentFontSize = nominalFontSize * fontScaleFactor; 
    if (currentFontSize > 0.1) { 
        ctx.font=`bold ${currentFontSize}px "Inter", system-ui`; ctx.fillStyle='white'; ctx.textAlign='center'; ctx.textBaseline='middle';
        Object.keys(data).forEach(k=>{
            if (k === 'powersource' || k === 'ghostDoor') return;
            data[k].forEach(it=>{
                if((!it.label && k !== 'label') || it.isVisible === false) return; 
                let p, offY;
                if (it.customLabelPos) { p = it.customLabelPos; offY = 0; } 
                else if(it.points) { p = getPolylineMidpoint(it.points); offY = -14 * fontScaleFactor; } 
                else if (it.kind === 'ToL') { 
                    const treeScale = (k === 'tree') ? settings.iconScale : 1.0; 
                    const h = (it.size || 9) * 3 * scale * treeScale * (settings.tolScale || 1.0) * (it.itemScale || 1.0); 
                    p = {x: it.pt.x, y: it.pt.y - (h/2)/scale}; offY = 0; 
                } else if (k === 'custom_icon') { 
                    const scaledW = it.w * it.scale; const scaledH = it.h * it.scale; 
                    p = { x: it.pt.x + scaledW / 2, y: it.pt.y + scaledH / 2 }; offY = 0; 
                } else { p = it.pt; offY = 0; }
                const s = toScr(p);
                let labelText = (k === 'label') ? (it.text || it.label) : it.label;
                if(isC9(k) && it.clip) labelText += ` ${it.clip}`; 
                if(k === 'wreath') labelText += ` ${it.size}`; 
                if(it.fra) labelText += ' (FRA)'; if(it.gguard) labelText += ' (GG)';
                const metrics = ctx.measureText(labelText); const textWidth = metrics.width;
                const padX = 6 * fontScaleFactor; const padY = 4 * fontScaleFactor; 
                const boxWidth = textWidth + (2 * padX); const boxHeight = currentFontSize + (2 * padY); const radius = 6 * fontScaleFactor;
                ctx.fillStyle = 'rgba(15, 23, 42, 0.85)'; roundRect(ctx, s.x - boxWidth/2, s.y + offY - boxHeight/2, boxWidth, boxHeight, radius); ctx.fill();
                ctx.fillStyle='white'; ctx.fillText(labelText, s.x, s.y + offY);
            });
        });
    }
}

function draw(){
    if (!ctx) return;
    const cw = cv.width / DPR; const ch = cv.height / DPR;
    let isBlankMap = imgReady && !imgDataUrl;
    if(isBlankMap){ ctx.fillStyle='#ffffff'; ctx.fillRect(0,0,cw,ch); } else { ctx.fillStyle='#0f172a'; ctx.fillRect(0,0,cw,ch); }
    let filterString = 'none'; 
    if(imgReady && imgDataUrl){ 
        if(isNightMode) filterString = 'brightness(0.25) grayscale(0.2)';
        if(settings.bgBlur > 0) filterString = (filterString==='none'?'':filterString+' ') + `blur(${settings.bgBlur/5}px)`;
        ctx.filter = filterString; ctx.drawImage(bg, panX, panY, bg.width*scale, bg.height*scale); ctx.filter = 'none'; 
    } 
    ctx.shadowBlur = 0; const pg = analyzePower();
    data.cords.forEach(it => { if(it.isVisible !== false) drawCord(it, getColorCode(it.col) || colorOf('cords'), 'cords'); }); 
    ['shrub','windows','ridges','fascia','peaks','groundstakes','garland'].forEach(L=>{ data[L].forEach(it=>{ if(it.isVisible !== false) drawContinuousLine(it, getColorCode(it.col) || colorOf(L), L); }); });
    if(pg){
        pg.edges.forEach(e => {
            if(['groundstakes'].includes(e.type)) return;
            const uNode = pg.nodes[e.u]; const vNode = pg.nodes[e.v];
            if(uNode.dist !== Infinity && vNode.dist !== Infinity){
                const uPos = toScr({x:uNode.x, y:uNode.y}); const vPos = toScr({x:vNode.x, y:vNode.y});
                let isReversed = uNode.dist > vNode.dist;
                const worldDist = segmentLength({x:uNode.x, y:uNode.y}, {x:vNode.x, y:vNode.y}, e.cps);
                let count = Math.floor((worldDist + 0.5) / 100 * settings.arrowFreqFactor);
                if (e.cps) {
                    const cp = toScr(e.cps);
                    for (let k = 1; k <= count; k++) {
                        let t = k / (count + 1); const invT = 1 - t;
                        const px = invT * invT * uPos.x + 2 * invT * t * cp.x + t * t * vPos.x; const py = invT * invT * uPos.y + 2 * invT * t * cp.y + t * t * vPos.y;
                        const tx = 2 * invT * (cp.x - uPos.x) + 2 * t * (vPos.x - cp.x); const ty = 2 * invT * (cp.y - uPos.y) + 2 * t * (vPos.y - cp.y);
                        let dir = { x: tx, y: ty }; if (isReversed) { dir.x = -dir.x; dir.y = -dir.y; }
                        drawArrow({ x: px, y: py }, dir, '#ef4444');
                    }
                } else {
                    const dx = vPos.x - uPos.x, dy = vPos.y - uPos.y;
                    for(let k=1; k<=count; k++){
                        const t = k / (count+1);
                        let dir = {x: dx, y: dy}; if(isReversed) { dir.x = -dir.x; dir.y = -dir.y; }
                        drawArrow({x: uPos.x + dx*t, y: uPos.y + dy*t}, dir, '#ef4444');
                    }
                }
            }
        });
        pg.singleArrowEdges.forEach(a => {
            const edge = a.edge; const uPos = toScr(edge.line.points[edge.index]); const vPos = toScr(edge.line.points[edge.index+1]);
            const segDist = segmentLength(uPos, vPos, edge.cps ? toScr(edge.cps) : null);
            const ptObj = getPointOnSegmentAtDist(uPos, vPos, segDist, a.distInSegment * scale, edge.cps ? toScr(edge.cps) : null);
            let dir = {x: ptObj.dx, y: ptObj.dy}; if (a.isReversed) { dir.x = -dir.x; dir.y = -dir.y; }
            drawArrow({x: ptObj.x, y: ptObj.y}, dir, '#ef4444');
        });
        pg.deadTips.forEach(nodeIdx => { const n = pg.nodes[nodeIdx]; const neighborIdx = n.adj[0]; if(neighborIdx !== undefined){ drawDeadEnd(n, pg.nodes[neighborIdx], '#fffdf0'); } });
    }
    const itemScale = settings.iconScale; const junctionScale = settings.junctionScale; 
    data.wreath.forEach(w=>{
        if (w.isVisible === false) return;
        const s=toScr(w.pt); const wreathCategoryScale = settings.wreathScale || 1.0; const individualScale = w.itemScale || 1.0; const totalWreathScale = itemScale * wreathCategoryScale * individualScale;
        const r=(w.size==='42"'?12.5:8.75) * scale * totalWreathScale; const wreathColor = colorOf('wreath'); 
        if (isNightMode) { ctx.shadowBlur = 15 * scale; ctx.shadowColor = wreathColor; }
        ctx.beginPath(); ctx.arc(s.x,s.y,r,0,Math.PI*2); ctx.fillStyle = colorOf('wreath'); ctx.fill();
        ctx.shadowBlur = 0; ctx.strokeStyle='black'; ctx.lineWidth=6 * totalWreathScale * scale; ctx.stroke(); ctx.strokeStyle=colorOf('wreath'); ctx.lineWidth=3 * totalWreathScale * scale; ctx.stroke(); 
        if(w.bow === 'top' || w.bow === 'bottom'){ const by = w.bow==='top' ? s.y - r : s.y + r; drawBow(s.x, by, scale, totalWreathScale); }
    });
    data.bow.forEach(b=>{ if (b.isVisible === false) return; const s=toScr(b.pt); const bowCategoryScale = settings.bowScale || 1.0; const individualScale = b.itemScale || 1.0; drawBow(s.x, s.y, scale, itemScale * bowCategoryScale * individualScale); }); 
    data.tree.forEach(tr => {
        if (tr.isVisible === false) return;
        const p = toScr(tr.pt); const kind = tr.kind; let catScale = 1.0;
        if(kind === 'C9 Tree') catScale = settings.c9TreeScale || 1.0;
        else if(kind === 'ToL') catScale = settings.tolScale || 1.0;
        else catScale = settings.miniTreeScale || 1.0;
        drawTreeIcon(ctx, p, tr.kind, tr.size, scale, itemScale * catScale * (tr.itemScale || 1.0));
    });
    data.powersource.forEach(ps=>{
        if (ps.isVisible === false) return;
        const s=toScr(ps.pt); const sz = 8 * junctionScale * scale; const strokeWidth = 3 * junctionScale * scale; 
        ctx.fillStyle='#ef4444'; ctx.fillRect(s.x-sz/2, s.y-sz/2, sz, sz); ctx.strokeStyle='black'; ctx.lineWidth=strokeWidth; ctx.strokeRect(s.x-sz/2, s.y-sz/2, sz, sz); ctx.strokeStyle='white'; ctx.lineWidth=strokeWidth/2; ctx.strokeRect(s.x-sz/2, s.y-sz/2, sz, sz);
    });
    if(data.threeway){
        data.threeway.forEach(tw=>{
            if (tw.isVisible === false) return;
            const s = toScr(tw.pt); const sz = 6 * scale * junctionScale; const strokeWidth = 3 * junctionScale * scale;
            ctx.beginPath(); ctx.moveTo(s.x, s.y - sz); ctx.lineTo(s.x + sz, s.y + sz); ctx.lineTo(s.x - sz, s.y + sz); ctx.closePath(); ctx.fillStyle = '#eab308'; ctx.fill();
            ctx.strokeStyle = 'black'; ctx.lineWidth = strokeWidth; ctx.stroke(); ctx.strokeStyle = 'white'; ctx.lineWidth = strokeWidth/2; ctx.stroke();
        });
    }
    data.custom_icon.forEach(ci => {
        if (!ci.url || ci.isVisible === false) return;
        const sTL = toScr(ci.pt); const scaledW = ci.w * ci.scale * scale; const scaledH = ci.h * ci.scale * scale;
        if (!ci.imageObj || ci.imageObj.src !== ci.url) { ci.imageObj = new Image(); ci.imageObj.src = ci.url; }
        if (ci.imageObj.complete) { ctx.drawImage(ci.imageObj, sTL.x, sTL.y, scaledW, scaledH); }
    });
    if(sketch && sketch.points.length>0){
        const cursor = cv._mx!=null ? toWorld(cv._mx, cv._my) : null; const pts = [...sketch.points]; if(cursor) pts.push(cursor);
        const skObj = {points: pts, cps: sketch.cps || [], layer: sketch.layer, col: sketch.col, isPillarMode: sketch.isPillarMode}; 
        const sketchColor = getColorCode(sketch.col) || colorOf(sketch.layer);
        drawContinuousLine(skObj, sketchColor, sketch.layer); 
    }
    if(chkSnap.checked && cv._mx!=null && !matchMedia('(max-width:900px)').matches){
         const sn = getSnap(cv._mx, cv._my, 25, (draggingPoint ? draggingPoint.obj : null));
         if(sn){ const s = toScr({x:sn.x, y:sn.y}); ctx.beginPath(); ctx.arc(s.x, s.y, 6, 0, Math.PI*2); ctx.fillStyle = 'rgba(234, 179, 8, 0.6)'; ctx.fill(); ctx.strokeStyle = '#000'; ctx.lineWidth=1; ctx.stroke(); }
    }
    drawGhostDoor(ctx);
    drawLabels(ctx);
    if(selectedItem){
        const obj = selectedItem.obj; const selectionBaseScale = 1.0; 
        if(obj.points){ obj.points.forEach(p=>{ const s = toScr(p); ctx.beginPath(); ctx.arc(s.x, s.y, 6 * selectionBaseScale, 0, Math.PI*2); ctx.fillStyle = 'white'; ctx.fill(); ctx.strokeStyle = '#3b82f6'; ctx.lineWidth=2 * selectionBaseScale; ctx.stroke(); }); } 
        else if (obj.tl) {
            ['tl','tr','bl','br'].forEach(k => {
                const s = toScr(obj[k]); ctx.beginPath(); ctx.arc(s.x, s.y, 8, 0, Math.PI*2); ctx.fillStyle = 'white'; ctx.fill(); ctx.strokeStyle = '#3b82f6'; ctx.lineWidth=2; ctx.stroke();
            });
        }
        else if (obj.pt && obj.kind !== 'custom_icon'){ const s = toScr(obj.pt); ctx.beginPath(); ctx.arc(s.x, s.y, 15 * selectionBaseScale, 0, Math.PI*2); ctx.strokeStyle = '#3b82f6'; ctx.lineWidth=2 * selectionBaseScale; ctx.stroke(); }
    }
}

window.addEventListener('popstate', () => { document.getElementById('modalBack').style.display = 'flex'; });
document.getElementById('btnStay').onclick = () => { document.getElementById('modalBack').style.display = 'none'; history.pushState(null, null, location.href); };
document.getElementById('btnLeave').onclick = () => { document.getElementById('modalBack').style.display = 'none'; history.back(); };
const handleImg = (f)=>{
    if(!f) return; const r=new FileReader();
    r.onload=()=>{ imgDataUrl=r.result; bg.src=imgDataUrl; bg.onload=()=>{ imgReady=true; document.body.classList.remove('white-bg'); resetView(); unlock(); }; bg.onerror=()=>{ showAlert("Failed to load image"); }; };
    r.readAsDataURL(f);
};

function startBlankMap() { 
    for(const key in data) data[key] = Array.isArray(data[key]) ? [] : null;
    bg.width = 1000; bg.height = 1000; imgDataUrl = null; imgReady = true; document.body.classList.add('white-bg'); resetView(); refreshTable(); updateVisibilityMenu(); unlock(); 
}

function getCleanData() { const cleanData = JSON.parse(JSON.stringify(data)); if (cleanData.custom_icon) { cleanData.custom_icon.forEach(icon => { delete icon.imageObj; }); } return cleanData; }

function applyUIState(o) {
    lineScaleInput.value = settings.lineScale; iconScaleInput.value = settings.iconScale; junctionScaleInput.value = settings.junctionScale; labelScaleInput.value = settings.labelScale; arrowFreqInput.value = settings.arrowFreqFactor; bgBlurInput.value = settings.bgBlur;
    c9TreeScaleInput.value = settings.c9TreeScale || 1.0; miniTreeScaleInput.value = settings.miniTreeScale || 1.0; tolScaleInput.value = settings.tolScale || 1.0; wreathScaleInput.value = settings.wreathScale || 1.0; bowScaleInput.value = settings.bowScale || 1.0;
    updateLineScaleUI(); updateIconScaleUI(); updateJunctionScaleUI(); updateLabelScaleUI(); updateArrowFreqUI(); updateBgBlurUI();
    const uiState = o.uiState || {}; isNightMode = uiState.isNightMode !== undefined ? uiState.isNightMode : false;
    const nightModeToolButton = toolBtn['night_mode'];
    if (nightModeToolButton) { nightModeToolButton.classList.toggle('toggled', isNightMode); nightModeToolButton.classList.toggle('night-glow', isNightMode); }
    chkSnap.checked = uiState.isSnapOn !== undefined ? uiState.isSnapOn : true; btnSnap.classList.toggle('toggled', chkSnap.checked);
    chkSwag.checked = uiState.isSwagOn !== undefined ? uiState.isSwagOn : false; btnSwag.classList.toggle('toggled', chkSwag.checked);
    chkPillar.checked = uiState.isPillarOn !== undefined ? uiState.isPillarOn : false; btnPillar.classList.toggle('toggled', chkPillar.checked);
    const chkAuto = document.getElementById('chkAutoCalc'); chkAuto.checked = uiState.isAutoCalcOn !== undefined ? uiState.isAutoCalcOn : true;
    requestRender();
}

const handleMap = (f)=>{
    if(!f) return; const r=new FileReader(); r.onload=()=>{ 
        try{ 
            const o=JSON.parse(r.result); imgDataUrl=o.image||null; 
            if(o.data) {
                 let maxIndex = 0; for (const L in data) { data[L] = o.data[L]; const arr = Array.isArray(data[L]) ? data[L] : (data[L] ? [data[L]] : []); arr.forEach(item => { if(item && item.index > maxIndex) maxIndex = item.index; }); }
                 actionCounter = maxIndex;
            }
            if (o.settings) { settings = {...settings, ...o.settings}; }
            applyState(o); applyUIState(o); 
            if(imgDataUrl){ bg.src=imgDataUrl; bg.onload=()=>{ imgReady=true; document.body.classList.remove('white-bg'); resetView(); unlock(); }; } 
            else { bg.width = o.bg_width || 1000; bg.height = o.bg_height || 1000; imgReady = true; document.body.classList.add('white-bg'); resetView(); unlock(); } 
        }catch(e){showAlert('Error loading map');} 
    };
    r.readAsText(f);
};

function applyState(o){
    document.getElementById('customer').value=o.job?.name||''; document.getElementById('address').value=o.job?.address||''; document.getElementById('jobNotes').value=o.job?.notes||''; 
    const timerInputs = document.getElementById('timerInputs'); const btnCC = document.getElementById('btnCustomerControlled');
    if(o.job?.timer?.isCustomerControlled) { timerInputs.style.display = 'none'; btnCC.classList.add('toggled'); document.getElementById('on1').value = 'CC'; } 
    else { 
        timerInputs.style.display = 'block'; btnCC.classList.remove('toggled'); 
        document.getElementById('on1').value = o.job?.timer?.on1 || ''; document.getElementById('off1').value = o.job?.timer?.off1 || ''; 
        document.getElementById('on2').value = o.job?.timer?.on2 || ''; document.getElementById('off2').value = o.job?.timer?.off2 || ''; 
    }
    markPowerDirty(); refreshTable(); updateVisibilityMenu();
}

document.getElementById('btnStd').onclick=()=>{ 
    document.getElementById('on1').value='06:00'; document.getElementById('off1').value='08:00'; document.getElementById('on2').value='17:00'; document.getElementById('off2').value='00:00'; 
    document.getElementById('btnCustomerControlled').classList.remove('toggled'); document.getElementById('timerInputs').style.display = 'block';
};
document.getElementById('btnCustomerControlled').onclick = () => {
    const timerInputs = document.getElementById('timerInputs'); const btnCC = document.getElementById('btnCustomerControlled'); const isActive = btnCC.classList.toggle('toggled');
    if (isActive) { timerInputs.style.display = 'none'; document.getElementById('on1').value = 'CC'; document.getElementById('off1').value = 'CC'; document.getElementById('on2').value = 'CC'; document.getElementById('off2').value = 'CC'; } 
    else { document.getElementById('on1').value = ''; document.getElementById('off1').value = ''; document.getElementById('on2').value = ''; document.getElementById('off2').value = ''; timerInputs.style.display = 'block'; }
};

document.getElementById('gPickImg').onclick=()=>document.getElementById('gImg').click();
document.getElementById('gPickMap').onclick=()=>document.getElementById('gMap').click();
document.getElementById('gImg').onchange=e=>{ handleImg(e.target.files[0]); e.target.value=''; };
document.getElementById('gMap').onchange=e=>{ handleMap(e.target.files[0]); e.target.value=''; };

const delay = ms => new Promise(res => setTimeout(res, ms));
document.getElementById('btnSaveAll').onclick = (e) => { e.preventDefault(); performDualSave(); };
document.getElementById('btnSaveImageOnly').onclick = () => { performSavePdf(); };
document.getElementById('btnSaveMapOnly').onclick = () => { performSaveMapOnly(); };

async function performDualSave() {
    const mapSuccess = await performSaveMapOnly(); await delay(3000); const pdfSuccess = await performSavePdf();
    return mapSuccess || pdfSuccess;
}

function buildPayload() {
    const isCC = document.getElementById('btnCustomerControlled').classList.contains('toggled');
    let thumbnail = null; const thumbCanvas = document.createElement('canvas'); thumbCanvas.width = 160; thumbCanvas.height = 90; const tCtx = thumbCanvas.getContext('2d');
    tCtx.fillStyle = '#0f172a'; tCtx.fillRect(0,0,160,90);
    if(imgReady) {
        const thumbScale = Math.min(160/bg.width, 90/bg.height); tCtx.drawImage(bg, 0, 0, bg.width*thumbScale, bg.height*thumbScale); tCtx.strokeStyle = '#fffdf0'; tCtx.lineWidth = 2;
        ['ridges','fascia','peaks'].forEach(L => { data[L].forEach(it => { if(it && it.isVisible !== false && it.points && it.points.length > 1) { tCtx.beginPath(); tCtx.moveTo(it.points[0].x * thumbScale, it.points[0].y * thumbScale); for(let i=1; i<it.points.length; i++) tCtx.lineTo(it.points[i].x * thumbScale, it.points[i].y * thumbScale); tCtx.stroke(); } }); });
        thumbnail = thumbCanvas.toDataURL('image/jpeg', 0.5);
    }
    return {
        version:20, image:imgDataUrl, data: getCleanData(), thumbnail: thumbnail,
        job:{ 
            name:document.getElementById('customer').value, address:document.getElementById('address').value, notes:document.getElementById('jobNotes').value,
            timer: { on1: document.getElementById('on1').value, off1: document.getElementById('off1').value, on2: document.getElementById('on2').value, off2: document.getElementById('off2').value, isCustomerControlled: isCC }
        },
        settings: settings, uiState: { isNightMode: isNightMode, isSnapOn: chkSnap.checked, isSwagOn: chkSwag.checked, isPillarOn: chkPillar.checked, isAutoCalcOn: document.getElementById('chkAutoCalc').checked }
    };
}

function getFilenameBase() { const year = new Date().getFullYear(); const nm = (document.getElementById('customer').value || 'Untitled').trim(); return `${nm} - ${year} Map`; }
async function performSaveMapOnly() {
    const filenameMap = `${getFilenameBase()}.skmap`; const payload = buildPayload(); const blob = new Blob([JSON.stringify(payload)], {type:'application/octet-stream'});
    const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = filenameMap; a.click();
    saveToGitHub(filenameMap, JSON.stringify(payload));
}
async function performSavePdf() {
    const capture = captureCanvasData(); if(!capture) { showAlert("Error generating image data."); return false; }
    const { url: pngData, width, height } = capture; const { jsPDF } = window.jspdf;
    const pdf = new jsPDF({ orientation: width > height ? 'l' : 'p', unit: 'px', format: [width, height] });
    pdf.addImage(pngData, 'PNG', 0, 0, width, height); const pdfName = `${getFilenameBase()}.pdf`; pdf.save(pdfName);
    saveToGitHub(pdfName, pngData.split(',')[1], true);
}

function wrapText(context, text, x, y, maxWidth, lineHeight) {
    if(!text) return y; let words = text.split(' '); let line = ''; let currentY = y;
    for (let n = 0; n < words.length; n++) {
        let testLine = line + words[n] + ' '; let metrics = context.measureText(testLine);
        if (metrics.width > maxWidth && n > 0) { context.fillText(line, x, currentY); line = words[n] + ' '; currentY += lineHeight; } else line = testLine;
    }
    context.fillText(line, x, currentY); return currentY + lineHeight;
}

function captureCanvasData() {
    if(!imgReady) return null;
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    const checkPt = (p) => { if(p.x < minX) minX = p.x; if(p.y < minY) minY = p.y; if(p.x > maxX) maxX = p.x; if(p.y > maxY) maxY = p.y; };
    let hasItems = false;
    Object.keys(data).forEach(L => { 
        const arr = Array.isArray(data[L]) ? data[L] : (data[L] ? [data[L]] : []);
        arr.forEach(item => { if (!item || item.isVisible === false) return; hasItems = true; if(item.points) item.points.forEach(checkPt); if(item.pt) checkPt(item.pt); if(item.tl) ['tl','tr','bl','br'].forEach(k => checkPt(item[k])); }); 
    });
    if(!hasItems) { minX = 0; minY = 0; maxX = bg.width; maxY = bg.height; } 
    else { const pad = 50; minX = Math.max(0, minX - pad); minY = Math.max(0, minY - pad); maxX = Math.min(bg.width, maxX + pad); maxY = Math.min(bg.height, maxY + pad); }
    const cropW = maxX - minX; const cropH = maxY - minY; const DPI = 2; const MAP_WIDTH_PX = 1000; const MAP_H_PX = Math.round((MAP_WIDTH_PX / cropW) * cropH);
    const testCanvas = document.createElement('canvas'); const tCtx = testCanvas.getContext('2d'); tCtx.font = 'italic 11px "Inter", system-ui';
    const notesWidth = 970; const jNotes = document.getElementById('jobNotes').value; let estimatedNotesHeight = 0;
    if(jNotes) {
        let words = jNotes.split(' '); let line = ''; estimatedNotesHeight = 15;
        for (let n = 0; n < words.length; n++) {
            let testLine = line + words[n] + ' '; if (tCtx.measureText(testLine).width > notesWidth && n > 0) { line = words[n] + ' '; estimatedNotesHeight += 15; } else line = testLine;
        }
    }
    const HEADER_BASE = 110; const HEADER_H = HEADER_BASE + estimatedNotesHeight; const FOOTER_ROW_H = 24; const FOOTER_TITLE_H = 40; 
    const items = collectRows(true); const ITEM_COUNT = items.length; const FOOTER_H = ITEM_COUNT > 0 ? (FOOTER_TITLE_H + ITEM_COUNT * FOOTER_ROW_H + 40) : 0;
    const OUT_W = MAP_WIDTH_PX; const OUT_H = HEADER_H + MAP_H_PX + FOOTER_H;
    const out = document.createElement('canvas'); out.width = OUT_W * DPI; out.height = OUT_H * DPI; const o = out.getContext('2d'); o.scale(DPI, DPI); 
    const oldScale = scale; const oldPanX = panX; const oldPanY = panY; const originalCtx = ctx; 
    try {
        const renderScale = MAP_WIDTH_PX / cropW; const renderPanX = -minX * renderScale; const renderPanY = HEADER_H - (minY * renderScale); 
        scale = renderScale; panX = renderPanX; panY = renderPanY; ctx = o;
        o.fillStyle = '#0f172a'; o.fillRect(0, 0, OUT_W, OUT_H);
        o.fillStyle = 'white'; o.font = 'bold 18px "Inter", system-ui'; o.textAlign = 'left'; o.textBaseline = 'top';
        o.fillText(document.getElementById('customer').value || 'UNTITLED PROJECT', 12, 20);
        o.fillStyle = '#94a3b8'; o.font = '500 13px "Inter", system-ui'; o.fillText(document.getElementById('address').value || 'No address provided', 12, 45);
        o.fillStyle = '#3b82f6'; o.font = 'bold 12px "Inter", system-ui'; o.fillText(`DATE: ${new Date().toLocaleDateString()}`, 12, 65);
        const timerOn1 = document.getElementById('on1').value; const timerOff1 = document.getElementById('off1').value; const timerOn2 = document.getElementById('on2').value; const timerOff2 = document.getElementById('off2').value;
        const isCC = document.getElementById('btnCustomerControlled').classList.contains('toggled') || timerOn1 === 'CC';
        o.textAlign = 'right'; o.fillStyle = '#1e293b'; const timerBoxW = 160; roundRect(o, OUT_W - timerBoxW - 12, 15, timerBoxW, 65, 8); o.fill(); o.strokeStyle = '#334155'; o.stroke();
        o.fillStyle = '#fbbf24'; o.font = 'bold 12px \"Inter\", system-ui'; o.textAlign = 'center'; o.fillText('TIMER SETTINGS', OUT_W - (timerBoxW/2) - 12, 25);
        o.fillStyle = '#f1f5f9'; o.font = 'bold 13px \"Inter\", system-ui'; o.textBaseline = 'middle';
        if (isCC) o.fillText('CUSTOMER CONTROLLED', OUT_W - (timerBoxW/2) - 12, 52);
        else { o.fillText(`T1: ${timerOn1 || '--'} to ${timerOff1 || '--'}`, OUT_W - (timerBoxW/2) - 12, 45); o.fillText(`T2: ${timerOn2 || '--'} to ${timerOff2 || '--'}`, OUT_W - (timerBoxW/2) - 12, 62); }
        o.textBaseline = 'top';
        if(jNotes) { o.textAlign = 'left'; o.fillStyle = '#fbbf24'; o.font = 'bold 11px \"Inter\", system-ui'; o.fillText('INSTALLATION NOTES:', 12, 85); o.fillStyle = '#cbd5e1'; o.font = 'italic 11px \"Inter\", system-ui'; wrapText(o, jNotes, 12, 100, notesWidth, 15); }
        const logoSize = 90; o.drawImage(logo, (OUT_W / 2) - (logoSize / 2), 10, logoSize, logoSize);
        let imageFilter = 'none'; if(isNightMode) imageFilter = 'brightness(0.25) grayscale(0.2)';
        if(settings.bgBlur > 0) imageFilter = (imageFilter==='none'?'':imageFilter+' ') + `blur(${settings.bgBlur/5}px)`;
        o.filter = imageFilter;
        if (imgReady && !imgDataUrl) { o.fillStyle = 'white'; o.fillRect(0, HEADER_H, OUT_W, MAP_H_PX); } else o.drawImage(bg, minX, minY, cropW, cropH, 0, HEADER_H, OUT_W, MAP_H_PX);
        o.filter = 'none';
        data.cords.forEach(it => { if(it && it.isVisible !== false) drawCord(it, getColorCode(it.col) || colorOf('cords'), 'cords'); });
        ['shrub','windows','ridges','fascia','peaks','groundstakes','garland'].forEach(L=>{ data[L].forEach(it=>{ if(it && it.isVisible !== false) drawContinuousLine(it, getColorCode(it.col) || colorOf(L), L); }); });
        const pg = analyzePower();
        if(pg){
             pg.edges.forEach(e => {
                 if(['groundstakes'].includes(e.type)) return;
                 const uNode = pg.nodes[e.u]; const vNode = pg.nodes[e.v];
                 if(uNode.dist !== Infinity && vNode.dist !== Infinity){
                     const uPos = toScr({x:uNode.x, y:uNode.y}); const vPos = toScr({x:vNode.x, y:vNode.y});
                     let from, to, isReversed; if(uNode.dist < vNode.dist) { from = uPos; to = vPos; isReversed = false; } else { from = vPos; to = uPos; isReversed = true; }
                     const worldDist = segmentLength({x:uNode.x, y:uNode.y}, {x:vNode.x, y:vNode.y}, e.cps);
                     let count = Math.floor((worldDist + 0.5) / 100 * settings.arrowFreqFactor);
                     if (e.cps) {
                         const cp = toScr(e.cps);
                         for (let k = 1; k <= count; k++) {
                             let t = k / (count + 1); const invT = 1 - t;
                             const px = invT * invT * uPos.x + 2 * invT * t * cp.x + t * t * vPos.x; const py = invT * invT * uPos.y + 2 * invT * t * cp.y + t * t * vPos.y;
                             const tx = 2 * invT * (cp.x - uPos.x) + 2 * t * (vPos.x - cp.x); const ty = 2 * invT * (cp.y - uPos.y) + 2 * t * (vPos.y - cp.y);
                             let dir = { x: tx, y: ty }; if (isReversed) { dir.x = -dir.x; dir.y = -dir.y; }
                             drawArrow({ x: px, y: py }, dir, '#ef4444');
                         }
                     } else {
                         const dx = vPos.x - uPos.x, dy = vPos.y - uPos.y;
                         for(let k=1; k<=count; k++){
                             const t = k / (count+1);
                             let dir = {x: dx, y: dy}; if(isReversed) { dir.x = -dir.x; dir.y = -dir.y; }
                             drawArrow({x: uPos.x + dx*t, y: uPos.y + dy*t}, dir, '#ef4444');
                         }
                     }
                 }
             });
             pg.deadTips.forEach(nodeIdx => { const n = pg.nodes[nodeIdx]; const neighbor = pg.nodes[n.adj[0]]; if(neighbor) drawDeadEnd(n, neighbor, '#fffdf0'); });
        }
        data.wreath.forEach(w=>{
            if (!w || w.isVisible === false) return;
            const s=toScr(w.pt); const wreathCategoryScale = settings.wreathScale || 1.0; const individualScale = w.itemScale || 1.0; const totalWreathScale = settings.iconScale * wreathCategoryScale * individualScale;
            const r=(w.size==='42"'?12.5:8.75)*scale*totalWreathScale; const wreathColor = colorOf('wreath');
            o.beginPath(); o.arc(s.x,s.y,r,0,Math.PI*2); o.fillStyle = wreathColor; o.fill(); 
            o.strokeStyle='black'; o.lineWidth=6 * totalWreathScale * scale; o.stroke(); o.strokeStyle=wreathColor; o.lineWidth=3 * totalWreathScale * scale; o.stroke();
            if(w.bow === 'top' || w.bow === 'bottom'){ const by = w.bow==='top' ? s.y - r : s.y + r; drawBow(s.x, by, scale, totalWreathScale); }
        });
        data.bow.forEach(b=>{ if (!b || b.isVisible === false) return; const s=toScr(b.pt); const bowCategoryScale = settings.bowScale || 1.0; const individualScale = b.itemScale || 1.0; drawBow(s.x, s.y, scale, settings.iconScale * bowCategoryScale * individualScale); }); 
        data.tree.forEach(tr => {
            if (!tr || tr.isVisible === false) return;
            const p = toScr(tr.pt); const kind = tr.kind; let catScale = 1.0;
            if(kind === 'C9 Tree') catScale = settings.c9TreeScale || 1.0;
            else if(kind === 'ToL') catScale = settings.tolScale || 1.0;
            else catScale = settings.miniTreeScale || 1.0;
            drawTreeIcon(o, p, tr.kind, tr.size, scale, settings.iconScale * catScale * (tr.itemScale || 1.0)); 
        });
        data.powersource.forEach(ps=>{ if(!ps || ps.isVisible === false) return; const s=toScr(ps.pt); const sz = 8*scale*settings.junctionScale; o.fillStyle='#ef4444'; o.fillRect(s.x-sz/2, s.y-sz/2, sz, sz); o.strokeStyle='black'; o.lineWidth=3*scale*settings.junctionScale; o.strokeRect(s.x-sz/2, s.y-sz/2, sz, sz); });
        data.threeway.forEach(tw=>{ if(!tw || tw.isVisible === false) return; const s=toScr(tw.pt); const sz = 6*scale*settings.junctionScale; o.beginPath(); o.moveTo(s.x, s.y-sz); o.lineTo(s.x+sz, s.y+sz); o.lineTo(s.x-sz, s.y+sz); o.closePath(); o.fillStyle='#eab308'; o.fill(); o.strokeStyle='black'; o.lineWidth=3*scale*settings.junctionScale; o.stroke(); });
        data.custom_icon.forEach(ci => {
            if (!ci || !ci.url || ci.isVisible === false) return;
            const sTL = toScr(ci.pt); const scaledW = ci.w * ci.scale * scale; const scaledH = ci.h * ci.scale * scale;
            if (!ci.imageObj || ci.imageObj.src !== ci.url) { ci.imageObj = new Image(); ci.imageObj.src = ci.url; }
            if (ci.imageObj.complete) o.drawImage(ci.imageObj, sTL.x, sTL.y, scaledW, scaledH);
        });
        drawLabels(o);
        if (ITEM_COUNT > 0) {
            const footY = HEADER_H + MAP_H_PX; o.fillStyle = '#1e293b'; o.fillRect(0, footY, OUT_W, FOOTER_H);
            o.fillStyle = '#3b82f6'; o.font = 'bold 15px \"Inter\", system-ui'; o.textAlign = 'left'; o.textBaseline = 'top';
            o.fillText('LINE INFORMATION SUMMARY', 12, footY + 12);
            let y = footY + FOOTER_TITLE_H;
            const cols = [ { label: 'TYPE', w: 0.15 }, { label: 'ID', w: 0.08 }, { label: 'FT', w: 0.08 }, { label: 'BULBS', w: 0.08 }, { label: 'CLIP', w: 0.12 }, { label: 'COLOUR', w: 0.15 }, { label: 'NOTES', w: 0.3 } ];
            o.fillStyle = '#0f172a'; roundRect(o, 8, y-2, OUT_W-16, 22, 6); o.fill();
            o.fillStyle = '#3b82f6'; o.font = 'bold 10px \"Inter\", system-ui'; o.textBaseline = 'middle';
            let headerX = 15; cols.forEach(c => { o.fillText(c.label, headerX, y + 9); headerX += OUT_W * c.w; });
            o.fillStyle = '#f1f5f9'; o.font = '11px \"Inter\", system-ui'; y += 24;
            items.sort((a,b)=>(a.label||'').localeCompare(b.label||'', undefined, {numeric:true})).forEach(r => {
                let x = 15; let typeDisplay = pretty[r.L] || r.L;
                if (r.kind === 'ToL') typeDisplay = 'Tree of Lights';
                o.fillText(typeDisplay, x, y + FOOTER_ROW_H/2); x += OUT_W * cols[0].w;
                o.fillText(r.label || '-', x, y + FOOTER_ROW_H/2); x += OUT_W * cols[1].w;
                o.fillText(r.ft || '-', x, y + FOOTER_ROW_H/2); x += OUT_W * cols[2].w;
                o.fillText(r.bulbs || '-', x, y + FOOTER_ROW_H/2); x += OUT_W * cols[3].w;
                o.fillText(r.clip || '-', x, y + FOOTER_ROW_H/2); x += OUT_W * cols[4].w;
                let displayCol = r.col || '-';
                const nrCol = r.col ? r.col.toLowerCase().replace(/\s/g, '/').replace(/,/g, '/').replace(/ /g, '') : '';
                if (r.L === 'garland' || r.L === 'wreath' || (r.L === 'shrub' && !r.col)) displayCol = 'Green'; 
                else if (r.L === 'cords') displayCol = 'Black'; 
                else { if (nrCol.includes('multi') || nrCol.includes('red/blue') || nrCol === 'm') displayCol = 'Multi'; else if (r.col === '') displayCol = 'Warm White'; else displayCol = r.col; }
                o.fillText(displayCol, x, y + FOOTER_ROW_H/2); x += OUT_W * cols[5].w;
                o.fillText(r.notes || '-', x, y + FOOTER_ROW_H/2); y += FOOTER_ROW_H;
                o.strokeStyle = '#334155'; o.lineWidth = 0.5; o.beginPath(); o.moveTo(12, y); o.lineTo(OUT_W - 12, y); o.stroke();
            });
        }
    } finally { scale = oldScale; panX = oldPanX; panY = oldPanY; ctx = originalCtx; }
    return { url: out.toDataURL('image/png'), width: OUT_W * DPI, height: OUT_H * DPI };
}

function collectRows(isForExport = false) {
    const rows = [];
    const EXCLUDED_LAYERS = ['label', 'custom_icon', 'bow', 'cords', 'powersource', 'threeway', 'ghostDoor'];
    Object.keys(data).forEach(L => {
        if (EXCLUDED_LAYERS.includes(L)) return;
        const arr = Array.isArray(data[L]) ? data[L] : (data[L] ? [data[L]] : []);
        arr.forEach(it => {
            if (!it || (isForExport && it.isVisible === false)) return;
            if (isForExport) {
                const hasId = it.label && it.label.trim() !== '';
                const hasNotes = it.notes && it.notes.trim() !== '';
                if (!hasId && !hasNotes) return;
            }
            rows.push({ L: L, label: it.label, ft: it.ft || '', bulbs: it.bulbs || '', col: it.col || '', clip: it.clip || '', notes: it.notes || '', fra: it.fra || false, gguard: it.gguard || false, kind: it.kind, item: it });
        });
    });
    return rows;
}

function initializeUI() {
    document.getElementById('inputAllCol').oninput = (e) => {
        const v = e.target.value;
        Object.keys(data).forEach(k => { 
            const arr = Array.isArray(data[k]) ? data[k] : (data[k] ? [data[k]] : []);
            arr.forEach(it => { if(it && it.label) it.col = v; }); 
        });
        requestRender(); 
    };

    // Correct logic for manual toggling of Display Settings accordion
    const dispAcc = document.getElementById('dispAcc');
    const dispAccHead = dispAcc.querySelector('.accHead');
    dispAccHead.onclick = () => {
        dispAcc.classList.toggle('open');
    };

    buildTools(); 
}

document.addEventListener('DOMContentLoaded', () => {
    initializeUI(); initializeAndSizeContext();
    document.getElementById('btnRelabelIDs').onclick = relabelIds;
    document.getElementById('gPickImg').onclick = () => document.getElementById('gImg').click();
    document.getElementById('gPickBlank').onclick = startBlankMap;
    document.getElementById('gPickMap').onclick = () => document.getElementById('gMap').click();
    document.getElementById('gOpenGallery').onclick = openGallery;
    document.getElementById('closeGateBtn').onclick = unlock;
    updateVisibilityMenu();
});
})();
</script>
</body>
</html>
